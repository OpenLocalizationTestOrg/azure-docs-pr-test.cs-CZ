---
title: "Klientská knihovna pro elastické databáze pomocí rozhraní Entity Framework | Microsoft Docs"
description: "Pomocí klientské knihovny pro elastické databáze a Entity Framework pro kódování databází"
services: sql-database
documentationcenter: 
manager: jhubbard
author: torsteng
editor: 
ms.assetid: b9c3065b-cb92-41be-aa7f-deba23e7e159
ms.service: sql-database
ms.custom: scale out apps
ms.workload: sql-database
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 03/06/2017
ms.author: torsteng
ms.openlocfilehash: 2f0bff394c1e11a270cb324be5a1a45e9e531d7f
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/11/2017
---
# <a name="elastic-database-client-library-with-entity-framework"></a><span data-ttu-id="b8471-103">Klientská knihovna pro elastické databáze s platformou Entity Framework</span><span class="sxs-lookup"><span data-stu-id="b8471-103">Elastic Database client library with Entity Framework</span></span>
<span data-ttu-id="b8471-104">Tento dokument ukazuje změny v aplikaci rozhraní Entity Framework, která jsou potřebné k integraci s [nástroje elastické databáze](sql-database-elastic-scale-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="b8471-104">This document shows the changes in an Entity Framework application that are needed to integrate with the [Elastic Database tools](sql-database-elastic-scale-introduction.md).</span></span> <span data-ttu-id="b8471-105">Zaměřuje se na skládání [horizontálního oddílu mapy správu](sql-database-elastic-scale-shard-map-management.md) a [závislé na data směrování](sql-database-elastic-scale-data-dependent-routing.md) s platformou Entity Framework **Code First** přístup.</span><span class="sxs-lookup"><span data-stu-id="b8471-105">The focus is on composing [shard map management](sql-database-elastic-scale-shard-map-management.md) and [data-dependent routing](sql-database-elastic-scale-data-dependent-routing.md) with the Entity Framework **Code First** approach.</span></span> <span data-ttu-id="b8471-106">[Code nejprve - novou databázi](http://msdn.microsoft.com/data/jj193542.aspx) kurz pro EF slouží jako našem příkladu spuštěné v tomto dokumentu.</span><span class="sxs-lookup"><span data-stu-id="b8471-106">The [Code First - New Database](http://msdn.microsoft.com/data/jj193542.aspx) tutorial for EF serves as our running example throughout this document.</span></span> <span data-ttu-id="b8471-107">Ukázkový kód doplňujícími tento dokument je součástí nástroje elastické databáze sada ukázky ve Visual Studio ukázky kódu.</span><span class="sxs-lookup"><span data-stu-id="b8471-107">The sample code accompanying this document is part of elastic database tools' set of samples in the Visual Studio Code Samples.</span></span>

## <a name="downloading-and-running-the-sample-code"></a><span data-ttu-id="b8471-108">Stažení a spuštění ukázkového kódu</span><span class="sxs-lookup"><span data-stu-id="b8471-108">Downloading and Running the Sample Code</span></span>
<span data-ttu-id="b8471-109">Chcete-li stáhnout kód v tomto článku:</span><span class="sxs-lookup"><span data-stu-id="b8471-109">To download the code for this article:</span></span>

* <span data-ttu-id="b8471-110">Visual Studio 2012 nebo novější je povinný.</span><span class="sxs-lookup"><span data-stu-id="b8471-110">Visual Studio 2012 or later is required.</span></span> 
* <span data-ttu-id="b8471-111">Stažení [elastické databáze nástroje pro Azure SQL – ukázka integrace Entity Framework](https://code.msdn.microsoft.com/windowsapps/Elastic-Scale-with-Azure-bae904ba) z webu MSDN.</span><span class="sxs-lookup"><span data-stu-id="b8471-111">Download the [Elastic DB Tools for Azure SQL - Entity Framework Integration sample](https://code.msdn.microsoft.com/windowsapps/Elastic-Scale-with-Azure-bae904ba) from MSDN.</span></span> <span data-ttu-id="b8471-112">Rozbalte vzorku, který se umístění vašeho výběru.</span><span class="sxs-lookup"><span data-stu-id="b8471-112">Unzip the sample to a location of your choosing.</span></span>
* <span data-ttu-id="b8471-113">Spusťte Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="b8471-113">Start Visual Studio.</span></span> 
* <span data-ttu-id="b8471-114">V sadě Visual Studio vyberte soubor -> Otevřít projekt nebo řešení.</span><span class="sxs-lookup"><span data-stu-id="b8471-114">In Visual Studio, select File -> Open Project/Solution.</span></span> 
* <span data-ttu-id="b8471-115">V **otevřít projekt** dialogové okno, přejděte k ukázkové jste stáhli a vyberte **EntityFrameworkCodeFirst.sln** otevřete ukázku.</span><span class="sxs-lookup"><span data-stu-id="b8471-115">In the **Open Project** dialog, navigate to the sample you downloaded and select **EntityFrameworkCodeFirst.sln** to open the sample.</span></span> 

<span data-ttu-id="b8471-116">Ke spuštění ukázky, budete muset vytvořit tři prázdné databáze ve službě Azure SQL Database:</span><span class="sxs-lookup"><span data-stu-id="b8471-116">To run the sample, you need to create three empty databases in Azure SQL Database:</span></span>

* <span data-ttu-id="b8471-117">Horizontálního oddílu mapa správce databáze</span><span class="sxs-lookup"><span data-stu-id="b8471-117">Shard Map Manager database</span></span>
* <span data-ttu-id="b8471-118">Databáze horizontálního oddílu 1</span><span class="sxs-lookup"><span data-stu-id="b8471-118">Shard 1 database</span></span>
* <span data-ttu-id="b8471-119">Databáze horizontálního oddílu 2</span><span class="sxs-lookup"><span data-stu-id="b8471-119">Shard 2 database</span></span>

<span data-ttu-id="b8471-120">Po vytvoření těchto databází, vyplňte zástupného v **Program.cs** se název serveru Azure SQL DB, názvy databáze a pověření pro připojení k databázím.</span><span class="sxs-lookup"><span data-stu-id="b8471-120">Once you have created these databases, fill in the place holders in **Program.cs** with your Azure SQL DB server name, the database names and your credentials to connect to the databases.</span></span> <span data-ttu-id="b8471-121">Sestavte řešení v sadě Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="b8471-121">Build the solution in Visual Studio.</span></span> <span data-ttu-id="b8471-122">Visual Studio stáhne požadované balíčky NuGet pro klientské knihovny elastické databáze Entity Framework a přechodná chyba zpracování v rámci procesu sestavení.</span><span class="sxs-lookup"><span data-stu-id="b8471-122">Visual Studio will download the required NuGet packages for the elastic database client library, Entity Framework, and Transient Fault handling as part of the build process.</span></span> <span data-ttu-id="b8471-123">Ujistěte se, že probíhá obnovení balíčků NuGet je povolena pro vaše řešení.</span><span class="sxs-lookup"><span data-stu-id="b8471-123">Make sure that restoring NuGet packages is enabled for your solution.</span></span> <span data-ttu-id="b8471-124">Toto nastavení můžete povolit kliknutím pravým tlačítkem na soubor řešení v Průzkumníku řešení Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="b8471-124">You can enable this setting by right-clicking on the solution file in the Visual Studio Solution Explorer.</span></span> 

## <a name="entity-framework-workflows"></a><span data-ttu-id="b8471-125">Pracovní postupy Entity Framework</span><span class="sxs-lookup"><span data-stu-id="b8471-125">Entity Framework workflows</span></span>
<span data-ttu-id="b8471-126">Vývojáři Entity Framework využívají následující čtyři pracovních postupů, chcete-li vytvářet aplikace a zajistit trvalosti pro objekty aplikací:</span><span class="sxs-lookup"><span data-stu-id="b8471-126">Entity Framework developers rely on one of the following four workflows to build applications and to ensure persistence for application objects:</span></span> 

* <span data-ttu-id="b8471-127">**Code First (nová databáze)**: EF vývojáře vytvoří model v kódu aplikace a pak EF vygeneruje databázi z něj.</span><span class="sxs-lookup"><span data-stu-id="b8471-127">**Code First (New Database)**: The EF developer creates the model in the application code and then EF generates the database from it.</span></span> 
* <span data-ttu-id="b8471-128">**Code First (existující databáze)**: vývojář umožňuje EF generování kódu aplikace pro model z existující databáze.</span><span class="sxs-lookup"><span data-stu-id="b8471-128">**Code First (Existing Database)**: The developer lets EF generate the application code for the model from an existing database.</span></span>
* <span data-ttu-id="b8471-129">**Model první**: vývojář vytvoří model v EF designeru a pak EF vytvoří databázi z modelu.</span><span class="sxs-lookup"><span data-stu-id="b8471-129">**Model First**: The developer creates the model in the EF designer and then EF creates the database from the model.</span></span>
* <span data-ttu-id="b8471-130">**Databáze první**: vývojář používá EF tooling odvodit modelu z existující databáze.</span><span class="sxs-lookup"><span data-stu-id="b8471-130">**Database First**: The developer uses EF tooling to infer the model from an existing database.</span></span> 

<span data-ttu-id="b8471-131">Všechny tyto přístupy spoléhají na třídy DbContext transparentně Správa připojení k databázi a schéma databáze pro aplikaci.</span><span class="sxs-lookup"><span data-stu-id="b8471-131">All these approaches rely on the DbContext class to transparently manage database connections and database schema for an application.</span></span> <span data-ttu-id="b8471-132">Jak se budeme zabývat podrobněji později v dokumentu, jiné konstruktory na základní třídy DbContext povolit pro různé úrovně kontroly nad vytváření připojení, databáze vytváření zavádění a schéma.</span><span class="sxs-lookup"><span data-stu-id="b8471-132">As we will discuss in more detail later in the document, different constructors on the DbContext base class allow for different levels of control over connection creation, database bootstrapping and schema creation.</span></span> <span data-ttu-id="b8471-133">Problémy jsou vyvolány především na skutečnost, že správu připojení databáze poskytované EF protíná s dat závislé směrování rozhraní poskytuje možnosti správy připojení pomocí klientské knihovny pro elastické databáze.</span><span class="sxs-lookup"><span data-stu-id="b8471-133">Challenges arise primarily from the fact that the database connection management provided by EF intersects with the connection management capabilities of the data dependent routing interfaces provided by the elastic database client library.</span></span> 

## <a name="elastic-database-tools-assumptions"></a><span data-ttu-id="b8471-134">Předpoklady nástroje elastické databáze</span><span class="sxs-lookup"><span data-stu-id="b8471-134">Elastic database tools assumptions</span></span>
<span data-ttu-id="b8471-135">Definice podmínek, najdete v části [Glosář nástroje elastické databáze](sql-database-elastic-scale-glossary.md).</span><span class="sxs-lookup"><span data-stu-id="b8471-135">For term definitions, see [Elastic Database tools glossary](sql-database-elastic-scale-glossary.md).</span></span>

<span data-ttu-id="b8471-136">Klientská knihovna pro elastické databáze definovat oddíly názvem shardlets data aplikací.</span><span class="sxs-lookup"><span data-stu-id="b8471-136">With elastic database client library, you define partitions of your application data called shardlets.</span></span> <span data-ttu-id="b8471-137">Shardlets jsou identifikovány klíč horizontálního dělení a jsou namapované na konkrétní databáze.</span><span class="sxs-lookup"><span data-stu-id="b8471-137">Shardlets are identified by a sharding key and are mapped to specific databases.</span></span> <span data-ttu-id="b8471-138">Aplikace může mít libovolný počet databází, podle potřeby a distribuovat shardlets zajistit dostatek kapacity nebo výkonu zadána aktuální podnikové požadavky.</span><span class="sxs-lookup"><span data-stu-id="b8471-138">An application may have as many databases as needed and distribute the shardlets to provide enough capacity or performance given current business requirements.</span></span> <span data-ttu-id="b8471-139">Mapování hodnot klíče horizontálního dělení k databázím ukládá horizontálního oddílu mapu poskytuje rozhraní API klienta elastické databáze.</span><span class="sxs-lookup"><span data-stu-id="b8471-139">The mapping of sharding key values to the databases is stored by a shard map provided by the elastic database client APIs.</span></span> <span data-ttu-id="b8471-140">Říkáme tato funkce **horizontálního oddílu mapy správu**, nebo pro zkrácení SMM.</span><span class="sxs-lookup"><span data-stu-id="b8471-140">We call this capability **Shard Map Management**, or SMM for short.</span></span> <span data-ttu-id="b8471-141">Mapování horizontálních slouží taky jako zprostředkovatel připojení databáze pro požadavky, které zajišťují klíč horizontálního dělení.</span><span class="sxs-lookup"><span data-stu-id="b8471-141">The shard map also serves as the broker of database connections for requests that carry a sharding key.</span></span> <span data-ttu-id="b8471-142">Tato funkce jako označujeme **závislé na data směrování**.</span><span class="sxs-lookup"><span data-stu-id="b8471-142">We refer to this capability as **data-dependent routing**.</span></span> 

<span data-ttu-id="b8471-143">Mapa správce horizontálního oddílu chrání uživatelé z nekonzistentní zobrazení do shardlet data, která může dojít, když se děje operace správy souběžných shardlet (například přemístění dat z jedné horizontálního oddílu do jiného).</span><span class="sxs-lookup"><span data-stu-id="b8471-143">The shard map manager protects users from inconsistent views into shardlet data that can occur when concurrent shardlet management operations (such as relocating data from one shard to another) are happening.</span></span> <span data-ttu-id="b8471-144">Uděláte to tak mapy horizontálního oddílu spravuje zprostředkovatele knihovny klienta připojení databáze pro aplikaci.</span><span class="sxs-lookup"><span data-stu-id="b8471-144">To do so, the shard maps managed by the client library broker the database connections for an application.</span></span> <span data-ttu-id="b8471-145">To umožňuje funkci horizontálního oddílu mapy automaticky ukončit připojení k databázi, pokud operace správy horizontálního oddílu by mohlo mít vliv shardlet, který byl vytvořen pro připojení.</span><span class="sxs-lookup"><span data-stu-id="b8471-145">This allows the shard map functionality to automatically kill a database connection when shard management operations could impact the shardlet that the connection has been created for.</span></span> <span data-ttu-id="b8471-146">Tento přístup je potřeba integrovat některé EF na funkce, jako je například vytváření nových připojení z existující Zkontrolovat existenci databáze.</span><span class="sxs-lookup"><span data-stu-id="b8471-146">This approach needs to integrate with some of EF’s functionality, such as creating new connections from an existing one to check for database existence.</span></span> <span data-ttu-id="b8471-147">Obecně platí naše pozorování bylo, že standardní konstruktory DbContext pouze pracovní spolehlivě pro uzavřené databázových připojení, která se dají bezpečně klonovat pro EF fungovat.</span><span class="sxs-lookup"><span data-stu-id="b8471-147">In general, our observation has been that the standard DbContext constructors only work reliably for closed database connections that can safely be cloned for EF work.</span></span> <span data-ttu-id="b8471-148">Princip návrhu elastické databáze místo toho je pouze zprostředkovatel otevřené připojení.</span><span class="sxs-lookup"><span data-stu-id="b8471-148">The design principle of elastic database instead is to only broker opened connections.</span></span> <span data-ttu-id="b8471-149">Může být jeden vezměte v úvahu uzavřením připojení pomocí klientské knihovny pro zprostředkované před předání do EF DbContext může vyřešit tento problém.</span><span class="sxs-lookup"><span data-stu-id="b8471-149">One might think that closing a connection brokered by the client library before handing it over to the EF DbContext may solve this issue.</span></span> <span data-ttu-id="b8471-150">Však Probíhá ukončování připojení a spoléhat na EF ho znovu otevřete, jeden foregoes kontroly ověřování a konzistence provádí knihovny.</span><span class="sxs-lookup"><span data-stu-id="b8471-150">However, by closing the connection and relying on EF to re-open it, one foregoes the validation and consistency checks performed by the library.</span></span> <span data-ttu-id="b8471-151">Funkce migrace ve EF, ale používá tato připojení ke správě základní schéma databáze tak, že je transparentní pro aplikace.</span><span class="sxs-lookup"><span data-stu-id="b8471-151">The migrations functionality in EF, however, uses these connections to manage the underlying database schema in a way that is transparent to the application.</span></span> <span data-ttu-id="b8471-152">V ideálním případě by rádi bychom zachovat a kombinace všechny tyto možnosti z klientské knihovny pro elastické databáze a EF ve stejné aplikaci.</span><span class="sxs-lookup"><span data-stu-id="b8471-152">Ideally, we would like to retain and combine all these capabilities from both the elastic database client library and EF in the same application.</span></span> <span data-ttu-id="b8471-153">Následující část popisuje tyto vlastnosti a požadavky podrobněji.</span><span class="sxs-lookup"><span data-stu-id="b8471-153">The following section discusses these properties and requirements in more detail.</span></span> 

## <a name="requirements"></a><span data-ttu-id="b8471-154">Požadavky</span><span class="sxs-lookup"><span data-stu-id="b8471-154">Requirements</span></span>
<span data-ttu-id="b8471-155">Při práci s klientské knihovny pro elastické databáze a Entity Framework rozhraní API, chceme zachovat následující vlastnosti:</span><span class="sxs-lookup"><span data-stu-id="b8471-155">When working with both the elastic database client library and Entity Framework APIs, we want to retain the following properties:</span></span> 

* <span data-ttu-id="b8471-156">**Škálováním na více systémů**: můžete přidat nebo odebrat databáze z datové vrstvy horizontálně dělené aplikace v případě potřeby u požadavky kapacity aplikace.</span><span class="sxs-lookup"><span data-stu-id="b8471-156">**Scale-out**: To add or remove databases from the data tier of the sharded application as necessary for the capacity demands of the application.</span></span> <span data-ttu-id="b8471-157">To znamená řízení přes vytváření a odstraňování databáze a horizontálního oddílu elastické databáze pomocí rozhraní API manager ke správě databáze a mapování shardlets mapy.</span><span class="sxs-lookup"><span data-stu-id="b8471-157">This means control over the the creation and deletion of databases and using the elastic database shard map manager APIs to manage databases, and mappings of shardlets.</span></span> 
* <span data-ttu-id="b8471-158">**Konzistence**: aplikace používá horizontálního dělení a používá závislé směrování funkce dat klientské knihovny.</span><span class="sxs-lookup"><span data-stu-id="b8471-158">**Consistency**: The application employs sharding, and uses the data dependent routing capabilities of the client library.</span></span> <span data-ttu-id="b8471-159">Připojení se pokud chcete vyhnout poškození nebo výsledky dotazu nesprávný, zprostředkované prostřednictvím správce mapy horizontálního oddílu.</span><span class="sxs-lookup"><span data-stu-id="b8471-159">To avoid corruption or wrong query results, connections are brokered through the shard map manager.</span></span> <span data-ttu-id="b8471-160">Zachová také ověření a konzistence.</span><span class="sxs-lookup"><span data-stu-id="b8471-160">This also retains validation and consistency.</span></span>
* <span data-ttu-id="b8471-161">**Code First**: zachování pohodlím, které představuje první zlepší EF na kódu.</span><span class="sxs-lookup"><span data-stu-id="b8471-161">**Code First**: To retain the convenience of EF’s code first paradigm.</span></span> <span data-ttu-id="b8471-162">Code First třídy v aplikaci se mapují transparentně základní struktury databáze.</span><span class="sxs-lookup"><span data-stu-id="b8471-162">In Code First, classes in the application are mapped transparently to the underlying database structures.</span></span> <span data-ttu-id="b8471-163">Kód aplikace komunikuje s DbSets, který maskování většinu aspektů základní zpracování databáze.</span><span class="sxs-lookup"><span data-stu-id="b8471-163">The application code interacts with DbSets that mask most aspects involved in the underlying database processing.</span></span>
* <span data-ttu-id="b8471-164">**Schéma**: rozhraní Entity Framework zpracovává vytvoření schématu počáteční databáze a následné schématu vývoj pomocí migrace.</span><span class="sxs-lookup"><span data-stu-id="b8471-164">**Schema**: Entity Framework handles initial database schema creation and subsequent schema evolution through migrations.</span></span> <span data-ttu-id="b8471-165">Přizpůsobení aplikace je snadné zachováním tyto možnosti, jak zpracovaní data.</span><span class="sxs-lookup"><span data-stu-id="b8471-165">By retaining these capabilities, adapting your app is easy as the data evolves.</span></span> 

<span data-ttu-id="b8471-166">Následující pokyny dá pokyn, jak splnit tyto požadavky pro Code First aplikací pomocí nástroje elastické databáze.</span><span class="sxs-lookup"><span data-stu-id="b8471-166">The following guidance instructs how to satisfy these requirements for Code First applications using elastic database tools.</span></span> 

## <a name="data-dependent-routing-using-ef-dbcontext"></a><span data-ttu-id="b8471-167">Data závislé směrování pomocí EF DbContext</span><span class="sxs-lookup"><span data-stu-id="b8471-167">Data dependent routing using EF DbContext</span></span>
<span data-ttu-id="b8471-168">Databázová připojení s platformou Entity Framework se obvykle spravují prostřednictvím měly podtřídy **DbContext**.</span><span class="sxs-lookup"><span data-stu-id="b8471-168">Database connections with Entity Framework are typically managed through subclasses of **DbContext**.</span></span> <span data-ttu-id="b8471-169">Vytvořit tyto podtřídy odvozené z **DbContext**.</span><span class="sxs-lookup"><span data-stu-id="b8471-169">Create these subclasses by deriving from **DbContext**.</span></span> <span data-ttu-id="b8471-170">Toto je, kde můžete definovat vaše **DbSets** které implementují databáze zálohována kolekce objektů CLR pro vaši aplikaci.</span><span class="sxs-lookup"><span data-stu-id="b8471-170">This is where you define your **DbSets** that implement the database-backed collections of CLR objects for your application.</span></span> <span data-ttu-id="b8471-171">V kontextu dat závislé směrování abychom mohli identifikovat několik užitečné vlastnosti, které nemají nutně další EF code první aplikaci scénáře:</span><span class="sxs-lookup"><span data-stu-id="b8471-171">In the context of data dependent routing, we can identify several helpful properties that do not necessarily hold for other EF code first application scenarios:</span></span> 

* <span data-ttu-id="b8471-172">Databáze již existuje a je zaregistrován v mapě horizontálního oddílu elastické databáze.</span><span class="sxs-lookup"><span data-stu-id="b8471-172">The database already exists and has been registered in the elastic database shard map.</span></span> 
* <span data-ttu-id="b8471-173">Schéma aplikace již byla nasazena do databáze (vysvětlení níže).</span><span class="sxs-lookup"><span data-stu-id="b8471-173">The schema of the application has already been deployed to the database (explained below).</span></span> 
* <span data-ttu-id="b8471-174">Jsou závislé na data směrování připojení k databázi zprostředkované pomocí mapy horizontálního oddílu.</span><span class="sxs-lookup"><span data-stu-id="b8471-174">Data-dependent routing connections to the database are brokered by the shard map.</span></span> 

<span data-ttu-id="b8471-175">K integraci **DbContexts** s závislé na data směrování pro Škálováním na více systémů:</span><span class="sxs-lookup"><span data-stu-id="b8471-175">To integrate **DbContexts** with data-dependent routing for scale-out:</span></span>

1. <span data-ttu-id="b8471-176">Vytvořit fyzická databáze připojení prostřednictvím rozhraní klienta elastické databáze správce mapy horizontálního oddílu,</span><span class="sxs-lookup"><span data-stu-id="b8471-176">Create physical database connections through the elastic database client interfaces of the shard map manager,</span></span> 
2. <span data-ttu-id="b8471-177">Zabalení připojení pomocí **DbContext** podtřídy</span><span class="sxs-lookup"><span data-stu-id="b8471-177">Wrap the connection with the **DbContext** subclass</span></span>
3. <span data-ttu-id="b8471-178">Předat připojení do **DbContext** základní třídy, aby veškeré zpracování na straně EF se také stane.</span><span class="sxs-lookup"><span data-stu-id="b8471-178">Pass the connection down into the **DbContext** base classes to ensure all the processing on the EF side happens as well.</span></span> 

<span data-ttu-id="b8471-179">Následující příklad kódu ukazuje tento přístup.</span><span class="sxs-lookup"><span data-stu-id="b8471-179">The following code example illustrates this approach.</span></span> <span data-ttu-id="b8471-180">(Tento kód se taky v doprovodné projektu sady Visual Studio)</span><span class="sxs-lookup"><span data-stu-id="b8471-180">(This code is also in the accompanying Visual Studio project)</span></span>

    public class ElasticScaleContext<T> : DbContext
    {
    public DbSet<Blog> Blogs { get; set; }
    …

        // C'tor for data dependent routing. This call will open a validated connection 
        // routed to the proper shard by the shard map manager. 
        // Note that the base class c'tor call will fail for an open connection
        // if migrations need to be done and SQL credentials are used. This is the reason for the 
        // separation of c'tors into the data-dependent routing case (this c'tor) and the internal c'tor for new shards.
        public ElasticScaleContext(ShardMap shardMap, T shardingKey, string connectionStr)
            : base(CreateDDRConnection(shardMap, shardingKey, connectionStr), 
            true /* contextOwnsConnection */)
        {
        }

        // Only static methods are allowed in calls into base class c'tors.
        private static DbConnection CreateDDRConnection(
        ShardMap shardMap, 
        T shardingKey, 
        string connectionStr)
        {
            // No initialization
            Database.SetInitializer<ElasticScaleContext<T>>(null);

            // Ask shard map to broker a validated connection for the given key
            SqlConnection conn = shardMap.OpenConnectionForKey<T>
                                (shardingKey, connectionStr, ConnectionOptions.Validate);
            return conn;
        }    

## <a name="main-points"></a><span data-ttu-id="b8471-181">Hlavní body</span><span class="sxs-lookup"><span data-stu-id="b8471-181">Main points</span></span>
* <span data-ttu-id="b8471-182">Nový konstruktor nahradí výchozí konstruktor v DbContext podtřídy</span><span class="sxs-lookup"><span data-stu-id="b8471-182">A new constructor replaces the default constructor in the DbContext subclass</span></span> 
* <span data-ttu-id="b8471-183">Nový konstruktor přijímá argumenty, které jsou požadovány pro závislé směrování dat přes klientské knihovny pro elastické databáze:</span><span class="sxs-lookup"><span data-stu-id="b8471-183">The new constructor takes the arguments that are required for data dependent routing through elastic database client library:</span></span>
  
  * <span data-ttu-id="b8471-184">mapování horizontálních pro přístup k rozhraní směrování závislé na data</span><span class="sxs-lookup"><span data-stu-id="b8471-184">the shard map to access the data-dependent routing interfaces,</span></span>
  * <span data-ttu-id="b8471-185">klíč horizontálního dělení k identifikaci shardlet,</span><span class="sxs-lookup"><span data-stu-id="b8471-185">the sharding key to identify the shardlet,</span></span>
  * <span data-ttu-id="b8471-186">připojovací řetězec s přihlašovacími údaji pro závislé na data směrování připojení k horizontálního oddílu.</span><span class="sxs-lookup"><span data-stu-id="b8471-186">a connection string with the credentials for the data-dependent routing connection to the shard.</span></span> 
* <span data-ttu-id="b8471-187">Volání konstruktoru základní třídy zohledňuje detour statickou metodu, která provádí všechny kroky potřebné pro směrování závislé na data.</span><span class="sxs-lookup"><span data-stu-id="b8471-187">The call to the base class constructor takes a detour into a static method that performs all the steps necessary for data-dependent routing.</span></span> 
  
  * <span data-ttu-id="b8471-188">Volání OpenConnectionForKey rozhraní klienta elastické databáze na mapě horizontálního oddílu používá k navázání otevřené připojení.</span><span class="sxs-lookup"><span data-stu-id="b8471-188">It uses the OpenConnectionForKey call of the elastic database client interfaces on the shard map to establish an open connection.</span></span>
  * <span data-ttu-id="b8471-189">Mapování horizontálních vytvoří otevřít připojení k horizontálního oddílu, který obsahuje shardlet pro danou horizontálního dělení klíč.</span><span class="sxs-lookup"><span data-stu-id="b8471-189">The shard map creates the open connection to the shard that holds the shardlet for the given sharding key.</span></span>
  * <span data-ttu-id="b8471-190">Toto otevřené připojení se předá zpět do konstruktoru základní třídy DbContext k označení, že je toto připojení má být používána EF místo EF automaticky vytvořit nové připojení.</span><span class="sxs-lookup"><span data-stu-id="b8471-190">This open connection is passed back to the base class constructor of DbContext to indicate that this connection is to be used by EF instead of letting EF create a new connection automatically.</span></span> <span data-ttu-id="b8471-191">Tímto způsobem připojení má byla označená klientem elastické databáze rozhraní API, tak, aby ho může zaručit konzistenci v rámci operace správy mapy horizontálního oddílu.</span><span class="sxs-lookup"><span data-stu-id="b8471-191">This way the connection has been tagged by the elastic database client API so that it can guarantee consistency under shard map management operations.</span></span>

<span data-ttu-id="b8471-192">Pomocí konstruktoru new podtřídy DbContext místo výchozí konstruktor v kódu.</span><span class="sxs-lookup"><span data-stu-id="b8471-192">Use the new constructor for your DbContext subclass instead of the default constructor in your code.</span></span> <span data-ttu-id="b8471-193">Zde naleznete příklad:</span><span class="sxs-lookup"><span data-stu-id="b8471-193">Here is an example:</span></span> 

    // Create and save a new blog.

    Console.Write("Enter a name for a new blog: "); 
    var name = Console.ReadLine(); 

    using (var db = new ElasticScaleContext<int>( 
                            sharding.ShardMap,  
                            tenantId1,  
                            connStrBldr.ConnectionString)) 
    { 
        var blog = new Blog { Name = name }; 
        db.Blogs.Add(blog); 
        db.SaveChanges(); 

        // Display all Blogs for tenant 1 
        var query = from b in db.Blogs 
                    orderby b.Name 
                    select b; 
     … 
    }

<span data-ttu-id="b8471-194">Nový konstruktor otevře připojení k horizontálního oddílu, který obsahuje data pro shardlet identifikovaný hodnotu **tenantid1**.</span><span class="sxs-lookup"><span data-stu-id="b8471-194">The new constructor opens the connection to the shard that holds the data for the shardlet identified by the value of **tenantid1**.</span></span> <span data-ttu-id="b8471-195">Kód v **pomocí** bloku zůstává beze změny, abyste měli přístup **DbSet** pro blogy pomocí EF na horizontálního oddílu pro **tenantid1**.</span><span class="sxs-lookup"><span data-stu-id="b8471-195">The code in the **using** block stays unchanged to access the **DbSet** for blogs using EF on the shard for **tenantid1**.</span></span> <span data-ttu-id="b8471-196">Tato operace změní sémantiku pro kód v pomocí blokovat tak, že všechny databázové operace jsou nyní vymezeny na jednu horizontálního oddílu kde **tenantid1** je uložen.</span><span class="sxs-lookup"><span data-stu-id="b8471-196">This changes semantics for the code in the using block such that all database operations are now scoped to the one shard where **tenantid1** is kept.</span></span> <span data-ttu-id="b8471-197">Například dotaz LINQ přes na blozích **DbSet** vrátí pouze uložené na aktuální horizontálního oddílu blogy, ale není těm, které jsou uložené na jiné horizontálních oddílů.</span><span class="sxs-lookup"><span data-stu-id="b8471-197">For instance, a LINQ query over the blogs **DbSet** would only return blogs stored on the current shard, but not the ones stored on other shards.</span></span>  

#### <a name="transient-faults-handling"></a><span data-ttu-id="b8471-198">Zpracování přechodné chyby</span><span class="sxs-lookup"><span data-stu-id="b8471-198">Transient faults handling</span></span>
<span data-ttu-id="b8471-199">Tým postupy společnosti Microsoft Patterns publikována [The přechodné chyby zpracování aplikace bloku](https://msdn.microsoft.com/library/dn440719.aspx).</span><span class="sxs-lookup"><span data-stu-id="b8471-199">The Microsoft Patterns & Practices team published the [The Transient Fault Handling Application Block](https://msdn.microsoft.com/library/dn440719.aspx).</span></span> <span data-ttu-id="b8471-200">Knihovny se používá v kombinaci s EF Klientská knihovna pro elastické škálování.</span><span class="sxs-lookup"><span data-stu-id="b8471-200">The library is used with elastic scale client library in combination with EF.</span></span> <span data-ttu-id="b8471-201">Však zajistěte, že všechny přechodný výjimka vrátí na místo, kde jsme můžete zajistit, že nový konstruktor je použit po přechodná chyba tak, aby všechny nový pokus o připojení se provádí pomocí konstruktorů, které jsme mít tweaked.</span><span class="sxs-lookup"><span data-stu-id="b8471-201">However, ensure that any transient exception returns to a place where we can ensure that the new constructor is being used after a transient fault so that any new connection attempt is made using the constructors we have tweaked.</span></span> <span data-ttu-id="b8471-202">Jinak hodnota není zaručena připojení ke správné horizontálního oddílu, a neexistují žádné záruky, které jsou prováděny změny mapy horizontálního oddílu se zachová připojení.</span><span class="sxs-lookup"><span data-stu-id="b8471-202">Otherwise, a connection to the correct shard is not guaranteed, and there are no assurances the connection is maintained as changes to the shard map occur.</span></span> 

<span data-ttu-id="b8471-203">Následující příklad kódu ukazuje použití zásady opakování SQL kolem nové **DbContext** podtřídami konstruktory:</span><span class="sxs-lookup"><span data-stu-id="b8471-203">The following code sample illustrates how a SQL retry policy can be used around the new **DbContext** subclass constructors:</span></span> 

    SqlDatabaseUtils.SqlRetryPolicy.ExecuteAction(() => 
    { 
        using (var db = new ElasticScaleContext<int>( 
                                sharding.ShardMap,  
                                tenantId1,  
                                connStrBldr.ConnectionString)) 
            { 
                    var blog = new Blog { Name = name }; 
                    db.Blogs.Add(blog); 
                    db.SaveChanges(); 
            … 
            } 
        }); 

<span data-ttu-id="b8471-204">**SqlDatabaseUtils.SqlRetryPolicy** ve výše uvedeném kódu je definován jako **SqlDatabaseTransientErrorDetectionStrategy** s počtem opakování 10 a 5 sekund čekací dobu mezi opakovanými pokusy.</span><span class="sxs-lookup"><span data-stu-id="b8471-204">**SqlDatabaseUtils.SqlRetryPolicy** in the code above is defined as a **SqlDatabaseTransientErrorDetectionStrategy** with a retry count of 10, and 5 seconds wait time between retries.</span></span> <span data-ttu-id="b8471-205">Tento přístup je podobná pokyny pro EF a uživatel spustil transakce (viz [omezení s opakováním strategie provádění (EF6 a vyšší)](http://msdn.microsoft.com/data/dn307226).</span><span class="sxs-lookup"><span data-stu-id="b8471-205">This approach is similar to the guidance for EF and user-initiated transactions (see [Limitations with Retrying Execution Strategies (EF6 onwards)](http://msdn.microsoft.com/data/dn307226).</span></span> <span data-ttu-id="b8471-206">Obě situace vyžadují, aplikace programu určí obor, ke které se vrátí přechodný výjimka: Otevřete transakce, nebo (jak je znázorněno) znovu vytvořte kontext z správné konstruktor, který používá klientské knihovny pro elastické databáze.</span><span class="sxs-lookup"><span data-stu-id="b8471-206">Both situations require that the application program controls the scope to which the transient exception returns: to either reopen the transaction, or (as shown) recreate the context from the proper constructor that uses the elastic database client library.</span></span>

<span data-ttu-id="b8471-207">Potřeba řídit, kde přechodné výjimky trvat nám zpět v oboru také neumožňuje použití předdefinované **SqlAzureExecutionStrategy** dodávaný s EF.</span><span class="sxs-lookup"><span data-stu-id="b8471-207">The need to control where transient exceptions take us back in scope also precludes the use of the built-in **SqlAzureExecutionStrategy** that comes with EF.</span></span> <span data-ttu-id="b8471-208">**SqlAzureExecutionStrategy** by znovu otevřít připojení, ale nechcete použít **OpenConnectionForKey** a proto všechny ověření, které se provádí v rámci obejít **OpenConnectionForKey**volání.</span><span class="sxs-lookup"><span data-stu-id="b8471-208">**SqlAzureExecutionStrategy** would reopen a connection but not use **OpenConnectionForKey** and therefore bypass all the validation that is performed as part of the **OpenConnectionForKey** call.</span></span> <span data-ttu-id="b8471-209">Místo toho ukázkový kód používá integrované **DefaultExecutionStrategy** také dodávaný s EF.</span><span class="sxs-lookup"><span data-stu-id="b8471-209">Instead, the code sample uses the built-in **DefaultExecutionStrategy** that also comes with EF.</span></span> <span data-ttu-id="b8471-210">Naproti tomu **SqlAzureExecutionStrategy**, funguje správně v kombinaci s zásady opakování z přechodných chyb.</span><span class="sxs-lookup"><span data-stu-id="b8471-210">As opposed to **SqlAzureExecutionStrategy**, it works correctly in combination with the retry policy from Transient Fault Handling.</span></span> <span data-ttu-id="b8471-211">Zásada spouštění nastavena v **ElasticScaleDbConfiguration** třídy.</span><span class="sxs-lookup"><span data-stu-id="b8471-211">The execution policy is set in the **ElasticScaleDbConfiguration** class.</span></span> <span data-ttu-id="b8471-212">Všimněte si, že jsme se rozhodli nepoužívat **DefaultSqlExecutionStrategy** vzhledem k tomu, že se doporučuje používat **SqlAzureExecutionStrategy** Pokud dojde k přechodné výjimky - popsané, což by způsobit nesprávné chování.</span><span class="sxs-lookup"><span data-stu-id="b8471-212">Note that we decided not to use **DefaultSqlExecutionStrategy** since it suggests to use **SqlAzureExecutionStrategy** if transient exceptions occur - which would lead to wrong behavior as discussed.</span></span> <span data-ttu-id="b8471-213">Další informace o různých opakování zásady a EF najdete v tématu [odolnost připojení v EF](http://msdn.microsoft.com/data/dn456835.aspx).</span><span class="sxs-lookup"><span data-stu-id="b8471-213">For more information on the different retry policies and EF, see [Connection Resiliency in EF](http://msdn.microsoft.com/data/dn456835.aspx).</span></span>     

#### <a name="constructor-rewrites"></a><span data-ttu-id="b8471-214">Konstruktor přepisů</span><span class="sxs-lookup"><span data-stu-id="b8471-214">Constructor rewrites</span></span>
<span data-ttu-id="b8471-215">Výše uvedený kód příklady ilustrují, výchozí konstruktor znovu zapíše potřebné pro vaši aplikaci k použití dat závislé směrování s rozhraní Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="b8471-215">The code examples above illustrate the default constructor re-writes required for your application in order to use  data dependent routing with the Entity Framework.</span></span> <span data-ttu-id="b8471-216">Následující tabulka umožňuje zobecnit tento přístup k jiné konstruktory.</span><span class="sxs-lookup"><span data-stu-id="b8471-216">The following table generalizes this approach to other constructors.</span></span> 

| <span data-ttu-id="b8471-217">Aktuální – konstruktor</span><span class="sxs-lookup"><span data-stu-id="b8471-217">Current Constructor</span></span> | <span data-ttu-id="b8471-218">Přepsaná konstruktor pro data</span><span class="sxs-lookup"><span data-stu-id="b8471-218">Rewritten Constructor for data</span></span> | <span data-ttu-id="b8471-219">Základní – konstruktor</span><span class="sxs-lookup"><span data-stu-id="b8471-219">Base Constructor</span></span> | <span data-ttu-id="b8471-220">Poznámky</span><span class="sxs-lookup"><span data-stu-id="b8471-220">Notes</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="b8471-221">MyContext()</span><span class="sxs-lookup"><span data-stu-id="b8471-221">MyContext()</span></span> |<span data-ttu-id="b8471-222">ElasticScaleContext (ShardMap, TKey)</span><span class="sxs-lookup"><span data-stu-id="b8471-222">ElasticScaleContext(ShardMap, TKey)</span></span> |<span data-ttu-id="b8471-223">DbContext (DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="b8471-223">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="b8471-224">Připojení musí být funkce mapy horizontálního oddílu a klíč směrování závislé na data.</span><span class="sxs-lookup"><span data-stu-id="b8471-224">The connection needs to be a function of the shard map and the data-dependent routing key.</span></span> <span data-ttu-id="b8471-225">Je třeba se obejít automatické připojení k vytvoření správcem EF a místo toho použijte mapování horizontálních k Zprostředkovatel připojení.</span><span class="sxs-lookup"><span data-stu-id="b8471-225">You need to by-pass automatic connection creation by EF and instead use the shard map to broker the connection.</span></span> |
| <span data-ttu-id="b8471-226">MyContext(string)</span><span class="sxs-lookup"><span data-stu-id="b8471-226">MyContext(string)</span></span> |<span data-ttu-id="b8471-227">ElasticScaleContext (ShardMap, TKey)</span><span class="sxs-lookup"><span data-stu-id="b8471-227">ElasticScaleContext(ShardMap, TKey)</span></span> |<span data-ttu-id="b8471-228">DbContext (DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="b8471-228">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="b8471-229">Připojení je funkce mapy horizontálního oddílu a klíč směrování závislé na data.</span><span class="sxs-lookup"><span data-stu-id="b8471-229">The connection is a function of the shard map and the data-dependent routing key.</span></span> <span data-ttu-id="b8471-230">Pevné databázové název nebo připojovací řetězec nebude fungovat jako jejich obejít ověření pomocí mapy horizontálního oddílu.</span><span class="sxs-lookup"><span data-stu-id="b8471-230">A fixed database name or connection string will not work as they by-pass validation by the shard map.</span></span> |
| <span data-ttu-id="b8471-231">MyContext(DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="b8471-231">MyContext(DbCompiledModel)</span></span> |<span data-ttu-id="b8471-232">ElasticScaleContext (ShardMap TKey, DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="b8471-232">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span></span> |<span data-ttu-id="b8471-233">DbContext (DbConnection, DbCompiledModel, logická hodnota)</span><span class="sxs-lookup"><span data-stu-id="b8471-233">DbContext(DbConnection, DbCompiledModel, bool)</span></span> |<span data-ttu-id="b8471-234">Připojení budou vytvořeny pro dané ID horizontálního oddílu mapy a horizontálního dělení klíč s modelem zadat.</span><span class="sxs-lookup"><span data-stu-id="b8471-234">The connection will get created for the given shard map and sharding key with the model provided.</span></span> <span data-ttu-id="b8471-235">Kompilované modelu se předá základní c'tor.</span><span class="sxs-lookup"><span data-stu-id="b8471-235">The compiled model will be passed on to the base c’tor.</span></span> |
| <span data-ttu-id="b8471-236">MyContext (DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="b8471-236">MyContext(DbConnection, bool)</span></span> |<span data-ttu-id="b8471-237">ElasticScaleContext (ShardMap TKey, logická hodnota)</span><span class="sxs-lookup"><span data-stu-id="b8471-237">ElasticScaleContext(ShardMap, TKey, bool)</span></span> |<span data-ttu-id="b8471-238">DbContext (DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="b8471-238">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="b8471-239">Připojení je potřeba odvodit z mapy horizontálního oddílu a klíč.</span><span class="sxs-lookup"><span data-stu-id="b8471-239">The connection needs to be inferred from the shard map and the key.</span></span> <span data-ttu-id="b8471-240">Jako vstup nemůže být zadaný (Pokud je tento vstup byl již pomocí mapy horizontálního oddílu a klíč).</span><span class="sxs-lookup"><span data-stu-id="b8471-240">It cannot be provided as an input (unless that input was already using the shard map and the key).</span></span> <span data-ttu-id="b8471-241">Logickou hodnotu, budou předány.</span><span class="sxs-lookup"><span data-stu-id="b8471-241">The Boolean will be passed on.</span></span> |
| <span data-ttu-id="b8471-242">MyContext (string, DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="b8471-242">MyContext(string, DbCompiledModel)</span></span> |<span data-ttu-id="b8471-243">ElasticScaleContext (ShardMap TKey, DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="b8471-243">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span></span> |<span data-ttu-id="b8471-244">DbContext (DbConnection, DbCompiledModel, logická hodnota)</span><span class="sxs-lookup"><span data-stu-id="b8471-244">DbContext(DbConnection, DbCompiledModel, bool)</span></span> |<span data-ttu-id="b8471-245">Připojení je potřeba odvodit z mapy horizontálního oddílu a klíč.</span><span class="sxs-lookup"><span data-stu-id="b8471-245">The connection needs to be inferred from the shard map and the key.</span></span> <span data-ttu-id="b8471-246">Jako vstup nemůže být zadaný (Pokud je tento vstup byl pomocí mapy horizontálního oddílu a klíč).</span><span class="sxs-lookup"><span data-stu-id="b8471-246">It cannot be provided as an input (unless that input was using the shard map and the key).</span></span> <span data-ttu-id="b8471-247">Kompilované modelu se předají.</span><span class="sxs-lookup"><span data-stu-id="b8471-247">The compiled model will be passed on.</span></span> |
| <span data-ttu-id="b8471-248">MyContext (ObjectContext, bool)</span><span class="sxs-lookup"><span data-stu-id="b8471-248">MyContext(ObjectContext, bool)</span></span> |<span data-ttu-id="b8471-249">ElasticScaleContext (ShardMap, TKey, ObjectContext, bool)</span><span class="sxs-lookup"><span data-stu-id="b8471-249">ElasticScaleContext(ShardMap, TKey, ObjectContext, bool)</span></span> |<span data-ttu-id="b8471-250">DbContext (ObjectContext, bool)</span><span class="sxs-lookup"><span data-stu-id="b8471-250">DbContext(ObjectContext, bool)</span></span> |<span data-ttu-id="b8471-251">Nový konstruktor musí zajistit, aby jakékoli připojení ve třídě ObjectContext předat jako vstup znovu směrované na připojení spravuje elastické škálování.</span><span class="sxs-lookup"><span data-stu-id="b8471-251">The new constructor needs to ensure that any connection in the ObjectContext passed as an input is re-routed to a connection managed by Elastic Scale.</span></span> <span data-ttu-id="b8471-252">Podrobnou diskuzi o ObjectContexts je nad rámec tohoto dokumentu.</span><span class="sxs-lookup"><span data-stu-id="b8471-252">A detailed discussion of ObjectContexts is beyond the scope of this document.</span></span> |
| <span data-ttu-id="b8471-253">MyContext (DbConnection, DbCompiledModel, logická hodnota)</span><span class="sxs-lookup"><span data-stu-id="b8471-253">MyContext(DbConnection, DbCompiledModel,bool)</span></span> |<span data-ttu-id="b8471-254">ElasticScaleContext (ShardMap, bool TKey, DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="b8471-254">ElasticScaleContext(ShardMap, TKey, DbCompiledModel, bool)</span></span> |<span data-ttu-id="b8471-255">DbContext (DbConnection, DbCompiledModel, logická hodnota);</span><span class="sxs-lookup"><span data-stu-id="b8471-255">DbContext(DbConnection, DbCompiledModel, bool);</span></span> |<span data-ttu-id="b8471-256">Připojení je potřeba odvodit z mapy horizontálního oddílu a klíč.</span><span class="sxs-lookup"><span data-stu-id="b8471-256">The connection needs to be inferred from the shard map and the key.</span></span> <span data-ttu-id="b8471-257">Připojení nelze zadat jako vstup (Pokud je tento vstup byl již pomocí mapy horizontálního oddílu a klíč).</span><span class="sxs-lookup"><span data-stu-id="b8471-257">The connection cannot be provided as an input (unless that input was already using the shard map and the key).</span></span> <span data-ttu-id="b8471-258">Model a logickou hodnotu jsou předány konstruktor základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b8471-258">Model and Boolean are passed on to the base class constructor.</span></span> |

## <a name="shard-schema-deployment-through-ef-migrations"></a><span data-ttu-id="b8471-259">Nasazení schématu horizontálního oddílu pomocí EF migrace</span><span class="sxs-lookup"><span data-stu-id="b8471-259">Shard schema deployment through EF migrations</span></span>
<span data-ttu-id="b8471-260">Správa automatického schématu je pro vaše pohodlí poskytované rozhraní Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="b8471-260">Automatic schema management is a convenience provided by the Entity Framework.</span></span> <span data-ttu-id="b8471-261">V souvislosti s aplikací pomocí nástroje elastické databáze chceme zachovat tato funkce automaticky zřídit schéma tak, aby nově vytvořený horizontálních oddílů po přidání databází do horizontálně dělené aplikace.</span><span class="sxs-lookup"><span data-stu-id="b8471-261">In the context of applications using elastic database tools, we want to retain this capability to automatically provision the schema to newly created shards when databases are added to the sharded application.</span></span> <span data-ttu-id="b8471-262">Případem primárního použití je zvýšit kapacitu na datové vrstvě pro horizontálně dělenou aplikací s využitím EF.</span><span class="sxs-lookup"><span data-stu-id="b8471-262">The primary use case is to increase capacity at the data tier for sharded applications using EF.</span></span> <span data-ttu-id="b8471-263">S horizontálně dělené aplikací postavené na EF spoléhat na EF na funkce pro správu schématu sníží úsilí správu databáze.</span><span class="sxs-lookup"><span data-stu-id="b8471-263">Relying on EF’s capabilities for schema management reduces the database administration effort with a sharded application built on EF.</span></span> 

<span data-ttu-id="b8471-264">Nasazení schématu pomocí migrace EF funguje nejlépe na **nebyla otevřena připojení**.</span><span class="sxs-lookup"><span data-stu-id="b8471-264">Schema deployment through EF migrations works best on **unopened connections**.</span></span> <span data-ttu-id="b8471-265">To je tento scénář pro data, které jsou závislé na rozdíl od směrování, spoléhá na otevřené připojení poskytnutý klientem elastické databáze rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="b8471-265">This is in contrast to the scenario for data dependent routing that relies on the opened connection provided by the elastic database client API.</span></span> <span data-ttu-id="b8471-266">Další rozdíl je požadavek na konzistence: při žádoucí zajistit konzistenci pro všechny závislé na data směrování připojení k ochraně proti manipulaci mapy souběžných horizontálního oddílu, se nejedná o problém s počátečním nasazení schématu pro nové databáze má ještě není zaregistrována v mapě horizontálního oddílu a ještě není byl přidělen k uchování shardlets.</span><span class="sxs-lookup"><span data-stu-id="b8471-266">Another difference is the consistency requirement: While desirable to ensure consistency for all data-dependent routing connections to protect against concurrent shard map manipulation, it is not a concern with initial schema deployment to a new database that has not yet been registered in the shard map, and not yet been allocated to hold shardlets.</span></span> <span data-ttu-id="b8471-267">Jsme můžete proto spoléhají na standardní databázi připojení pro tento scénáře, a závislé na data směrování.</span><span class="sxs-lookup"><span data-stu-id="b8471-267">We can therefore rely on regular database connections for this scenarios, as opposed to data-dependent routing.</span></span>  

<span data-ttu-id="b8471-268">To vede k přístup, kde nasazení schématu pomocí EF migrace je úzce spojeny s registrací nové databáze jako horizontálního oddílu v mapě horizontálního oddílu aplikace.</span><span class="sxs-lookup"><span data-stu-id="b8471-268">This leads to an approach where schema deployment through EF migrations is tightly coupled with the registration of the new database as a shard in the application’s shard map.</span></span> <span data-ttu-id="b8471-269">To závisí na následující požadavky:</span><span class="sxs-lookup"><span data-stu-id="b8471-269">This relies on the following prerequisites:</span></span> 

* <span data-ttu-id="b8471-270">Databáze již existuje.</span><span class="sxs-lookup"><span data-stu-id="b8471-270">The database has already been created.</span></span> 
* <span data-ttu-id="b8471-271">Databáze je prázdný – drží žádné schéma uživatele a žádná uživatelská data.</span><span class="sxs-lookup"><span data-stu-id="b8471-271">The database is empty - it holds no user schema and no user data.</span></span>
* <span data-ttu-id="b8471-272">Databázi nelze ještě přistupovat prostřednictvím rozhraní API klienta elastické databáze pro směrování závislé na data.</span><span class="sxs-lookup"><span data-stu-id="b8471-272">The database cannot yet be accessed through the elastic database client APIs for data-dependent routing.</span></span> 

<span data-ttu-id="b8471-273">Tyto požadavky splněny, můžeme vytvořit běžný zrušení otevřenou **SqlConnection** k ji EF migrace pro nasazení schématu.</span><span class="sxs-lookup"><span data-stu-id="b8471-273">With these prerequisites in place, we can create a regular un-opened **SqlConnection** to kick off EF migrations for schema deployment.</span></span> <span data-ttu-id="b8471-274">Následující příklad kódu ukazuje tento přístup.</span><span class="sxs-lookup"><span data-stu-id="b8471-274">The following code sample illustrates this approach.</span></span> 

        // Enter a new shard - i.e. an empty database - to the shard map, allocate a first tenant to it  
        // and kick off EF intialization of the database to deploy schema 

        public void RegisterNewShard(string server, string database, string connStr, int key) 
        { 

            Shard shard = this.ShardMap.CreateShard(new ShardLocation(server, database)); 

            SqlConnectionStringBuilder connStrBldr = new SqlConnectionStringBuilder(connStr); 
            connStrBldr.DataSource = server; 
            connStrBldr.InitialCatalog = database; 

            // Go into a DbContext to trigger migrations and schema deployment for the new shard. 
            // This requires an un-opened connection. 
            using (var db = new ElasticScaleContext<int>(connStrBldr.ConnectionString)) 
            { 
                // Run a query to engage EF migrations 
                (from b in db.Blogs 
                    select b).Count(); 
            } 

            // Register the mapping of the tenant to the shard in the shard map. 
            // After this step, data-dependent routing on the shard map can be used 

            this.ShardMap.CreatePointMapping(key, shard); 
        } 


<span data-ttu-id="b8471-275">Tento příklad ukazuje metodu **RegisterNewShard** , zaregistruje horizontálního oddílu v mapě horizontálního oddílu, nasadí schéma prostřednictvím EF migrace a ukládá zajišťuje mapování klíč horizontálního dělení do horizontálního oddílu.</span><span class="sxs-lookup"><span data-stu-id="b8471-275">This sample shows the method **RegisterNewShard** that registers the shard in the shard map, deploys the schema through EF migrations, and stores a mapping of a sharding key to the shard.</span></span> <span data-ttu-id="b8471-276">Přitom spoléhá na konstruktoru objektu **DbContext** podtřídami (**ElasticScaleContext** v ukázce), která má jako vstup připojovací řetězec SQL.</span><span class="sxs-lookup"><span data-stu-id="b8471-276">It relies on a constructor of the **DbContext** subclass (**ElasticScaleContext** in the sample) that takes a SQL connection string as input.</span></span> <span data-ttu-id="b8471-277">Kód tento konstruktor je jednoduché, jak ukazuje následující příklad:</span><span class="sxs-lookup"><span data-stu-id="b8471-277">The code of this constructor is straight-forward, as the following example shows:</span></span> 

        // C'tor to deploy schema and migrations to a new shard 
        protected internal ElasticScaleContext(string connectionString) 
            : base(SetInitializerForConnection(connectionString)) 
        { 
        } 

        // Only static methods are allowed in calls into base class c'tors 
        private static string SetInitializerForConnection(string connnectionString) 
        { 
            // We want existence checks so that the schema can get deployed 
            Database.SetInitializer<ElasticScaleContext<T>>( 
        new CreateDatabaseIfNotExists<ElasticScaleContext<T>>()); 

            return connnectionString; 
        } 

<span data-ttu-id="b8471-278">Jeden použili verze konstruktoru zděděn ze základní třídy.</span><span class="sxs-lookup"><span data-stu-id="b8471-278">One might have used the version of the constructor inherited from the base class.</span></span> <span data-ttu-id="b8471-279">Je však nutné zajistit, aby používala výchozí inicializátoru pro EF při připojování kód.</span><span class="sxs-lookup"><span data-stu-id="b8471-279">But the code needs to ensure that the default initializer for EF is used when connecting.</span></span> <span data-ttu-id="b8471-280">Proto krátké obcházejí do statickou metodu před voláním do konstruktoru základní třídy připojovacím řetězcem.</span><span class="sxs-lookup"><span data-stu-id="b8471-280">Hence the short detour into the static method before calling into the base class constructor with the connection string.</span></span> <span data-ttu-id="b8471-281">Všimněte si, že registrace horizontálních oddílů měly být spuštěny v jiné domény aplikace nebo proces, který zajišťuje, že nastavení inicializátoru EF nejsou v konfliktu.</span><span class="sxs-lookup"><span data-stu-id="b8471-281">Note that the registration of shards should run in a different app domain or process to ensure that the initializer settings for EF do not conflict.</span></span> 

## <a name="limitations"></a><span data-ttu-id="b8471-282">Omezení</span><span class="sxs-lookup"><span data-stu-id="b8471-282">Limitations</span></span>
<span data-ttu-id="b8471-283">Přístupy uvedených v tomto dokumentu za následek několik omezení:</span><span class="sxs-lookup"><span data-stu-id="b8471-283">The approaches outlined in this document entail a couple of limitations:</span></span> 

* <span data-ttu-id="b8471-284">EF aplikace, které používají **LocalDb** nejprve budete muset migrovat na standardní databázi systému SQL Server před použitím klientské knihovny pro elastické databáze.</span><span class="sxs-lookup"><span data-stu-id="b8471-284">EF applications that use **LocalDb** first need to migrate to a regular SQL Server database before using elastic database client library.</span></span> <span data-ttu-id="b8471-285">Horizontální navýšení kapacity aplikace prostřednictvím horizontálního dělení s elastickým Škálováním není možné pomocí **LocalDb**.</span><span class="sxs-lookup"><span data-stu-id="b8471-285">Scaling out an application through sharding with Elastic Scale is not possible with **LocalDb**.</span></span> <span data-ttu-id="b8471-286">Všimněte si, že vývoj můžete nadále používat **LocalDb**.</span><span class="sxs-lookup"><span data-stu-id="b8471-286">Note that development can still use **LocalDb**.</span></span> 
* <span data-ttu-id="b8471-287">Všechny změny do aplikace, které implikují změny schématu databáze muset projít EF migrace na všechny horizontálních oddílů.</span><span class="sxs-lookup"><span data-stu-id="b8471-287">Any changes to the application that imply database schema changes need to go through EF migrations on all shards.</span></span> <span data-ttu-id="b8471-288">Ukázkový kód pro tento dokument není ukazují, jak to udělat.</span><span class="sxs-lookup"><span data-stu-id="b8471-288">The sample code for this document does not demonstrate how to do this.</span></span> <span data-ttu-id="b8471-289">Zvažte použití Update-Database s parametrem ConnectionString Iterujte přes všechny horizontálních oddílů; nebo extrahuje skriptu T-SQL pro migraci čekající na vyřízení pomocí Update-Database-skript s možnost a použít skriptu T-SQL pro vaše horizontálních oddílů.</span><span class="sxs-lookup"><span data-stu-id="b8471-289">Consider using Update-Database with a ConnectionString parameter to iterate over all shards; or extract the T-SQL script for the pending migration using Update-Database with the -Script option and apply the T-SQL script to your shards.</span></span>  
* <span data-ttu-id="b8471-290">Zadaný požadavek, se předpokládá, že určeno klíčem horizontálního dělení poskytované žádost, všechny její zpracování databáze je obsažena v jedné horizontálního oddílu.</span><span class="sxs-lookup"><span data-stu-id="b8471-290">Given a request, it is assumed that all of its database processing is contained within a single shard as identified by the sharding key provided by the request.</span></span> <span data-ttu-id="b8471-291">Však tento předpoklad vždy nemá hodnotu true.</span><span class="sxs-lookup"><span data-stu-id="b8471-291">However, this assumption does not always hold true.</span></span> <span data-ttu-id="b8471-292">Například když není možné zpřístupnit klíč horizontálního dělení.</span><span class="sxs-lookup"><span data-stu-id="b8471-292">For example, when it is not possible to make a sharding key available.</span></span> <span data-ttu-id="b8471-293">Chcete-li vyřešit tím, poskytuje knihovna klienta **MultiShardQuery** třídu, která implementuje abstraktní připojení pro dotazování přes několik horizontálních oddílů.</span><span class="sxs-lookup"><span data-stu-id="b8471-293">To address this, the client library provides the **MultiShardQuery** class that implements a connection abstraction for querying over several shards.</span></span> <span data-ttu-id="b8471-294">Osvojit si **MultiShardQuery** v kombinaci s EF je nad rámec tohoto dokumentu</span><span class="sxs-lookup"><span data-stu-id="b8471-294">Learning to use the **MultiShardQuery** in combination with EF is beyond the scope of this document</span></span>

## <a name="conclusion"></a><span data-ttu-id="b8471-295">Závěr</span><span class="sxs-lookup"><span data-stu-id="b8471-295">Conclusion</span></span>
<span data-ttu-id="b8471-296">Pomocí kroků uvedených v tomto dokumentu, EF aplikace můžete použít možnost klientské knihovny elastické databáze pro data závislé směrování podle refaktoring konstruktory **DbContext** použitou v aplikaci EF podtřídy.</span><span class="sxs-lookup"><span data-stu-id="b8471-296">Through the steps outlined in this document, EF applications can use the elastic database client library's capability for data dependent routing by refactoring constructors of the **DbContext** subclasses used in the EF application.</span></span> <span data-ttu-id="b8471-297">Toto nastavení omezuje změny požadované na těchto místech kde **DbContext** třídy již existují.</span><span class="sxs-lookup"><span data-stu-id="b8471-297">This limits the  changes required to those places where **DbContext** classes already exist.</span></span> <span data-ttu-id="b8471-298">Kromě toho EF aplikace můžete nadále těžit z nasazení automatické schéma kombinací kroky, které vyvolání nezbytné migrace EF s registrací nové horizontálních oddílů a mapování v mapě horizontálního oddílu.</span><span class="sxs-lookup"><span data-stu-id="b8471-298">In addition, EF applications can continue to benefit from automatic schema deployment by combining the steps that invoke the necessary EF migrations with the registration of new shards and mappings in the shard map.</span></span> 

[!INCLUDE [elastic-scale-include](../../includes/elastic-scale-include.md)]

<!--Image references-->
[1]: ./media/sql-database-elastic-scale-use-entity-framework-applications-visual-studio/sample.png
