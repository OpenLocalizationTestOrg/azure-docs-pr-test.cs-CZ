---
title: "Psaní aplikací, které používají fronty Azure Service Bus | Microsoft Docs"
description: "Jak napsat jednoduchou aplikaci na základě fronty, která používá Azure Service Bus."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 754d91b3-1426-405e-84b4-fd36d65b114a
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 08/07/2017
ms.author: sethm
ms.openlocfilehash: 419caff7e8ceeb419c89a2ef9a6614c1accf3e52
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/18/2017
---
# <a name="create-applications-that-use-service-bus-queues"></a><span data-ttu-id="c9944-103">Vytváření aplikací používajících fronty Service Bus</span><span class="sxs-lookup"><span data-stu-id="c9944-103">Create applications that use Service Bus queues</span></span>
<span data-ttu-id="c9944-104">Toto téma popisuje fronty Service Bus a ukazuje, jak napsat jednoduchou aplikaci na základě fronty, která používá Service Bus.</span><span class="sxs-lookup"><span data-stu-id="c9944-104">This topic describes Service Bus queues and shows how to write a simple queue-based application that uses Service Bus.</span></span>

<span data-ttu-id="c9944-105">Představte si třeba situaci ze světa prodejní, ve kterém prodeje dat z jednotlivých terminály Point-of-Sale (POS) musejí směrovat na systém pro správu inventáře, která data používá k určení, kdy musí být doplněny stock.</span><span class="sxs-lookup"><span data-stu-id="c9944-105">Consider a scenario from the world of retail in which sales data from individual Point-of-Sale (POS) terminals must be routed to an inventory management system that uses the data to determine when stock has to be replenished.</span></span> <span data-ttu-id="c9944-106">Toto řešení používá pro komunikaci mezi terminály a systém pro správu inventáře, zasílání zpráv Service Bus, jak je znázorněno na následujícím obrázku:</span><span class="sxs-lookup"><span data-stu-id="c9944-106">This solution uses Service Bus messaging for the communication between the terminals and the inventory management system, as illustrated in the following figure:</span></span>

![Fronty služby Service Bus obrázku 1](./media/service-bus-create-queues/IC657161.gif)

<span data-ttu-id="c9944-108">Každý terminál POS sestavy jeho data prodeje odesláním zprávy a pokuste se **DataCollectionQueue**.</span><span class="sxs-lookup"><span data-stu-id="c9944-108">Each POS terminal reports its sales data by sending messages to the **DataCollectionQueue**.</span></span> <span data-ttu-id="c9944-109">Tyto zprávy zůstanou v této frontě, dokud se načítají pomocí systému pro správu inventáře.</span><span class="sxs-lookup"><span data-stu-id="c9944-109">These messages remain in this queue until they are retrieved by the inventory management system.</span></span> <span data-ttu-id="c9944-110">Toto chování se často říká *asynchronní zasílání zpráv*, protože není nutné čekat na odpověď od systém pro správu inventáře pokračovat zpracování POS terminálu.</span><span class="sxs-lookup"><span data-stu-id="c9944-110">This pattern is often termed *asynchronous messaging*, because the POS terminal does not have to wait for a reply from the inventory management system to continue processing.</span></span>

## <a name="why-queuing"></a><span data-ttu-id="c9944-111">Proč služba Řízení front?</span><span class="sxs-lookup"><span data-stu-id="c9944-111">Why queuing?</span></span>
<span data-ttu-id="c9944-112">Předtím, než se podíváme na kód, který je nutný k nastavení této aplikace, zvažte výhody používání fronty v tomto scénáři místo nutnosti terminály POS komunikovat přímo (synchronně) do systému pro správu inventáře.</span><span class="sxs-lookup"><span data-stu-id="c9944-112">Before we look at the code that is required to set up this application, consider the advantages of using a queue in this scenario instead of having the POS terminals talk directly (synchronously) to the inventory management system.</span></span>

### <a name="temporal-decoupling"></a><span data-ttu-id="c9944-113">Časové oddělení</span><span class="sxs-lookup"><span data-stu-id="c9944-113">Temporal decoupling</span></span>
<span data-ttu-id="c9944-114">S asynchronním vzorcem zasílání zpráv producenti a spotřebitelé nemusí být online ve stejnou dobu.</span><span class="sxs-lookup"><span data-stu-id="c9944-114">With the asynchronous messaging pattern, producers and consumers do not have to be online at the same time.</span></span> <span data-ttu-id="c9944-115">Infrastruktura přenosu zpráv spolehlivě uloží zprávy, dokud spotřebitel nebude připravený je přijmout.</span><span class="sxs-lookup"><span data-stu-id="c9944-115">The messaging infrastructure reliably stores messages until the consuming party is ready to receive them.</span></span> <span data-ttu-id="c9944-116">To znamená, že se že součásti distribuované aplikace můžou být odpojit; například pro údržbu, nebo kvůli součástí, bez ovlivnění celý systém.</span><span class="sxs-lookup"><span data-stu-id="c9944-116">This means the components of the distributed application can be disconnected, either voluntarily; for example, for maintenance, or due to a component crash, without affecting the whole system.</span></span> <span data-ttu-id="c9944-117">Kromě toho spotřebitelskou aplikací může mít pouze jako online v určitou dobu dne.</span><span class="sxs-lookup"><span data-stu-id="c9944-117">Furthermore, the consuming application may only have to be online during certain times of the day.</span></span> <span data-ttu-id="c9944-118">Například v tomto scénáři prodejní systém pro správu inventáře může mít pouze do režimu online na konci pracovního dne.</span><span class="sxs-lookup"><span data-stu-id="c9944-118">For example, in this retail scenario, the inventory management system may only have to come online after the end of the business day.</span></span>

### <a name="load-leveling"></a><span data-ttu-id="c9944-119">Vyrovnávání zátěže</span><span class="sxs-lookup"><span data-stu-id="c9944-119">Load leveling</span></span>
<span data-ttu-id="c9944-120">V mnoha aplikacích zatížení systému se liší v čase, zatímco zpracování čas potřebný pro jednotlivé jednotky práce je obvykle stálá.</span><span class="sxs-lookup"><span data-stu-id="c9944-120">In many applications system load varies over time, whereas the processing time required for each unit of work is typically constant.</span></span> <span data-ttu-id="c9944-121">Propojovací producenti a spotřebitelé zpráv s frontou znamená, že spotřebitelskou aplikaci (pracovní proces) má jenom zřídit na služby průměrnou zátěž spíše než zátěž ve špičce.</span><span class="sxs-lookup"><span data-stu-id="c9944-121">Intermediating message producers and consumers with a queue means that the consuming application (the worker) only has to be provisioned to service an average load rather than a peak load.</span></span> <span data-ttu-id="c9944-122">Hloubka fronty budou růst a smluv jako příchozí zátěží se mění.</span><span class="sxs-lookup"><span data-stu-id="c9944-122">The depth of the queue will grow and contract as the incoming load varies.</span></span> <span data-ttu-id="c9944-123">To znamená přímou úsporu nákladů s ohledem na množství infrastruktury nutné pro zvládání zatížení aplikace.</span><span class="sxs-lookup"><span data-stu-id="c9944-123">This directly saves money with regard to the amount of infrastructure required to service the application load.</span></span>

![Fronty služby Service Bus obrázku 2](./media/service-bus-create-queues/IC657162.gif)

### <a name="load-balancing"></a><span data-ttu-id="c9944-125">Vyrovnávání zatížení</span><span class="sxs-lookup"><span data-stu-id="c9944-125">Load balancing</span></span>
<span data-ttu-id="c9944-126">Při rostoucí zátěži, lze přidat další pracovní procesy ke čtení z fronty pracovních procesů.</span><span class="sxs-lookup"><span data-stu-id="c9944-126">As the load increases, more worker processes can be added to read from the worker queue.</span></span> <span data-ttu-id="c9944-127">Každou zprávu zpracovává jen jeden pracovní proces.</span><span class="sxs-lookup"><span data-stu-id="c9944-127">Each message is processed by only one of the worker processes.</span></span> <span data-ttu-id="c9944-128">Kromě toho tato Vyrovnávání zatížení založené na operaci pull umožňuje optimální využívání pracovních počítačů i v případě, že pracovní počítače liší s ohledem na výpočetní výkon, jak se bude načítat zprávy na svou vlastním maximální rychlostí.</span><span class="sxs-lookup"><span data-stu-id="c9944-128">Furthermore, this pull-based load balancing allows for optimum usage of the worker computers even if the worker computers differ with regard to processing power, as they will pull messages at their own maximum rate.</span></span> <span data-ttu-id="c9944-129">Toto chování se často říká konkurenční vzoru příjemce.</span><span class="sxs-lookup"><span data-stu-id="c9944-129">This pattern is often termed the competing consumer pattern.</span></span>

![Obrázek 3 fronty Service Bus](./media/service-bus-create-queues/IC657163.gif)

### <a name="loose-coupling"></a><span data-ttu-id="c9944-131">Volné párování</span><span class="sxs-lookup"><span data-stu-id="c9944-131">Loose coupling</span></span>
<span data-ttu-id="c9944-132">Použití pro zprostředkující mezi producenti a spotřebitelé zpráv služby Řízení front zpráv poskytuje vnitřní volné párování mezi součástmi.</span><span class="sxs-lookup"><span data-stu-id="c9944-132">Using message queuing to intermediate between message producers and consumers provides an intrinsic loose coupling between the components.</span></span> <span data-ttu-id="c9944-133">Protože producenti a spotřebitelé nemají informace o sobě navzájem, bez nutnosti nijak neprojeví na Autor lze upgradovat příjemce.</span><span class="sxs-lookup"><span data-stu-id="c9944-133">Because producers and consumers are not aware of each other, a consumer can be upgraded without having any effect on the producer.</span></span> <span data-ttu-id="c9944-134">Kromě toho můžete zasílání zpráv topologie rozvíjet bez ovlivnění stávající koncové body.</span><span class="sxs-lookup"><span data-stu-id="c9944-134">Furthermore, the messaging topology can evolve without affecting the existing endpoints.</span></span> <span data-ttu-id="c9944-135">Probereme to více při mluvíme o publikování a přihlášení k odběru.</span><span class="sxs-lookup"><span data-stu-id="c9944-135">We’ll discuss this more when we talk about publish/subscribe.</span></span>

## <a name="show-me-the-code"></a><span data-ttu-id="c9944-136">Zobrazit mi kód</span><span class="sxs-lookup"><span data-stu-id="c9944-136">Show me the code</span></span>
<span data-ttu-id="c9944-137">V následující části ukazuje, jak sběrnice můžete použít k vytvoření této aplikace.</span><span class="sxs-lookup"><span data-stu-id="c9944-137">The following section shows how to use Service Bus to build this application.</span></span>

### <a name="sign-up-for-an-azure-account"></a><span data-ttu-id="c9944-138">Zaregistrujte si účet Azure</span><span class="sxs-lookup"><span data-stu-id="c9944-138">Sign up for an Azure account</span></span>
<span data-ttu-id="c9944-139">Chcete-li začít pracovat se Service Bus, budete potřebovat účet Azure.</span><span class="sxs-lookup"><span data-stu-id="c9944-139">You’ll need an Azure account in order to start working with Service Bus.</span></span> <span data-ttu-id="c9944-140">Pokud není již nemáte, můžete zaregistrovat bezplatný účet [zde](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF).</span><span class="sxs-lookup"><span data-stu-id="c9944-140">If you do not already have one, you can sign up for a free account [here](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF).</span></span>

### <a name="create-a-namespace"></a><span data-ttu-id="c9944-141">Vytvoření oboru názvů</span><span class="sxs-lookup"><span data-stu-id="c9944-141">Create a namespace</span></span>
<span data-ttu-id="c9944-142">Jakmile máte předplatné, můžete [vytvořit obor názvů služby](service-bus-create-namespace-portal.md).</span><span class="sxs-lookup"><span data-stu-id="c9944-142">Once you have a subscription, you can [create a service namespace](service-bus-create-namespace-portal.md).</span></span> <span data-ttu-id="c9944-143">Každý obor názvů funguje jako kontejner oboru pro sadu entit služby Service Bus.</span><span class="sxs-lookup"><span data-stu-id="c9944-143">Each namespace acts as a scoping container for a set of Service Bus entities.</span></span> <span data-ttu-id="c9944-144">Zadejte jedinečný název váš nový obor názvů mezi všechny účty služby Service Bus.</span><span class="sxs-lookup"><span data-stu-id="c9944-144">Give your new namespace a unique name across all Service Bus accounts.</span></span> 

### <a name="install-the-nuget-package"></a><span data-ttu-id="c9944-145">Nainstalujte balíček NuGet</span><span class="sxs-lookup"><span data-stu-id="c9944-145">Install the NuGet package</span></span>
<span data-ttu-id="c9944-146">Pro používání oboru názvů Service Bus, aplikace musí odkazovat na sestavení Service Bus, konkrétně Microsoft.ServiceBus.dll.</span><span class="sxs-lookup"><span data-stu-id="c9944-146">To use the Service Bus namespace, an application must reference the Service Bus assembly, specifically Microsoft.ServiceBus.dll.</span></span> <span data-ttu-id="c9944-147">Můžete najít toto sestavení v rámci Microsoft Azure SDK a je k dispozici ke stažení [stránky pro stažení sady Azure SDK](https://azure.microsoft.com/downloads/).</span><span class="sxs-lookup"><span data-stu-id="c9944-147">You can find this assembly as part of the Microsoft Azure SDK, and the download is available at the [Azure SDK download page](https://azure.microsoft.com/downloads/).</span></span> <span data-ttu-id="c9944-148">Ale [balíček Service Bus NuGet](https://www.nuget.org/packages/WindowsAzure.ServiceBus) Nejsnadnějším způsobem, chcete-li získat rozhraní API Service Bus a nakonfigurovat svoji aplikaci se všemi závislostmi služby Service Bus.</span><span class="sxs-lookup"><span data-stu-id="c9944-148">However, the [Service Bus NuGet package](https://www.nuget.org/packages/WindowsAzure.ServiceBus) is the easiest way to get the Service Bus API and to configure your application with all of the Service Bus dependencies.</span></span>

### <a name="create-the-queue"></a><span data-ttu-id="c9944-149">Vytvoření fronty</span><span class="sxs-lookup"><span data-stu-id="c9944-149">Create the queue</span></span>
<span data-ttu-id="c9944-150">Operace správy pro Service Bus entit pro zasílání zpráv (fronty a publikování a přihlášení k odběru témata) se provádí prostřednictvím [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) třídy.</span><span class="sxs-lookup"><span data-stu-id="c9944-150">Management operations for Service Bus messaging entities (queues and publish/subscribe topics) are performed via the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class.</span></span> <span data-ttu-id="c9944-151">Service Bus používá [sdíleného přístupového podpisu (SAS)](service-bus-sas.md) model zabezpečení založený na.</span><span class="sxs-lookup"><span data-stu-id="c9944-151">Service Bus uses a [Shared Access Signature (SAS)](service-bus-sas.md) based security model.</span></span> <span data-ttu-id="c9944-152">[TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider) třída představuje poskytovatele tokenu zabezpečení se zabudovanými metodami pro vytváření vracení některé známé poskytovatele tokenů.</span><span class="sxs-lookup"><span data-stu-id="c9944-152">The [TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider) class represents a security token provider with built-in factory methods returning some well-known token providers.</span></span> <span data-ttu-id="c9944-153">Použijeme [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) metoda pro uložení pověření SAS.</span><span class="sxs-lookup"><span data-stu-id="c9944-153">We’ll use a [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) method to hold the SAS credentials.</span></span> <span data-ttu-id="c9944-154">[NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance je pak vytvořený pomocí bázové adresy oboru názvů Service Bus a zprostředkovateli tokenu.</span><span class="sxs-lookup"><span data-stu-id="c9944-154">The [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is then constructed with the base address of the Service Bus namespace and the token provider.</span></span>

<span data-ttu-id="c9944-155">[NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) třída poskytuje metody pro vytvoření, výčet a odstranění entit přenosu zpráv.</span><span class="sxs-lookup"><span data-stu-id="c9944-155">The [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class provides methods to create, enumerate and delete messaging entities.</span></span> <span data-ttu-id="c9944-156">Kód, který zobrazí se zde zobrazí jak [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) je vytvořit a použít k vytvoření instance **DataCollectionQueue** fronty.</span><span class="sxs-lookup"><span data-stu-id="c9944-156">The code that is shown here shows how the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is created and used to create the **DataCollectionQueue** queue.</span></span>

```csharp
Uri uri = ServiceBusEnvironment.CreateServiceUri("sb", 
                "test-blog", string.Empty);
string name = "RootManageSharedAccessKey";
string key = "abcdefghijklmopqrstuvwxyz";

TokenProvider tokenProvider = 
    TokenProvider.CreateSharedAccessSignatureTokenProvider(name, key);
NamespaceManager namespaceManager = 
    new NamespaceManager(uri, tokenProvider);
namespaceManager.CreateQueue("DataCollectionQueue");
```

<span data-ttu-id="c9944-157">Všimněte si, že existují přetížení [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) metoda, která povolení vlastností fronty v úzkém ladit.</span><span class="sxs-lookup"><span data-stu-id="c9944-157">Note that there are overloads of the [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) method that enable properties of the queue to be tuned.</span></span> <span data-ttu-id="c9944-158">Můžete například nastavit výchozí time to live (TTL) hodnotě pro zprávy odeslané do fronty.</span><span class="sxs-lookup"><span data-stu-id="c9944-158">For example, you can set the default time-to-live (TTL) value for messages sent to the queue.</span></span>

### <a name="send-messages-to-the-queue"></a><span data-ttu-id="c9944-159">Zasílání zpráv do fronty</span><span class="sxs-lookup"><span data-stu-id="c9944-159">Send messages to the queue</span></span>
<span data-ttu-id="c9944-160">Pro spuštění operace na Service Bus entity; například odesílání a přijímání zpráv, aplikace musíte nejdřív vytvořit [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) objektu.</span><span class="sxs-lookup"><span data-stu-id="c9944-160">For run-time operations on Service Bus entities; for example, sending and receiving messages, an application must first create a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) object.</span></span> <span data-ttu-id="c9944-161">Podobně jako [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) třídy, [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance je vytvořený z bázové adresy oboru názvů služby a zprostředkovateli tokenu.</span><span class="sxs-lookup"><span data-stu-id="c9944-161">Similar to the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class, the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance is created from the base address of the service namespace and the token provider.</span></span>

```csharp
 BrokeredMessage bm = new BrokeredMessage(salesData);
 bm.Label = "SalesReport";
 bm.Properties["StoreName"] = "Redmond";
 bm.Properties["MachineID"] = "POS_1";
```

<span data-ttu-id="c9944-162">Zprávy odeslané do a fronty přijal od služby Service Bus jsou instance [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage) třídy.</span><span class="sxs-lookup"><span data-stu-id="c9944-162">Messages sent to, and received from Service Bus queues are instances of the [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage) class.</span></span> <span data-ttu-id="c9944-163">Tato třída obsahuje sadu standardních vlastností (jako například [popisek](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) a [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), slovník používaný pro udržení vlastností aplikace a tělo s libovolnými aplikačními daty.</span><span class="sxs-lookup"><span data-stu-id="c9944-163">This class consists of a set of standard properties (such as [Label](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) and [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), a dictionary that is used to hold application properties, and a body of arbitrary application data.</span></span> <span data-ttu-id="c9944-164">Aplikace můžete nastavit text tak předávání jakýkoli serializovatelný objekt (v následujícím příkladu předá v **SalesData** objekt, který představuje data z prodeje z terminálu POS), který bude používat [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) k serializaci objektu.</span><span class="sxs-lookup"><span data-stu-id="c9944-164">An application can set the body by passing in any serializable object (the following example passes in a **SalesData** object that represents the sales data from the POS terminal), which will use the [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) to serialize the object.</span></span> <span data-ttu-id="c9944-165">Alternativně [datového proudu](https://msdn.microsoft.com/library/system.io.stream.aspx) může být zadán objekt.</span><span class="sxs-lookup"><span data-stu-id="c9944-165">Alternatively, a [Stream](https://msdn.microsoft.com/library/system.io.stream.aspx) object can be provided.</span></span>

<span data-ttu-id="c9944-166">Nejjednodušší způsob, jak zasílání zpráv do dané fronty, v našem případě **DataCollectionQueue**, je použití [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) k vytvoření [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) přímo objektu z [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance.</span><span class="sxs-lookup"><span data-stu-id="c9944-166">The easiest way to send messages to a given queue, in our case the **DataCollectionQueue**, is to use [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) to create a [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) object directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance.</span></span>

```csharp
MessageSender sender = factory.CreateMessageSender("DataCollectionQueue");
sender.Send(bm);
```

### <a name="receiving-messages-from-the-queue"></a><span data-ttu-id="c9944-167">Přijímání zpráv z fronty</span><span class="sxs-lookup"><span data-stu-id="c9944-167">Receiving messages from the queue</span></span>
<span data-ttu-id="c9944-168">Pro příjem zpráv z fronty, můžete použít [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) objekt, který vytvoříte přímo z [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) pomocí [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_).</span><span class="sxs-lookup"><span data-stu-id="c9944-168">To receive messages from the queue, you can use a [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) object which you create directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) using [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_).</span></span> <span data-ttu-id="c9944-169">Zpráva příjemci můžou pracovat ve dvou různých režimech: **ReceiveAndDelete** a **PeekLock**.</span><span class="sxs-lookup"><span data-stu-id="c9944-169">Message receivers can work in two different modes: **ReceiveAndDelete** and **PeekLock**.</span></span> <span data-ttu-id="c9944-170">[ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) při vytvoření příjemce zprávu jako parametr pro nastavený [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_) volání.</span><span class="sxs-lookup"><span data-stu-id="c9944-170">The [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) is set when the message receiver is created, as a parameter to the [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_) call.</span></span>

<span data-ttu-id="c9944-171">Při použití **ReceiveAndDelete** režimu, je je přijetí jednorázová operace; to znamená, když Service Bus přijme požadavek, označí zprávu jako spotřebovávanou a vrátí ji do aplikace.</span><span class="sxs-lookup"><span data-stu-id="c9944-171">When using the **ReceiveAndDelete** mode, the receive is a single-shot operation; that is, when Service Bus receives the request, it marks the message as being consumed and returns it to the application.</span></span> <span data-ttu-id="c9944-172">**ReceiveAndDelete** režimu je nejjednodušší model a funguje nejlépe ve scénářích, kde aplikace může tolerovat Pokud dojde k selhání se zpráva nezpracuje.</span><span class="sxs-lookup"><span data-stu-id="c9944-172">**ReceiveAndDelete** mode is the simplest model and works best for scenarios in which the application can tolerate not processing a message if a failure were to occur.</span></span> <span data-ttu-id="c9944-173">Pro lepší vysvětlení si představte scénář, ve kterém spotřebitel vyšle požadavek na přijetí, ale než ji může zpracovat, dojde v něm k chybě a ukončí se.</span><span class="sxs-lookup"><span data-stu-id="c9944-173">To understand this, consider a scenario in which the consumer issues the receive request and then crashes before processing it.</span></span> <span data-ttu-id="c9944-174">Vzhledem k tomu, že Service Bus označit zprávu jako spotřebovávanou, když se aplikace restartuje a začne znovu přijímat zprávy, ji budou neuskutečnily zprávu, která se spotřebovala před havárii.</span><span class="sxs-lookup"><span data-stu-id="c9944-174">Since Service Bus marked the message as being consumed, when the application restarts and starts consuming messages again, it will have missed the message that was consumed before the crash.</span></span>

<span data-ttu-id="c9944-175">V **PeekLock** režimu, je přijetí stane dvoufázová operaci, která umožňuje podporuje aplikace, které nemůžou tolerovat vynechání zpráv.</span><span class="sxs-lookup"><span data-stu-id="c9944-175">In **PeekLock** mode, the receive becomes a two-stage operation, which makes it possible to support applications that cannot tolerate missing messages.</span></span> <span data-ttu-id="c9944-176">Když Service Bus přijme požadavek, najde zprávu, který se má používat, uzamkne ji proti spotřebování jinými spotřebiteli a vrátí ji do aplikace.</span><span class="sxs-lookup"><span data-stu-id="c9944-176">When Service Bus receives the request, it finds the next message to be consumed, locks it to prevent other consumers receiving it, and then returns it to the application.</span></span> <span data-ttu-id="c9944-177">Když aplikace dokončí zpracování zprávy (nebo ji bezpečně uloží pro pozdější zpracování), zavolá na přijatou zprávu [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete), a tím potvrdí dokončení druhé fáze přijetí.</span><span class="sxs-lookup"><span data-stu-id="c9944-177">After the application finishes processing the message (or stores it reliably for future processing), it completes the second stage of the receive process by calling [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) on the received message.</span></span> <span data-ttu-id="c9944-178">Když Service Bus uvidí [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) volání, označí zprávu jako spotřebovávanou.</span><span class="sxs-lookup"><span data-stu-id="c9944-178">When Service Bus sees the [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) call, it marks the message as being consumed.</span></span>

<span data-ttu-id="c9944-179">K dispozici jsou dva další výsledky.</span><span class="sxs-lookup"><span data-stu-id="c9944-179">Two other outcomes are possible.</span></span> <span data-ttu-id="c9944-180">První, pokud aplikace nemůže zpracovat zprávu z nějakého důvodu, může zavolat [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) na přijatou zprávu (místo [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span><span class="sxs-lookup"><span data-stu-id="c9944-180">First, if the application is unable to process the message for some reason, it can call [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) on the received message (instead of [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span></span> <span data-ttu-id="c9944-181">To způsobí, že Service Bus zprávu odemkne a zpřístupní ji pro další přijetí, buď stejným uživatelem, nebo jiné dokončuje příjemce.</span><span class="sxs-lookup"><span data-stu-id="c9944-181">This causes Service Bus to unlock the message and make it available to be received again, either by the same consumer or by another completing consumer.</span></span> <span data-ttu-id="c9944-182">Druhý je časový limit zámku a pokud aplikace nelze zpracovat zprávu, vyprší časový limit uzamčení (například pokud aplikace spadne), pak bude Service Bus zprávu odemkne a nastavit jej jako lze přijaté znovu) v podstatě provádění [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) operace ve výchozím nastavení).</span><span class="sxs-lookup"><span data-stu-id="c9944-182">Second, there is a time-out associated with the lock and if the application cannot process the message before the lock time-out expires (for example, if the application crashes), then Service Bus will unlock the message and make it available to be received again (essentially performing an [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) operation by default).</span></span>

<span data-ttu-id="c9944-183">Všimněte si, že pokud aplikace spadne po zpracování zprávy ale předtím, než [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) byl vydán požadavek, zpráva bude vysláním do aplikace odešle znovu.</span><span class="sxs-lookup"><span data-stu-id="c9944-183">Note that if the application crashes after it processes the message but before the [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) request was issued, the message will be redelivered to the application when it restarts.</span></span> <span data-ttu-id="c9944-184">To se často říká * alespoň jednou * zpracování.</span><span class="sxs-lookup"><span data-stu-id="c9944-184">This is often termed *At Least Once * processing.</span></span> <span data-ttu-id="c9944-185">To znamená, že každá zpráva se zpracuje alespoň jednou, ale v některých situacích může být stejná zpráva víckrát.</span><span class="sxs-lookup"><span data-stu-id="c9944-185">This means that each message will be processed at least once but in certain situations the same message may be redelivered.</span></span> <span data-ttu-id="c9944-186">Pokud scénář nemůže tolerovat zpracování duplicitní, bude potřeba další logiku v aplikaci duplicity.</span><span class="sxs-lookup"><span data-stu-id="c9944-186">If the scenario cannot tolerate duplicate processing, then additional logic is required in the application to detect duplicates.</span></span> <span data-ttu-id="c9944-187">Toho lze dosáhnout na základě [MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) vlastnost zprávy.</span><span class="sxs-lookup"><span data-stu-id="c9944-187">This can be achieved based on the [MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) property of the message.</span></span> <span data-ttu-id="c9944-188">Hodnota této vlastnosti konstantní mezi pokusy o doručení.</span><span class="sxs-lookup"><span data-stu-id="c9944-188">The value of this property remains constant across delivery attempts.</span></span> <span data-ttu-id="c9944-189">To se říká *právě jednou* zpracování.</span><span class="sxs-lookup"><span data-stu-id="c9944-189">This is termed *Exactly Once* processing.</span></span>

<span data-ttu-id="c9944-190">Kód, který se zobrazí tady obdrží a zpracuje zprávu pomocí **PeekLock** režimu, který je výchozím nastavením, pokud žádné [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) explicitně zadat hodnotu.</span><span class="sxs-lookup"><span data-stu-id="c9944-190">The code that is shown here receives and processes a message using the **PeekLock** mode, which is the default if no [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) value is explicitly provided.</span></span>

```csharp
MessageReceiver receiver = factory.CreateMessageReceiver("DataCollectionQueue");
BrokeredMessage receivedMessage = receiver.Receive();
try
{
    ProcessMessage(receivedMessage);
    receivedMessage.Complete();
}
catch (Exception e)
{
    receivedMessage.Abandon();
}
```

### <a name="use-the-queue-client"></a><span data-ttu-id="c9944-191">Pomocí klienta fronty</span><span class="sxs-lookup"><span data-stu-id="c9944-191">Use the queue client</span></span>
<span data-ttu-id="c9944-192">Příklady dříve v této části vytvořit [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) a [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) objekty přímo z [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) odesílat a přijímat zprávy z ve frontě, v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="c9944-192">The examples earlier in this section created [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) and [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) objects directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) to send and receive messages from the queue, respectively.</span></span> <span data-ttu-id="c9944-193">Alternativní způsob je použít [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) objekt, který podporuje jak operace odesílání a přijímání kromě dalších pokročilých funkcí, jako je například relací.</span><span class="sxs-lookup"><span data-stu-id="c9944-193">An alternative approach is to use a [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) object, which supports both send and receive operations in addition to more advanced features, such as sessions.</span></span>

```csharp
QueueClient queueClient = factory.CreateQueueClient("DataCollectionQueue");
queueClient.Send(bm);

BrokeredMessage message = queueClient.Receive();

try
{
    ProcessMessage(message);
    message.Complete();
}
catch (Exception e)
{
    message.Abandon();
} 
```

## <a name="next-steps"></a><span data-ttu-id="c9944-194">Další kroky</span><span class="sxs-lookup"><span data-stu-id="c9944-194">Next steps</span></span>
<span data-ttu-id="c9944-195">Teď, když jste se naučili základy front, najdete v části [vytvářet aplikace, které používají témata a odběry Service Bus](service-bus-create-topics-subscriptions.md) pokračujte toto pojednání pomocí možnosti publikování a přihlášení k odběru témat a odběrů Service Bus.</span><span class="sxs-lookup"><span data-stu-id="c9944-195">Now that you've learned the basics of queues, see [Create applications that use Service Bus topics and subscriptions](service-bus-create-topics-subscriptions.md) to continue this discussion using the publish/subscribe capabilities of Service Bus topics and subscriptions.</span></span>

