---
title: "Přehled fronty, témata a odběry pro zasílání zpráv Azure Service Bus | Microsoft Docs"
description: "Přehled služby Service Bus entity pro zasílání zpráv."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: a306ced4-74e9-47c6-990a-d9c47efa31d5
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 06/28/2017
ms.author: sethm
ms.openlocfilehash: 00f9f38fbae028486270053dedb4df580a3f1a44
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/18/2017
---
# <a name="service-bus-queues-topics-and-subscriptions"></a><span data-ttu-id="67ebb-103">Fronty, témata a odběry služby Service Bus</span><span class="sxs-lookup"><span data-stu-id="67ebb-103">Service Bus queues, topics, and subscriptions</span></span>

<span data-ttu-id="67ebb-104">Microsoft Azure Service Bus podporuje sadu založené na cloudu, orientovaný na zprávy middleware technologie včetně služby Řízení front zpráv spolehlivé a trvanlivé publikování a přihlášení k odběru zasílání zpráv.</span><span class="sxs-lookup"><span data-stu-id="67ebb-104">Microsoft Azure Service Bus supports a set of cloud-based, message-oriented middleware technologies including reliable message queuing and durable publish/subscribe messaging.</span></span> <span data-ttu-id="67ebb-105">Tyto funkce "zprostředkovaného" přenosu zpráv můžete představit jako odpojené zasílání zpráv funkce, které podpora publikování a odběru, časové oddělení a scénáře s využitím prostředků infrastruktury pro zprávy sběrnice služby Vyrovnávání zatížení.</span><span class="sxs-lookup"><span data-stu-id="67ebb-105">These "brokered" messaging capabilities can be thought of as decoupled messaging features that support publish-subscribe, temporal decoupling, and load balancing scenarios using the Service Bus messaging fabric.</span></span> <span data-ttu-id="67ebb-106">Oddělená komunikace má mnoho výhod – klienti a servery se například můžou spojit podle potřeby a provádět své operace asynchronním způsobem.</span><span class="sxs-lookup"><span data-stu-id="67ebb-106">Decoupled communication has many advantages; for example, clients and servers can connect as needed and perform their operations in an asynchronous fashion.</span></span>

<span data-ttu-id="67ebb-107">Entit pro zasílání zpráv, které tvoří základní možnosti zasílání zpráv ve sběrnici Service Bus jsou fronty, témata a odběry a pravidla nebo akce.</span><span class="sxs-lookup"><span data-stu-id="67ebb-107">The messaging entities that form the core of the messaging capabilities in Service Bus are queues, topics and subscriptions, and rules/actions.</span></span>

## <a name="queues"></a><span data-ttu-id="67ebb-108">Fronty</span><span class="sxs-lookup"><span data-stu-id="67ebb-108">Queues</span></span>

<span data-ttu-id="67ebb-109">Fronty nabízejí *First In, Out první* doručování zpráv (metodou FIFO) na jeden nebo několik konkurenčních spotřebitelů.</span><span class="sxs-lookup"><span data-stu-id="67ebb-109">Queues offer *First In, First Out* (FIFO) message delivery to one or more competing consumers.</span></span> <span data-ttu-id="67ebb-110">To znamená zprávy se očekává obvykle přijímají a zpracovávají v pořadí, ve kterém byly přidány do fronty, a každou zprávu přijme a zpracuje jenom jeden příjemce zprávy.</span><span class="sxs-lookup"><span data-stu-id="67ebb-110">That is, messages are typically expected to be received and processed by the receivers in the order in which they were added to the queue, and each message is received and processed by only one message consumer.</span></span> <span data-ttu-id="67ebb-111">Klíčovou výhodou použití front je dosáhnout "časové oddělení" součástí aplikace.</span><span class="sxs-lookup"><span data-stu-id="67ebb-111">A key benefit of using queues is to achieve "temporal decoupling" of application components.</span></span> <span data-ttu-id="67ebb-112">Jinými slovy producenti (odesílatelé) a spotřebitelé (příjemci) nemusí být odesílání a přijímání zpráv ve stejnou dobu, protože zprávy jsou bezpečně uložené ve frontě.</span><span class="sxs-lookup"><span data-stu-id="67ebb-112">In other words, the producers (senders) and consumers (receivers) do not have to be sending and receiving messages at the same time, because messages are stored durably in the queue.</span></span> <span data-ttu-id="67ebb-113">Kromě toho Autor nemusí čekat na odpověď od příjemce, aby bylo možné pokračovat se zpracováním a odesláním zprávy.</span><span class="sxs-lookup"><span data-stu-id="67ebb-113">Furthermore, the producer does not have to wait for a reply from the consumer in order to continue to process and send messages.</span></span>

<span data-ttu-id="67ebb-114">Výhodou je, "vyrovnávání zátěže," což umožňuje odesílatelům a spotřebitelům umožňuje odesílat a přijímat zprávy různými rychlostmi.</span><span class="sxs-lookup"><span data-stu-id="67ebb-114">A related benefit is "load leveling," which enables producers and consumers to send and receive messages at different rates.</span></span> <span data-ttu-id="67ebb-115">V mnoha aplikacích zatížení systému se liší v čase; ale zpracování čas potřebný pro jednotlivé jednotky práce je obvykle stálá.</span><span class="sxs-lookup"><span data-stu-id="67ebb-115">In many applications, the system load varies over time; however, the processing time required for each unit of work is typically constant.</span></span> <span data-ttu-id="67ebb-116">Propojovací producenti a spotřebitelé zpráv s frontou znamená, že spotřebitelskou aplikaci pouze musí být zřízená být schopna zpracovávat průměrnou zátěž místo zátěž ve špičce.</span><span class="sxs-lookup"><span data-stu-id="67ebb-116">Intermediating message producers and consumers with a queue means that the consuming application only has to be provisioned to be able to handle average load instead of peak load.</span></span> <span data-ttu-id="67ebb-117">S měnící se příchozí zátěží se mění hloubka fronty.</span><span class="sxs-lookup"><span data-stu-id="67ebb-117">The depth of the queue grows and contracts as the incoming load varies.</span></span> <span data-ttu-id="67ebb-118">To znamená přímou úsporu nákladů s ohledem na množství infrastruktury nutné pro zvládání zatížení aplikace.</span><span class="sxs-lookup"><span data-stu-id="67ebb-118">This directly saves money with regard to the amount of infrastructure required to service the application load.</span></span> <span data-ttu-id="67ebb-119">Při rostoucí zátěži, lze přidat další pracovní procesy ke čtení z fronty.</span><span class="sxs-lookup"><span data-stu-id="67ebb-119">As the load increases, more worker processes can be added to read from the queue.</span></span> <span data-ttu-id="67ebb-120">Každou zprávu zpracovává jen jeden pracovní proces.</span><span class="sxs-lookup"><span data-stu-id="67ebb-120">Each message is processed by only one of the worker processes.</span></span> <span data-ttu-id="67ebb-121">Kromě toho tato Vyrovnávání zatížení založené na operaci pull umožňuje optimální využívání pracovních počítačů i v případě, že pracovní počítače liší s ohledem na výpočetní výkon, jak se bude načítat zprávy na svou vlastním maximální rychlostí.</span><span class="sxs-lookup"><span data-stu-id="67ebb-121">Furthermore, this pull-based load balancing allows for optimum use of the worker computers even if the worker computers differ with regard to processing power, as they will pull messages at their own maximum rate.</span></span> <span data-ttu-id="67ebb-122">Toto chování se často říká vzor "neslučitelných příjemce".</span><span class="sxs-lookup"><span data-stu-id="67ebb-122">This pattern is often termed the "competing consumer" pattern.</span></span>

<span data-ttu-id="67ebb-123">Pomocí fronty pro zprostředkující mezi producenti a spotřebitelé zpráv poskytuje vyplývajících volné párování mezi součástmi.</span><span class="sxs-lookup"><span data-stu-id="67ebb-123">Using queues to intermediate between message producers and consumers provides an inherent loose coupling between the components.</span></span> <span data-ttu-id="67ebb-124">Protože producenti a spotřebitelé nemají informace o sobě navzájem, bez nutnosti nijak neprojeví na Autor lze upgradovat příjemce.</span><span class="sxs-lookup"><span data-stu-id="67ebb-124">Because producers and consumers are not aware of each other, a consumer can be upgraded without having any effect on the producer.</span></span>

<span data-ttu-id="67ebb-125">Vytvoření fronty je několika krocích.</span><span class="sxs-lookup"><span data-stu-id="67ebb-125">Creating a queue is a multi-step process.</span></span> <span data-ttu-id="67ebb-126">Provádět operace správy pro Service Bus (fronty a témata) entity pro zasílání zpráv prostřednictvím [Microsoft.ServiceBus.NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) třídy, která je vytvořená zadáním bázové adresy oboru názvů Service Bus a přihlašovací údaje uživatele.</span><span class="sxs-lookup"><span data-stu-id="67ebb-126">You perform management operations for Service Bus messaging entities (both queues and topics) via the [Microsoft.ServiceBus.NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) class, which is constructed by supplying the base address of the Service Bus namespace and the user credentials.</span></span> <span data-ttu-id="67ebb-127">[NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) poskytuje metody pro vytvoření, výčet a odstranění entit přenosu zpráv.</span><span class="sxs-lookup"><span data-stu-id="67ebb-127">[NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) provides methods to create, enumerate and delete messaging entities.</span></span> <span data-ttu-id="67ebb-128">Po vytvoření [Microsoft.ServiceBus.TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#microsoft_servicebus_tokenprovider) objekt objektu pomocí názvu SAS a klíč a správu oboru názvů služby, můžete použít [Microsoft.ServiceBus.NamespaceManager.CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_)metodu pro vytvoření fronty.</span><span class="sxs-lookup"><span data-stu-id="67ebb-128">After creating a [Microsoft.ServiceBus.TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#microsoft_servicebus_tokenprovider) object from the SAS name and key, and a service namespace management object, you can use the [Microsoft.ServiceBus.NamespaceManager.CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) method to create the queue.</span></span> <span data-ttu-id="67ebb-129">Například:</span><span class="sxs-lookup"><span data-stu-id="67ebb-129">For example:</span></span>

```csharp
// Create management credentials
TokenProvider credentials = TokenProvider.CreateSharedAccessSignatureTokenProvider(sasKeyName,sasKeyValue);
// Create namespace client
NamespaceManager namespaceClient = new NamespaceManager(ServiceBusEnvironment.CreateServiceUri("sb", ServiceNamespace, string.Empty), credentials);
```

<span data-ttu-id="67ebb-130">Potom můžete vytvořit objekt fronty a objekt zasílání zpráv s identifikátor URI služby Service Bus jako argument.</span><span class="sxs-lookup"><span data-stu-id="67ebb-130">You can then create a queue object and a messaging factory with the Service Bus URI as an argument.</span></span> <span data-ttu-id="67ebb-131">Například:</span><span class="sxs-lookup"><span data-stu-id="67ebb-131">For example:</span></span>

```csharp
QueueDescription myQueue;
myQueue = namespaceClient.CreateQueue("TestQueue");
MessagingFactory factory = MessagingFactory.Create(ServiceBusEnvironment.CreateServiceUri("sb", ServiceNamespace, string.Empty), credentials); 
QueueClient myQueueClient = factory.CreateQueueClient("TestQueue");
```

<span data-ttu-id="67ebb-132">Pak můžete odesílat zprávy do fronty.</span><span class="sxs-lookup"><span data-stu-id="67ebb-132">You can then send messages to the queue.</span></span> <span data-ttu-id="67ebb-133">Například, pokud máte seznam zprostředkovaných zpráv názvem `MessageList`, zobrazí se tento kód podobný následujícímu:</span><span class="sxs-lookup"><span data-stu-id="67ebb-133">For example, if you have a list of brokered messages called `MessageList`, the code appears similar to the following:</span></span>

```csharp
for (int count = 0; count < 6; count++)
{
    var issue = MessageList[count];
    issue.Label = issue.Properties["IssueTitle"].ToString();
    myQueueClient.Send(issue);
}
```

<span data-ttu-id="67ebb-134">Potom zobrazí zprávy z fronty následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="67ebb-134">You then receive messages from the queue as follows:</span></span>

```csharp
while ((message = myQueueClient.Receive(new TimeSpan(hours: 0, minutes: 0, seconds: 5))) != null)
    {
        Console.WriteLine(string.Format("Message received: {0}, {1}, {2}", message.SequenceNumber, message.Label, message.MessageId));
        message.Complete();

        Console.WriteLine("Processing message (sleeping...)");
        Thread.Sleep(1000);
    }
```

<span data-ttu-id="67ebb-135">V [ReceiveAndDelete](/dotnet/api/microsoft.servicebus.messaging.receivemode) režim, operace příjmu je jednorázová; to znamená, když Service Bus přijme požadavek, označí zprávu jako spotřebovávanou a vrátí ji do aplikace.</span><span class="sxs-lookup"><span data-stu-id="67ebb-135">In the [ReceiveAndDelete](/dotnet/api/microsoft.servicebus.messaging.receivemode) mode, the receive operation is single-shot; that is, when Service Bus receives the request, it marks the message as being consumed and returns it to the application.</span></span> <span data-ttu-id="67ebb-136">**ReceiveAndDelete** režimu je nejjednodušší model a funguje nejlépe ve scénářích, kde aplikace může tolerovat selhání se zpráva nezpracuje.</span><span class="sxs-lookup"><span data-stu-id="67ebb-136">**ReceiveAndDelete** mode is the simplest model and works best for scenarios in which the application can tolerate not processing a message in the event of a failure.</span></span> <span data-ttu-id="67ebb-137">Pro lepší vysvětlení si představte scénář, ve kterém spotřebitel vyšle požadavek na přijetí, ale než ji může zpracovat, dojde v něm k chybě a ukončí se.</span><span class="sxs-lookup"><span data-stu-id="67ebb-137">To understand this, consider a scenario in which the consumer issues the receive request and then crashes before processing it.</span></span> <span data-ttu-id="67ebb-138">Vzhledem k tomu, že Service Bus, označí zprávu jako spotřebovávanou, když se aplikace restartuje a začne znovu přijímat zprávy, se neuskutečnily zprávu, která se spotřebovala před havárii.</span><span class="sxs-lookup"><span data-stu-id="67ebb-138">Because Service Bus marks the message as being consumed, when the application restarts and begins consuming messages again, it will have missed the message that was consumed prior to the crash.</span></span>

<span data-ttu-id="67ebb-139">V [PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode) režimu operace příjmu stane dvoufázová, které umožňuje podporuje aplikace, které nemůžou tolerovat vynechání zpráv.</span><span class="sxs-lookup"><span data-stu-id="67ebb-139">In [PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode) mode, the receive operation becomes two-stage, which makes it possible to support applications that cannot tolerate missing messages.</span></span> <span data-ttu-id="67ebb-140">Když Service Bus přijme požadavek, najde zprávu, který se má používat, uzamkne ji proti spotřebování jinými odběrateli příjem ho a vrátí ji do aplikace.</span><span class="sxs-lookup"><span data-stu-id="67ebb-140">When Service Bus receives the request, it finds the next message to be consumed, locks it to prevent other consumers from receiving it, and then returns it to the application.</span></span> <span data-ttu-id="67ebb-141">Když aplikace dokončí zpracování zprávy (nebo ji bezpečně uloží pro pozdější zpracování), zavolá na přijatou zprávu [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete), a tím potvrdí dokončení druhé fáze přijetí.</span><span class="sxs-lookup"><span data-stu-id="67ebb-141">After the application finishes processing the message (or stores it reliably for future processing), it completes the second stage of the receive process by calling [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) on the received message.</span></span> <span data-ttu-id="67ebb-142">Když Service Bus uvidí **Complete** volání, označí zprávu jako spotřebovávanou.</span><span class="sxs-lookup"><span data-stu-id="67ebb-142">When Service Bus sees the **Complete** call, it marks the message as being consumed.</span></span>

<span data-ttu-id="67ebb-143">Pokud aplikace nemůže zpracovat zprávu z nějakého důvodu, může zavolat [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) metoda na přijatou zprávu (místo [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span><span class="sxs-lookup"><span data-stu-id="67ebb-143">If the application is unable to process the message for some reason, it can call the [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) method on the received message (instead of [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span></span> <span data-ttu-id="67ebb-144">To umožňuje služba Service Bus zprávu odemkne a zpřístupní ji pro další přijetí, příjemci stejné nebo jiné konkurence mezi spotřebiteli.</span><span class="sxs-lookup"><span data-stu-id="67ebb-144">This enables Service Bus to unlock the message and make it available to be received again, either by the same consumer or by another competing consumer.</span></span> <span data-ttu-id="67ebb-145">Za druhé je vypršení časového limitu přidružené zámek a aplikace nepodaří zprávu zpracovat vyprší časový limit uzamčení (například pokud aplikace spadne), pak Service Bus zprávu odemkne a je-li k dispozici být přijata znovu) v podstatě provádění [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) operace ve výchozím nastavení).</span><span class="sxs-lookup"><span data-stu-id="67ebb-145">Secondly, there is a timeout associated with the lock and if the application fails to process the message before the lock timeout expires (for example, if the application crashes), then Service Bus unlocks the message and makes it available to be received again (essentially performing an [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) operation by default).</span></span>

<span data-ttu-id="67ebb-146">Všimněte si, že v případě, že aplikace spadne po zpracování zprávy, ale předtím, než **Complete** požadavku, zpráva se víckrát do aplikace odešle znovu.</span><span class="sxs-lookup"><span data-stu-id="67ebb-146">Note that in the event that the application crashes after processing the message, but before the **Complete** request is issued, the message is redelivered to the application when it restarts.</span></span> <span data-ttu-id="67ebb-147">To se často označuje jako *nejméně jednou* zpracování; to znamená, že každá zpráva se zpracuje alespoň jednou.</span><span class="sxs-lookup"><span data-stu-id="67ebb-147">This is often called *At Least Once* processing; that is, each message is processed at least once.</span></span> <span data-ttu-id="67ebb-148">Ale v některých situacích může doručit víckrát stejnou zprávu.</span><span class="sxs-lookup"><span data-stu-id="67ebb-148">However, in certain situations the same message may be redelivered.</span></span> <span data-ttu-id="67ebb-149">Pokud scénář nemůže tolerovat zpracování duplicitní, pak je potřeba další logiku v aplikaci vyhledat duplicity, které lze dosáhnout na základě **MessageId** vlastnosti zprávy, která zůstává konstantní napříč pokusy o doručení.</span><span class="sxs-lookup"><span data-stu-id="67ebb-149">If the scenario cannot tolerate duplicate processing, then additional logic is required in the application to detect duplicates which can be achieved based upon the **MessageId** property of the message, which remains constant across delivery attempts.</span></span> <span data-ttu-id="67ebb-150">To se označuje jako *právě jednou* zpracování.</span><span class="sxs-lookup"><span data-stu-id="67ebb-150">This is known as *Exactly Once* processing.</span></span>

## <a name="topics-and-subscriptions"></a><span data-ttu-id="67ebb-151">Témata a předplatná</span><span class="sxs-lookup"><span data-stu-id="67ebb-151">Topics and subscriptions</span></span>
<span data-ttu-id="67ebb-152">Na rozdíl od front, ve kterých každou zprávu zpracuje jeden spotřebitel, *témata* a *odběry* poskytovat ve formuláři na více komunikace, *publikování a přihlášení k odběru* vzor.</span><span class="sxs-lookup"><span data-stu-id="67ebb-152">In contrast to queues, in which each message is processed by a single consumer, *topics* and *subscriptions* provide a one-to-many form of communication, in a *publish/subscribe* pattern.</span></span> <span data-ttu-id="67ebb-153">Tato možnost je užitečná pro škálování pro velmi velký počet příjemců, každá publikovaná zpráva je k dispozici všem odběrům registrovaným pro příslušné téma.</span><span class="sxs-lookup"><span data-stu-id="67ebb-153">Useful for scaling to very large numbers of recipients, each published message is made available to each subscription registered with the topic.</span></span> <span data-ttu-id="67ebb-154">Zprávy odeslané do tématu se doručí na jeden nebo více přidružených odběrů, v závislosti na pravidla filtru, které lze nastavit na základě za předplatné.</span><span class="sxs-lookup"><span data-stu-id="67ebb-154">Messages are sent to a topic and delivered to one or more associated subscriptions, depending on filter rules that can be set on a per-subscription basis.</span></span> <span data-ttu-id="67ebb-155">Odběry můžete použít další filtry a omezit zprávy, které chcete dostávat.</span><span class="sxs-lookup"><span data-stu-id="67ebb-155">The subscriptions can use additional filters to restrict the messages that they want to receive.</span></span> <span data-ttu-id="67ebb-156">Se odesílají zprávy do tématu stejným způsobem, se odešlou do fronty, ale nejsou v tématu přímo přijaty zprávy.</span><span class="sxs-lookup"><span data-stu-id="67ebb-156">Messages are sent to a topic in the same way they are sent to a queue, but messages are not received from the topic directly.</span></span> <span data-ttu-id="67ebb-157">Místo toho jsou přijímány z předplatného.</span><span class="sxs-lookup"><span data-stu-id="67ebb-157">Instead, they are received from subscriptions.</span></span> <span data-ttu-id="67ebb-158">Předplatné tématu se podobá virtuální frontě, která obdrží kopii zprávy, které jsou odeslány do tématu.</span><span class="sxs-lookup"><span data-stu-id="67ebb-158">A topic subscription resembles a virtual queue that receives copies of the messages that are sent to the topic.</span></span> <span data-ttu-id="67ebb-159">Zprávy se přijaté z odběru stejně jako způsob příjmu z fronty.</span><span class="sxs-lookup"><span data-stu-id="67ebb-159">Messages are received from a subscription identically to the way they are received from a queue.</span></span>

<span data-ttu-id="67ebb-160">Prostřednictvím porovnání funkci zasílání zpráv fronty mapuje přímo do tématu a jeho funkce příjem zpráv se mapuje na předplatné.</span><span class="sxs-lookup"><span data-stu-id="67ebb-160">By way of comparison, the message-sending functionality of a queue maps directly to a topic and its message-receiving functionality maps to a subscription.</span></span> <span data-ttu-id="67ebb-161">Kromě jiných věcí, to znamená, že odběry podporují stejné vzory dříve popisované v této části s ohledem na fronty: konkurence mezi spotřebiteli, časové oddělení, Vyrovnávání zatížení a vyrovnávání zatížení.</span><span class="sxs-lookup"><span data-stu-id="67ebb-161">Among other things, this means that subscriptions support the same patterns described earlier in this section with regard to queues: competing consumer, temporal decoupling, load leveling, and load balancing.</span></span>

<span data-ttu-id="67ebb-162">Vytvoření tématu je podobná vytváření fronty, jak je znázorněno v příkladu v předchozí části.</span><span class="sxs-lookup"><span data-stu-id="67ebb-162">Creating a topic is similar to creating a queue, as shown in the example in the previous section.</span></span> <span data-ttu-id="67ebb-163">Vytvořit URI služby a pak použít [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) třídy za účelem vytvoření oboru názvů klienta.</span><span class="sxs-lookup"><span data-stu-id="67ebb-163">Create the service URI, and then use the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class to create the namespace client.</span></span> <span data-ttu-id="67ebb-164">Potom můžete vytvořit téma pomocí [CreateTopic](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateTopic_System_String_) metoda.</span><span class="sxs-lookup"><span data-stu-id="67ebb-164">You can then create a topic using the [CreateTopic](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateTopic_System_String_) method.</span></span> <span data-ttu-id="67ebb-165">Například:</span><span class="sxs-lookup"><span data-stu-id="67ebb-165">For example:</span></span>

```csharp
TopicDescription dataCollectionTopic = namespaceClient.CreateTopic("DataCollectionTopic");
```

<span data-ttu-id="67ebb-166">V dalším kroku přidejte odběry podle potřeby:</span><span class="sxs-lookup"><span data-stu-id="67ebb-166">Next, add subscriptions as desired:</span></span>

```csharp
SubscriptionDescription myAgentSubscription = namespaceClient.CreateSubscription(myTopic.Path, "Inventory");
SubscriptionDescription myAuditSubscription = namespaceClient.CreateSubscription(myTopic.Path, "Dashboard");
```

<span data-ttu-id="67ebb-167">Potom můžete vytvořit téma klienta.</span><span class="sxs-lookup"><span data-stu-id="67ebb-167">You can then create a topic client.</span></span> <span data-ttu-id="67ebb-168">Například:</span><span class="sxs-lookup"><span data-stu-id="67ebb-168">For example:</span></span>

```csharp
MessagingFactory factory = MessagingFactory.Create(serviceUri, tokenProvider);
TopicClient myTopicClient = factory.CreateTopicClient(myTopic.Path)
```

<span data-ttu-id="67ebb-169">Pomocí odesílatele zprávy, můžete odesílat a přijímat zprávy do tématu, jak je uvedeno v předchozí části.</span><span class="sxs-lookup"><span data-stu-id="67ebb-169">Using the message sender, you can send and receive messages to and from the topic, as shown in the previous section.</span></span> <span data-ttu-id="67ebb-170">Například:</span><span class="sxs-lookup"><span data-stu-id="67ebb-170">For example:</span></span>

```csharp
foreach (BrokeredMessage message in messageList)
{
    myTopicClient.Send(message);
    Console.WriteLine(
    string.Format("Message sent: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
}
```

<span data-ttu-id="67ebb-171">Podobně jako u front, jsou přijaty zprávy pomocí předplatného [SubscriptionClient](/dotnet/api/microsoft.servicebus.messaging.subscriptionclient) objektu místo [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) objektu.</span><span class="sxs-lookup"><span data-stu-id="67ebb-171">Similar to queues, messages are received from a subscription using a [SubscriptionClient](/dotnet/api/microsoft.servicebus.messaging.subscriptionclient) object instead of a [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) object.</span></span> <span data-ttu-id="67ebb-172">Vytvoření klienta předplatné, předávání název tématu, názvu předplatné a (volitelně) režimu receive jako parametry.</span><span class="sxs-lookup"><span data-stu-id="67ebb-172">Create the subscription client, passing the name of the topic, the name of the subscription, and (optionally) the receive mode as parameters.</span></span> <span data-ttu-id="67ebb-173">Například s **inventáře** předplatného:</span><span class="sxs-lookup"><span data-stu-id="67ebb-173">For example, with the **Inventory** subscription:</span></span>

```csharp
// Create the subscription client
MessagingFactory factory = MessagingFactory.Create(serviceUri, tokenProvider); 

SubscriptionClient agentSubscriptionClient = factory.CreateSubscriptionClient("IssueTrackingTopic", "Inventory", ReceiveMode.PeekLock);
SubscriptionClient auditSubscriptionClient = factory.CreateSubscriptionClient("IssueTrackingTopic", "Dashboard", ReceiveMode.ReceiveAndDelete); 

while ((message = agentSubscriptionClient.Receive(TimeSpan.FromSeconds(5))) != null)
{
    Console.WriteLine("\nReceiving message from Inventory...");
    Console.WriteLine(string.Format("Message received: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
    message.Complete();
}          

// Create a receiver using ReceiveAndDelete mode
while ((message = auditSubscriptionClient.Receive(TimeSpan.FromSeconds(5))) != null)
{
    Console.WriteLine("\nReceiving message from Dashboard...");
    Console.WriteLine(string.Format("Message received: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
}
```

### <a name="rules-and-actions"></a><span data-ttu-id="67ebb-174">Pravidla a akce</span><span class="sxs-lookup"><span data-stu-id="67ebb-174">Rules and actions</span></span>
<span data-ttu-id="67ebb-175">V mnoha případech je nutné zpracovat zprávy, které mají určité charakteristické vlastnosti různými způsoby.</span><span class="sxs-lookup"><span data-stu-id="67ebb-175">In many scenarios, messages that have specific characteristics must be processed in different ways.</span></span> <span data-ttu-id="67ebb-176">Chcete-li povolit, můžete nakonfigurovat odběry najít zprávy, které mají požadovaných vlastností a pak provést určité úpravy tyto vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="67ebb-176">To enable this, you can configure subscriptions to find messages that have desired properties and then perform certain modifications to those properties.</span></span> <span data-ttu-id="67ebb-177">Při odběry služby Service Bus zobrazit všechny zprávy odeslané do tématu, kopírovat můžete pouze podmnožinu těchto zpráv do fronty virtuální odběru.</span><span class="sxs-lookup"><span data-stu-id="67ebb-177">While Service Bus subscriptions see all messages sent to the topic, you can only copy a subset of those messages to the virtual subscription queue.</span></span> <span data-ttu-id="67ebb-178">To se provádí pomocí filtrů odběrů.</span><span class="sxs-lookup"><span data-stu-id="67ebb-178">This is accomplished using subscription filters.</span></span> <span data-ttu-id="67ebb-179">Tyto změny se nazývají *akce filtru*.</span><span class="sxs-lookup"><span data-stu-id="67ebb-179">Such modifications are called *filter actions*.</span></span> <span data-ttu-id="67ebb-180">Když je vytvořen předplatné, můžete zadat výraz filtru, který funguje na vlastnosti zprávy, vlastnosti systému (například **popisek**) a vlastností vlastní aplikaci (například  **StoreName**.) Výraz filtru SQL je volitelné v tomto případě; bez výraz filtru SQL filtru akce definované na předplatné bude třeba provést na všechny zprávy pro toto předplatné.</span><span class="sxs-lookup"><span data-stu-id="67ebb-180">When a subscription is created, you can supply a filter expression that operates on the properties of the message, both the system properties (for example, **Label**) and custom application properties (for example, **StoreName**.) The SQL filter expression is optional in this case; without a SQL filter expression, any filter action defined on a subscription will be performed on all the messages for that subscription.</span></span>

<span data-ttu-id="67ebb-181">Použijeme předchozí příklad, k filtrování zprávy přicházející pouze z **Store1**, by vytvořit řídicí panel předplatné takto:</span><span class="sxs-lookup"><span data-stu-id="67ebb-181">Using the previous example, to filter messages coming only from **Store1**, you would create the Dashboard subscription as follows:</span></span>

```csharp
namespaceManager.CreateSubscription("IssueTrackingTopic", "Dashboard", new SqlFilter("StoreName = 'Store1'"));
```

<span data-ttu-id="67ebb-182">K tomuto filtru předplatné v místě, jen zprávy, které mají `StoreName` vlastnost nastavena na hodnotu `Store1` se zkopírují do virtuální fronty pro `Dashboard` předplatné.</span><span class="sxs-lookup"><span data-stu-id="67ebb-182">With this subscription filter in place, only messages that have the `StoreName` property set to `Store1` are copied to the virtual queue for the `Dashboard` subscription.</span></span>

<span data-ttu-id="67ebb-183">Další informace o možných filtru hodnoty, najdete v dokumentaci pro [SqlFilter](/dotnet/api/microsoft.servicebus.messaging.sqlfilter) a [SqlRuleAction](/dotnet/api/microsoft.servicebus.messaging.sqlruleaction) třídy.</span><span class="sxs-lookup"><span data-stu-id="67ebb-183">For more information about possible filter values, see the documentation for the [SqlFilter](/dotnet/api/microsoft.servicebus.messaging.sqlfilter) and [SqlRuleAction](/dotnet/api/microsoft.servicebus.messaging.sqlruleaction) classes.</span></span> <span data-ttu-id="67ebb-184">Další informace naleznete [zprostředkované zasílání zpráv: rozšířené filtry](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749) a [tématu filtry](https://github.com/Azure-Samples/azure-servicebus-messaging-samples/tree/master/TopicFilters) ukázky.</span><span class="sxs-lookup"><span data-stu-id="67ebb-184">Also, see the [Brokered Messaging: Advanced Filters](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749) and [Topic Filters](https://github.com/Azure-Samples/azure-servicebus-messaging-samples/tree/master/TopicFilters) samples.</span></span>

## <a name="next-steps"></a><span data-ttu-id="67ebb-185">Další kroky</span><span class="sxs-lookup"><span data-stu-id="67ebb-185">Next steps</span></span>
<span data-ttu-id="67ebb-186">Najdete zde advanced témata pro další informace a příklady použití zasílání zpráv Service Bus.</span><span class="sxs-lookup"><span data-stu-id="67ebb-186">See the following advanced topics for more information and examples of using Service Bus messaging.</span></span>

* [<span data-ttu-id="67ebb-187">Přehled přenosu zpráv ve službě Service Bus</span><span class="sxs-lookup"><span data-stu-id="67ebb-187">Service Bus messaging overview</span></span>](service-bus-messaging-overview.md)
* [<span data-ttu-id="67ebb-188">Kurz .NET pro zprostředkované zasílání zpráv ve službě Service Bus</span><span class="sxs-lookup"><span data-stu-id="67ebb-188">Service Bus brokered messaging .NET tutorial</span></span>](service-bus-brokered-tutorial-dotnet.md)
* [<span data-ttu-id="67ebb-189">Zprostředkované zasílání zpráv kurz REST</span><span class="sxs-lookup"><span data-stu-id="67ebb-189">Service Bus brokered messaging REST tutorial</span></span>](service-bus-brokered-tutorial-rest.md)
* [<span data-ttu-id="67ebb-190">Ukázka filtrů témat</span><span class="sxs-lookup"><span data-stu-id="67ebb-190">Topic Filters sample </span></span>](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/Microsoft.ServiceBus.Messaging/TopicFilters)
* [<span data-ttu-id="67ebb-191">Zprostředkované zasílání zpráv: Ukázka filtrů Advanced</span><span class="sxs-lookup"><span data-stu-id="67ebb-191">Brokered Messaging: Advanced Filters sample</span></span>](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749)

