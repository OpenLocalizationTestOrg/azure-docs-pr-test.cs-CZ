---
title: "Řešení potíží s Azure Redis Cache | Microsoft Docs"
description: "Zjistěte, jak řešit obvyklé problémy s Azure Redis Cache."
services: redis-cache
documentationcenter: 
author: steved0x
manager: douge
editor: 
ms.assetid: 928b9b9c-d64f-4252-884f-af7ba8309af6
ms.service: cache
ms.workload: tbd
ms.tgt_pltfrm: cache-redis
ms.devlang: na
ms.topic: article
ms.date: 01/06/2017
ms.author: sdanie
ms.openlocfilehash: 2e9d1b644f1e80c7d916a261a6c47fcc11a1ffe0
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/11/2017
---
# <a name="how-to-troubleshoot-azure-redis-cache"></a><span data-ttu-id="77679-103">Řešení potíží s Azure Redis Cache</span><span class="sxs-lookup"><span data-stu-id="77679-103">How to troubleshoot Azure Redis Cache</span></span>
<span data-ttu-id="77679-104">Tento článek obsahuje pokyny pro řešení potíží s následující kategorie problémy s Azure Redis Cache.</span><span class="sxs-lookup"><span data-stu-id="77679-104">This article provides guidance for troubleshooting the following categories of Azure Redis Cache issues.</span></span>

* <span data-ttu-id="77679-105">[Řešení potíží s straně klienta](#client-side-troubleshooting) – Tato část obsahuje pokyny pro identifikaci a řešení potíží se nezdařila z důvodu aplikace připojení k Azure Redis Cache.</span><span class="sxs-lookup"><span data-stu-id="77679-105">[Client side troubleshooting](#client-side-troubleshooting) - This section provides guidelines on identifying and resolving issues caused by the application connecting to Azure Redis Cache.</span></span>
* <span data-ttu-id="77679-106">[Řešení potíží s serveru straně](#server-side-troubleshooting) – Tato část obsahuje pokyny pro identifikaci a řešení potíží se nezdařila z důvodu na straně serveru Azure Redis Cache.</span><span class="sxs-lookup"><span data-stu-id="77679-106">[Server side troubleshooting](#server-side-troubleshooting) - This section provides guidelines on identifying and resolving issues caused on the Azure Redis Cache server side.</span></span>
* <span data-ttu-id="77679-107">[Výjimkám časového limitu StackExchange.Redis](#stackexchangeredis-timeout-exceptions) – Tato část obsahuje informace o odstraňování problémů při používání klienta StackExchange.Redis.</span><span class="sxs-lookup"><span data-stu-id="77679-107">[StackExchange.Redis timeout exceptions](#stackexchangeredis-timeout-exceptions) - This section provides information on troubleshooting issues when using the StackExchange.Redis client.</span></span>

> [!NOTE]
> <span data-ttu-id="77679-108">Některé kroky uvedené v této příručce obsahovat pokyny ke spuštění příkazů Redis a monitorování různých metrik výkonu.</span><span class="sxs-lookup"><span data-stu-id="77679-108">Several of the troubleshooting steps in this guide include instructions to run Redis commands and monitor various performance metrics.</span></span> <span data-ttu-id="77679-109">Další informace a pokyny najdete v článcích v [Další informace o](#additional-information) části.</span><span class="sxs-lookup"><span data-stu-id="77679-109">For more information and instructions, see the articles in the [Additional information](#additional-information) section.</span></span>
> 
> 

## <a name="client-side-troubleshooting"></a><span data-ttu-id="77679-110">Řešení potíží s straně klienta</span><span class="sxs-lookup"><span data-stu-id="77679-110">Client side troubleshooting</span></span>
<span data-ttu-id="77679-111">Tato část popisuje řešení problémů, ke kterým dochází kvůli podmínce na klientské aplikaci.</span><span class="sxs-lookup"><span data-stu-id="77679-111">This section discusses troubleshooting issues that occur because of a condition on the client application.</span></span>

* [<span data-ttu-id="77679-112">Přetížení paměti na straně klienta</span><span class="sxs-lookup"><span data-stu-id="77679-112">Memory pressure on the client</span></span>](#memory-pressure-on-the-client)
* [<span data-ttu-id="77679-113">Shluků provozu</span><span class="sxs-lookup"><span data-stu-id="77679-113">Burst of traffic</span></span>](#burst-of-traffic)
* [<span data-ttu-id="77679-114">Klient vysoké využití procesoru</span><span class="sxs-lookup"><span data-stu-id="77679-114">High client CPU usage</span></span>](#high-client-cpu-usage)
* [<span data-ttu-id="77679-115">Překročení šířky pásma straně klienta</span><span class="sxs-lookup"><span data-stu-id="77679-115">Client Side Bandwidth Exceeded</span></span>](#client-side-bandwidth-exceeded)
* [<span data-ttu-id="77679-116">Velikost velké požadavků a odpovědí</span><span class="sxs-lookup"><span data-stu-id="77679-116">Large Request/Response Size</span></span>](#large-requestresponse-size)
* [<span data-ttu-id="77679-117">Co se stalo s mým datům v Redis?</span><span class="sxs-lookup"><span data-stu-id="77679-117">What happened to my data in Redis?</span></span>](#what-happened-to-my-data-in-redis)

### <a name="memory-pressure-on-the-client"></a><span data-ttu-id="77679-118">Přetížení paměti na straně klienta</span><span class="sxs-lookup"><span data-stu-id="77679-118">Memory pressure on the client</span></span>
#### <a name="problem"></a><span data-ttu-id="77679-119">Problém</span><span class="sxs-lookup"><span data-stu-id="77679-119">Problem</span></span>
<span data-ttu-id="77679-120">Přetížení paměti v klientském počítači vede k nejrůznějších druhy problémy s výkonem, které můžou zdržet zpracování dat, který vám byl zaslán instance Redis bez jakéhokoli zpoždění.</span><span class="sxs-lookup"><span data-stu-id="77679-120">Memory pressure on the client machine leads to all kinds of performance problems that can delay processing of data that was sent by the Redis instance without any delay.</span></span> <span data-ttu-id="77679-121">Pokud se dotkne přetížení paměti, systém obvykle má k datům stránky, od fyzické paměti na virtuální paměti, která je na disku.</span><span class="sxs-lookup"><span data-stu-id="77679-121">When memory pressure hits, the system typically has to page data from physical memory to virtual memory which is on disk.</span></span> <span data-ttu-id="77679-122">To *stránky chybující* způsobí, že systém výrazně zpomalit.</span><span class="sxs-lookup"><span data-stu-id="77679-122">This *page faulting* causes the system to slow down significantly.</span></span>

#### <a name="measurement"></a><span data-ttu-id="77679-123">Měření</span><span class="sxs-lookup"><span data-stu-id="77679-123">Measurement</span></span>
1. <span data-ttu-id="77679-124">Monitorování využití paměti v počítači a ujistěte se, že nepřekročí dostupné paměti.</span><span class="sxs-lookup"><span data-stu-id="77679-124">Monitor memory usage on machine to make sure that it does not exceed available memory.</span></span> 
2. <span data-ttu-id="77679-125">Monitorování `Page Faults/Sec` čítače výkonu.</span><span class="sxs-lookup"><span data-stu-id="77679-125">Monitor the `Page Faults/Sec` performance counter.</span></span> <span data-ttu-id="77679-126">Většina systémů bude mít některé chyb stránek i při běžném provozu, takže sledování špiček v tomto čítači výkonu chyb stránky, odpovídajících s vypršení časových limitů.</span><span class="sxs-lookup"><span data-stu-id="77679-126">Most systems will have some page faults even during normal operation, so watch for spikes in this page faults performance counter which correspond with timeouts.</span></span>

#### <a name="resolution"></a><span data-ttu-id="77679-127">Řešení</span><span class="sxs-lookup"><span data-stu-id="77679-127">Resolution</span></span>
<span data-ttu-id="77679-128">Upgrade vašeho klienta ke klientovi větší velikost virtuálního počítače s více paměti nebo proniknout do vašeho vzory využití paměti ke snížení consuption paměti.</span><span class="sxs-lookup"><span data-stu-id="77679-128">Upgrade your client to a larger client VM size with more memory or dig into your memory usage patterns to reduce memory consuption.</span></span>

### <a name="burst-of-traffic"></a><span data-ttu-id="77679-129">Shluků provozu</span><span class="sxs-lookup"><span data-stu-id="77679-129">Burst of traffic</span></span>
#### <a name="problem"></a><span data-ttu-id="77679-130">Problém</span><span class="sxs-lookup"><span data-stu-id="77679-130">Problem</span></span>
<span data-ttu-id="77679-131">Shluky provozu v kombinaci s nízká `ThreadPool` nastavení může vést k prodlevám při zpracování dat již odesílané serverem Redis, ale ještě nebyla použije na straně klienta.</span><span class="sxs-lookup"><span data-stu-id="77679-131">Bursts of traffic combined with poor `ThreadPool` settings can result in delays in processing data already sent by the Redis Server but not yet consumed on the client side.</span></span>

#### <a name="measurement"></a><span data-ttu-id="77679-132">Měření</span><span class="sxs-lookup"><span data-stu-id="77679-132">Measurement</span></span>
<span data-ttu-id="77679-133">Monitorování jak vaše `ThreadPool` časem pomocí kódu změnit statistiky [podobné výjimky](https://github.com/JonCole/SampleCode/blob/master/ThreadPoolMonitor/ThreadPoolLogger.cs).</span><span class="sxs-lookup"><span data-stu-id="77679-133">Monitor how your `ThreadPool` statistics change over time using code [like this](https://github.com/JonCole/SampleCode/blob/master/ThreadPoolMonitor/ThreadPoolLogger.cs).</span></span> <span data-ttu-id="77679-134">Můžete také zobrazit `TimeoutException` zprávu od StackExchange.Redis.</span><span class="sxs-lookup"><span data-stu-id="77679-134">You can also look at the `TimeoutException` message from StackExchange.Redis.</span></span> <span data-ttu-id="77679-135">Tady je příklad:</span><span class="sxs-lookup"><span data-stu-id="77679-135">Here is an example :</span></span>

    System.TimeoutException: Timeout performing EVAL, inst: 8, mgr: Inactive, queue: 0, qu: 0, qs: 0, qc: 0, wr: 0, wq: 0, in: 64221, ar: 0, 
    IOCP: (Busy=6,Free=999,Min=2,Max=1000), WORKER: (Busy=7,Free=8184,Min=2,Max=8191)

<span data-ttu-id="77679-136">Ve výše uvedené zprávě existují několik problémů, které jsou zajímavé:</span><span class="sxs-lookup"><span data-stu-id="77679-136">In the above message, there are several issues that are interesting:</span></span>

1. <span data-ttu-id="77679-137">Všimněte si, že v `IOCP` části a `WORKER` části máte `Busy` hodnotu, která je větší než `Min` hodnotu.</span><span class="sxs-lookup"><span data-stu-id="77679-137">Notice that in the `IOCP` section and the `WORKER` section you have a `Busy` value that is greater than the `Min` value.</span></span> <span data-ttu-id="77679-138">To znamená, že vaše `ThreadPool` nastavení je třeba úprava.</span><span class="sxs-lookup"><span data-stu-id="77679-138">This means that your `ThreadPool` settings need adjusting.</span></span>
2. <span data-ttu-id="77679-139">Můžete také zjistit `in: 64221`.</span><span class="sxs-lookup"><span data-stu-id="77679-139">You can also see `in: 64221`.</span></span> <span data-ttu-id="77679-140">To znamená, že byly přijaty ve vrstvě soketu jádra 64211 bajtů, ale nebyly přečteny aplikací (například StackExchange.Redis).</span><span class="sxs-lookup"><span data-stu-id="77679-140">This indicates that 64211 bytes have been received at the kernel socket layer but haven't yet been read by the application (e.g. StackExchange.Redis).</span></span> <span data-ttu-id="77679-141">To obvykle znamená, že aplikace není čtení dat ze sítě serveru je odeslání vám rychle.</span><span class="sxs-lookup"><span data-stu-id="77679-141">This typically means that your application isn't reading data from the network as quickly as the server is sending it to you.</span></span>

#### <a name="resolution"></a><span data-ttu-id="77679-142">Řešení</span><span class="sxs-lookup"><span data-stu-id="77679-142">Resolution</span></span>
<span data-ttu-id="77679-143">Konfigurace vaší [nastavení fondu podprocesů](https://gist.github.com/JonCole/e65411214030f0d823cb) a ujistěte se, že se rychle v části škálování fondu vláken burst scénáře.</span><span class="sxs-lookup"><span data-stu-id="77679-143">Configure your [ThreadPool Settings](https://gist.github.com/JonCole/e65411214030f0d823cb) to make sure that your thread pool will scale up quickly under burst scenarios.</span></span>

### <a name="high-client-cpu-usage"></a><span data-ttu-id="77679-144">Klient vysoké využití procesoru</span><span class="sxs-lookup"><span data-stu-id="77679-144">High client CPU usage</span></span>
#### <a name="problem"></a><span data-ttu-id="77679-145">Problém</span><span class="sxs-lookup"><span data-stu-id="77679-145">Problem</span></span>
<span data-ttu-id="77679-146">Vysoké využití procesoru na straně klienta je znamená, že systém nedokáže držet krok s práci, kterou byla požádána k provedení.</span><span class="sxs-lookup"><span data-stu-id="77679-146">High CPU usage on the client is an indication that the system cannot keep up with the work that it has been asked to perform.</span></span> <span data-ttu-id="77679-147">To znamená, že klient může dojít k selhání zpracovat včas odpověď od Redis, i když Redis odeslané odpovědi velmi rychle.</span><span class="sxs-lookup"><span data-stu-id="77679-147">This means that the client may fail to process a response from Redis in a timely fashion even though Redis sent the response very quickly.</span></span>

#### <a name="measurement"></a><span data-ttu-id="77679-148">Měření</span><span class="sxs-lookup"><span data-stu-id="77679-148">Measurement</span></span>
<span data-ttu-id="77679-149">Sledování využití procesoru široké systému prostřednictvím portálu Azure nebo čítače výkonu přidružený.</span><span class="sxs-lookup"><span data-stu-id="77679-149">Monitor the System Wide CPU usage through the Azure Portal or through the associated performance counter.</span></span> <span data-ttu-id="77679-150">Dejte pozor, abyste monitorování *proces* procesoru, protože v jednom procesu mohou být nízké využití procesoru ve stejné čas této celého systému procesoru může být vysoká.</span><span class="sxs-lookup"><span data-stu-id="77679-150">Be careful not to monitor *process* CPU because a single process can have low CPU usage at the same time that overall system CPU can be high.</span></span> <span data-ttu-id="77679-151">Sledování špiček využití procesoru, které odpovídají s vypršení časových limitů.</span><span class="sxs-lookup"><span data-stu-id="77679-151">Watch for spikes in CPU usage that correspond with timeouts.</span></span> <span data-ttu-id="77679-152">V důsledku vysoké využití procesoru, může se také zobrazit základní `in: XXX` hodnoty v `TimeoutException` chybové zprávy, jak je popsáno v [shluků provozu](#burst-of-traffic) části.</span><span class="sxs-lookup"><span data-stu-id="77679-152">As a result of high CPU, you may also see high `in: XXX` values in `TimeoutException` error messages as described in the [Burst of traffic](#burst-of-traffic) section.</span></span>

> [!NOTE]
> <span data-ttu-id="77679-153">StackExchange.Redis 1.1.603 a dále zahrnuje `local-cpu` metriky v `TimeoutException` chybové zprávy.</span><span class="sxs-lookup"><span data-stu-id="77679-153">StackExchange.Redis 1.1.603 and later includes the `local-cpu` metric in `TimeoutException` error messages.</span></span> <span data-ttu-id="77679-154">Ujistěte se, používáte nejnovější verzi [balíčku StackExchange.Redis NuGet](https://www.nuget.org/packages/StackExchange.Redis/).</span><span class="sxs-lookup"><span data-stu-id="77679-154">Ensure you using the latest version of the [StackExchange.Redis NuGet package](https://www.nuget.org/packages/StackExchange.Redis/).</span></span> <span data-ttu-id="77679-155">Existují opravených neustále se kód, který ho robustnější do vypršení časových limitů, nejnovější verze je důležité.</span><span class="sxs-lookup"><span data-stu-id="77679-155">There are bugs constantly being fixed in the code to make it more robust to timeouts so having the latest version is important.</span></span>
> 
> 

#### <a name="resolution"></a><span data-ttu-id="77679-156">Řešení</span><span class="sxs-lookup"><span data-stu-id="77679-156">Resolution</span></span>
<span data-ttu-id="77679-157">Upgrade na větší velikost virtuálního počítače s větší kapacitu procesoru nebo zjistěte, co ho způsobuje vzroste využití procesoru.</span><span class="sxs-lookup"><span data-stu-id="77679-157">Upgrade to a larger VM size with more CPU capacity or investigate what is causing CPU spikes.</span></span> 

### <a name="client-side-bandwidth-exceeded"></a><span data-ttu-id="77679-158">Překročení šířky pásma straně klienta</span><span class="sxs-lookup"><span data-stu-id="77679-158">Client side bandwidth exceeded</span></span>
#### <a name="problem"></a><span data-ttu-id="77679-159">Problém</span><span class="sxs-lookup"><span data-stu-id="77679-159">Problem</span></span>
<span data-ttu-id="77679-160">Různé velikostí klientské počítače mají omezení na tom, kolik šířku pásma sítě mají k dispozici.</span><span class="sxs-lookup"><span data-stu-id="77679-160">Different sized client machines have limitations on how much network bandwidth they have available.</span></span> <span data-ttu-id="77679-161">Pokud klient překračuje dostupnou šířku pásma, pak data nebudou zpracovány na straně klienta rychle odesílá na server.</span><span class="sxs-lookup"><span data-stu-id="77679-161">If the client exceeds the available bandwidth, then data will not be processed on the client side as quickly as the server is sending it.</span></span> <span data-ttu-id="77679-162">To může vést k vypršení časových limitů.</span><span class="sxs-lookup"><span data-stu-id="77679-162">This can lead to timeouts.</span></span>

#### <a name="measurement"></a><span data-ttu-id="77679-163">Měření</span><span class="sxs-lookup"><span data-stu-id="77679-163">Measurement</span></span>
<span data-ttu-id="77679-164">Monitorování, jak změnit použití šířky pásma v čase pomocí kódu [podobné výjimky](https://github.com/JonCole/SampleCode/blob/master/BandWidthMonitor/BandwidthLogger.cs).</span><span class="sxs-lookup"><span data-stu-id="77679-164">Monitor how your Bandwidth usage change over time using code [like this](https://github.com/JonCole/SampleCode/blob/master/BandWidthMonitor/BandwidthLogger.cs).</span></span> <span data-ttu-id="77679-165">Všimněte si, že tento kód nemusí spustit, v některých prostředích s omezenými oprávněními (například weby Azure).</span><span class="sxs-lookup"><span data-stu-id="77679-165">Note that this code may not run successfully in some environments with restricted permissions (like Azure web sites).</span></span>

#### <a name="resolution"></a><span data-ttu-id="77679-166">Řešení</span><span class="sxs-lookup"><span data-stu-id="77679-166">Resolution</span></span>
<span data-ttu-id="77679-167">Zvětšete velikost virtuálního počítače klienta nebo snížení využití šířky pásma sítě.</span><span class="sxs-lookup"><span data-stu-id="77679-167">Increase Client VM size or reduce network bandwidth consumption.</span></span>

### <a name="large-requestresponse-size"></a><span data-ttu-id="77679-168">Velikost velké požadavků a odpovědí</span><span class="sxs-lookup"><span data-stu-id="77679-168">Large Request/Response Size</span></span>
#### <a name="problem"></a><span data-ttu-id="77679-169">Problém</span><span class="sxs-lookup"><span data-stu-id="77679-169">Problem</span></span>
<span data-ttu-id="77679-170">Velké požadavků a odpovědí může způsobit překročení časového limitu.</span><span class="sxs-lookup"><span data-stu-id="77679-170">A large request/response can cause timeouts.</span></span> <span data-ttu-id="77679-171">Předpokládejme například, klientem hodnota časového limitu je 1 sekunda.</span><span class="sxs-lookup"><span data-stu-id="77679-171">As an example, Suppose your timeout value configured on your client is 1 second.</span></span> <span data-ttu-id="77679-172">Vaše aplikace požaduje dva klíče (např.) "A" a "B") ve stejnou dobu (pomocí stejné fyzické síti připojení).</span><span class="sxs-lookup"><span data-stu-id="77679-172">Your application requests two keys (e.g. 'A' and 'B') at the same time (using the same physical network connection).</span></span> <span data-ttu-id="77679-173">Většina klienti podporují "Pipelining" požadavků, tak, aby obě "A" a "B" jsou odeslání požadavků v drátové síti k serveru, jedna po druhé bez čekání odezvu.</span><span class="sxs-lookup"><span data-stu-id="77679-173">Most clients support "Pipelining" of requests, such that both requests 'A' and 'B' are sent on the wire to the server one after the other without waiting for the responses.</span></span> <span data-ttu-id="77679-174">Server bude posílat odpovědi zpět ve stejném pořadí.</span><span class="sxs-lookup"><span data-stu-id="77679-174">The server will send the responses back in the same order.</span></span> <span data-ttu-id="77679-175">Pokud je odpověď "A" velký dostatečně ho vyžadovat značné množství většinu časového limitu pro následné požadavky.</span><span class="sxs-lookup"><span data-stu-id="77679-175">If response 'A' is large enough it can eat up most of the timeout for subsequent requests.</span></span> 

<span data-ttu-id="77679-176">Následující příklad ukazuje, tento scénář.</span><span class="sxs-lookup"><span data-stu-id="77679-176">The following example demonstrates this scenario.</span></span> <span data-ttu-id="77679-177">V tomto scénáři jsou rychle odeslat žádost o "A" a "B", server se spustí rychle odesílání odpovědí "A" a "B", ale kvůli doba přenosu dat, "B" uváznout za dalších požadavků a časy se to i v případě, že rychle odpověď serveru.</span><span class="sxs-lookup"><span data-stu-id="77679-177">In this scenario, Request 'A' and 'B' are sent quickly, the server starts sending responses 'A' and 'B' quickly, but because of data transfer times, 'B' get stuck behind the other request and times out even though the server responded quickly.</span></span>

    |-------- 1 Second Timeout (A)----------|
    |-Request A-|
         |-------- 1 Second Timeout (B) ----------|
         |-Request B-|
                |- Read Response A --------|
                                           |- Read Response B-| (**TIMEOUT**)



#### <a name="measurement"></a><span data-ttu-id="77679-178">Měření</span><span class="sxs-lookup"><span data-stu-id="77679-178">Measurement</span></span>
<span data-ttu-id="77679-179">Toto je obtížné jeden k měření.</span><span class="sxs-lookup"><span data-stu-id="77679-179">This is a difficult one to measure.</span></span> <span data-ttu-id="77679-180">Máte v podstatě instrumentace váš klientský kód ke sledování velké požadavky a odpovědi.</span><span class="sxs-lookup"><span data-stu-id="77679-180">You basically have to instrument your client code to track large requests and responses.</span></span> 

#### <a name="resolution"></a><span data-ttu-id="77679-181">Řešení</span><span class="sxs-lookup"><span data-stu-id="77679-181">Resolution</span></span>
1. <span data-ttu-id="77679-182">Redis je optimalizovaná pro velké množství malých hodnoty, nikoli několik velkých hodnot.</span><span class="sxs-lookup"><span data-stu-id="77679-182">Redis is optimized for a large number of small values, rather than a few large values.</span></span> <span data-ttu-id="77679-183">Upřednostňované řešením je rozdělit data do související menší hodnoty.</span><span class="sxs-lookup"><span data-stu-id="77679-183">The preferred solution is to break up your data into related smaller values.</span></span> <span data-ttu-id="77679-184">Najdete v článku [co je velikost rozsah hodnot ideální pro redis? Je příliš velký 100KB? ](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) post podrobnosti kolem Proč se doporučují menší hodnoty.</span><span class="sxs-lookup"><span data-stu-id="77679-184">See the [What is the ideal value size range for redis? Is 100KB too large?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) post for details around why smaller values are recommended.</span></span>
2. <span data-ttu-id="77679-185">Zvětšete velikost virtuálního počítače (pro klienta a serveru Redis mezipaměti), získat vyšší možnosti šířky pásma, snižuje doba přenosu dat pro větší odpovědi.</span><span class="sxs-lookup"><span data-stu-id="77679-185">Increase the size of your VM (for client and Redis Cache Server), to get higher bandwidth capabilities, reducing data transfer times for larger responses.</span></span> <span data-ttu-id="77679-186">Všimněte si, že získávání větší šířku pásma na právě serveru nebo jenom na klienta nemusí stačit.</span><span class="sxs-lookup"><span data-stu-id="77679-186">Note that getting more bandwidth on just the server or just on the client may not be enough.</span></span> <span data-ttu-id="77679-187">Měření použití šířky pásma a porovnejte je s možností velikost virtuálního počítače, které máte aktuálně.</span><span class="sxs-lookup"><span data-stu-id="77679-187">Measure your bandwidth usage and compare it to the capabilities of the size of VM you currently have.</span></span>
3. <span data-ttu-id="77679-188">Zvyšte počet `ConnectionMultiplexer` objekty můžete použít a kruhového dotazování požadavky přes jiné připojení.</span><span class="sxs-lookup"><span data-stu-id="77679-188">Increase the number of `ConnectionMultiplexer` objects you use and round-robin requests over different connections.</span></span>

### <a name="what-happened-to-my-data-in-redis"></a><span data-ttu-id="77679-189">Co se stalo s mým datům v Redis?</span><span class="sxs-lookup"><span data-stu-id="77679-189">What happened to my data in Redis?</span></span>
#### <a name="problem"></a><span data-ttu-id="77679-190">Problém</span><span class="sxs-lookup"><span data-stu-id="77679-190">Problem</span></span>
<span data-ttu-id="77679-191">Očekávání pro určité instance Moje Azure Redis Cache jde data, ale nebyla zdá být k dispozici.</span><span class="sxs-lookup"><span data-stu-id="77679-191">I expected for certain data to be in my Azure Redis Cache instance but it didn't seem to be there.</span></span>

#### <a name="resolution"></a><span data-ttu-id="77679-192">Řešení</span><span class="sxs-lookup"><span data-stu-id="77679-192">Resolution</span></span>
<span data-ttu-id="77679-193">V tématu [co se stalo s mým datům v Redis?](https://gist.github.com/JonCole/b6354d92a2d51c141490f10142884ea4#file-whathappenedtomydatainredis-md) možné příčiny a řešení.</span><span class="sxs-lookup"><span data-stu-id="77679-193">See [What happened to my data in Redis?](https://gist.github.com/JonCole/b6354d92a2d51c141490f10142884ea4#file-whathappenedtomydatainredis-md) for possible causes and resolutions.</span></span>

## <a name="server-side-troubleshooting"></a><span data-ttu-id="77679-194">Řešení potíží s straně serveru</span><span class="sxs-lookup"><span data-stu-id="77679-194">Server side troubleshooting</span></span>
<span data-ttu-id="77679-195">Tato část popisuje řešení problémů, ke kterým dochází z důvodu stavu na serveru mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="77679-195">This section discusses troubleshooting issues that occur because of a condition on the cache server.</span></span>

* [<span data-ttu-id="77679-196">Přetížení paměti na serveru</span><span class="sxs-lookup"><span data-stu-id="77679-196">Memory Pressure on the server</span></span>](#memory-pressure-on-the-server)
* [<span data-ttu-id="77679-197">Vysoké využití procesoru / Server načíst</span><span class="sxs-lookup"><span data-stu-id="77679-197">High CPU usage / Server Load</span></span>](#high-cpu-usage-server-load)
* [<span data-ttu-id="77679-198">Překročení šířky pásma straně serveru</span><span class="sxs-lookup"><span data-stu-id="77679-198">Server Side Bandwidth Exceeded</span></span>](#server-side-bandwidth-exceeded)

### <a name="memory-pressure-on-the-server"></a><span data-ttu-id="77679-199">Přetížení paměti na serveru</span><span class="sxs-lookup"><span data-stu-id="77679-199">Memory Pressure on the server</span></span>
#### <a name="problem"></a><span data-ttu-id="77679-200">Problém</span><span class="sxs-lookup"><span data-stu-id="77679-200">Problem</span></span>
<span data-ttu-id="77679-201">Přetížení paměti na straně serveru vede k nejrůznějších druhy problémy s výkonem, které můžou zdržet zpracování požadavků.</span><span class="sxs-lookup"><span data-stu-id="77679-201">Memory pressure on the server side leads to all kinds of performance problems that can delay processing of requests.</span></span> <span data-ttu-id="77679-202">Pokud se dotkne přetížení paměti, systém obvykle má k datům stránky, od fyzické paměti na virtuální paměti, která je na disku.</span><span class="sxs-lookup"><span data-stu-id="77679-202">When memory pressure hits, the system typically has to page data from physical memory to virtual memory which is on disk.</span></span> <span data-ttu-id="77679-203">To *stránky chybující* způsobí, že systém výrazně zpomalit.</span><span class="sxs-lookup"><span data-stu-id="77679-203">This *page faulting* causes the system to slow down significantly.</span></span> <span data-ttu-id="77679-204">Existuje několik možných příčin této přetížení paměti:</span><span class="sxs-lookup"><span data-stu-id="77679-204">There are several possible causes of this memory pressure:</span></span> 

1. <span data-ttu-id="77679-205">Jste vyplnili mezipaměti, aby kapacita s daty.</span><span class="sxs-lookup"><span data-stu-id="77679-205">You have filled the cache to full capacity with data.</span></span> 
2. <span data-ttu-id="77679-206">Redis se zobrazuje fragmentace paměti vysoké - nejčastěji způsobeno ukládání velkých objektů (Redis je optimalizovaná pro malé objekty - najdete [co je velikost rozsah hodnot ideální pro redis? Je příliš velký 100KB? ](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) post podrobnosti).</span><span class="sxs-lookup"><span data-stu-id="77679-206">Redis is seeing high memory fragmentation - most often caused by storing large objects (Redis is optimized for a small objects - See the [What is the ideal value size range for redis? Is 100KB too large?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) post for details).</span></span> 

#### <a name="measurement"></a><span data-ttu-id="77679-207">Měření</span><span class="sxs-lookup"><span data-stu-id="77679-207">Measurement</span></span>
<span data-ttu-id="77679-208">Redis zpřístupní dvě metriky, které pomáhají identifikovat potíže.</span><span class="sxs-lookup"><span data-stu-id="77679-208">Redis exposes two metrics that can help you identify this issue.</span></span> <span data-ttu-id="77679-209">První je `used_memory` a druhá je `used_memory_rss`.</span><span class="sxs-lookup"><span data-stu-id="77679-209">The first is `used_memory` and the other is `used_memory_rss`.</span></span> <span data-ttu-id="77679-210">[Tyto metriky](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) jsou k dispozici na portálu Azure nebo prostřednictvím [Redis informace](http://redis.io/commands/info) příkaz.</span><span class="sxs-lookup"><span data-stu-id="77679-210">[These metrics](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) are available in the Azure Portal or through the [Redis INFO](http://redis.io/commands/info) command.</span></span>

#### <a name="resolution"></a><span data-ttu-id="77679-211">Řešení</span><span class="sxs-lookup"><span data-stu-id="77679-211">Resolution</span></span>
<span data-ttu-id="77679-212">Existuje několik možných změny, které můžete provést zajistit, aby byl v pořádku využití paměti:</span><span class="sxs-lookup"><span data-stu-id="77679-212">There are several possible changes that you can make to help keep memory usage healthy:</span></span>

1. <span data-ttu-id="77679-213">[Nakonfigurujte zásady paměti](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) a nastavit čas vypršení platnosti na vaše klíče.</span><span class="sxs-lookup"><span data-stu-id="77679-213">[Configure a memory policy](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) and set expiration times on your keys.</span></span> <span data-ttu-id="77679-214">Všimněte si, že to nemusí být dostatečná, pokud máte fragmentace.</span><span class="sxs-lookup"><span data-stu-id="77679-214">Note that this may not be sufficient if you have fragmentation.</span></span>
2. <span data-ttu-id="77679-215">[Nakonfigurovat hodnotu vyhrazené maxmemory](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) , je dostatečně velký pro kompenzovat fragmentace paměti.</span><span class="sxs-lookup"><span data-stu-id="77679-215">[Configure a maxmemory-reserved value](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) that is large enough to compensate for memory fragmentation.</span></span>
3. <span data-ttu-id="77679-216">Rozdělte vaší rozsáhlé objekty uložené v mezipaměti do menších související objekty.</span><span class="sxs-lookup"><span data-stu-id="77679-216">Break up your large cached objects into smaller related objects.</span></span>
4. <span data-ttu-id="77679-217">[Škálování](cache-how-to-scale.md) větší velikost mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="77679-217">[Scale](cache-how-to-scale.md) to a larger cache size.</span></span>
5. <span data-ttu-id="77679-218">Pokud používáte [premium mezipaměť Redis clusteru povolena](cache-how-to-premium-clustering.md) můžete [zvýšit počet horizontálních oddílů](cache-how-to-premium-clustering.md#change-the-cluster-size-on-a-running-premium-cache).</span><span class="sxs-lookup"><span data-stu-id="77679-218">If you are using a [premium cache with Redis cluster enabled](cache-how-to-premium-clustering.md) you can [increase the number of shards](cache-how-to-premium-clustering.md#change-the-cluster-size-on-a-running-premium-cache).</span></span>

### <a name="high-cpu-usage--server-load"></a><span data-ttu-id="77679-219">Vysoké využití procesoru / Server načíst</span><span class="sxs-lookup"><span data-stu-id="77679-219">High CPU usage / Server Load</span></span>
#### <a name="problem"></a><span data-ttu-id="77679-220">Problém</span><span class="sxs-lookup"><span data-stu-id="77679-220">Problem</span></span>
<span data-ttu-id="77679-221">Vysoké využití procesoru může znamenat, že na straně klienta se nemusí zdařit zpracovat včas odpověď od Redis, i když Redis odeslané odpovědi velmi rychle.</span><span class="sxs-lookup"><span data-stu-id="77679-221">High CPU usage can mean that the client side can fail to process a response from Redis in a timely fashion even though Redis sent the response very quickly.</span></span>

#### <a name="measurement"></a><span data-ttu-id="77679-222">Měření</span><span class="sxs-lookup"><span data-stu-id="77679-222">Measurement</span></span>
<span data-ttu-id="77679-223">Sledování využití procesoru široké systému prostřednictvím portálu Azure nebo čítače výkonu přidružený.</span><span class="sxs-lookup"><span data-stu-id="77679-223">Monitor the System Wide CPU usage through the Azure Portal or through the associated performance counter.</span></span> <span data-ttu-id="77679-224">Dejte pozor, abyste monitorování *proces* procesoru, protože v jednom procesu mohou být nízké využití procesoru ve stejné čas této celého systému procesoru může být vysoká.</span><span class="sxs-lookup"><span data-stu-id="77679-224">Be careful not to monitor *process* CPU because a single process can have low CPU usage at the same time that overall system CPU can be high.</span></span> <span data-ttu-id="77679-225">Sledování špiček využití procesoru, které odpovídají s vypršení časových limitů.</span><span class="sxs-lookup"><span data-stu-id="77679-225">Watch for spikes in CPU usage that correspond with timeouts.</span></span>

#### <a name="resolution"></a><span data-ttu-id="77679-226">Řešení</span><span class="sxs-lookup"><span data-stu-id="77679-226">Resolution</span></span>
<span data-ttu-id="77679-227">[Škálování](cache-how-to-scale.md) větší mezipaměti vrstvy s větší kapacitu procesoru nebo zjistit, co ho způsobuje vzroste využití procesoru.</span><span class="sxs-lookup"><span data-stu-id="77679-227">[Scale](cache-how-to-scale.md) to a larger cache tier with more CPU capacity or investigate what is causing CPU spikes.</span></span> 

### <a name="server-side-bandwidth-exceeded"></a><span data-ttu-id="77679-228">Překročení šířky pásma straně serveru</span><span class="sxs-lookup"><span data-stu-id="77679-228">Server Side Bandwidth Exceeded</span></span>
#### <a name="problem"></a><span data-ttu-id="77679-229">Problém</span><span class="sxs-lookup"><span data-stu-id="77679-229">Problem</span></span>
<span data-ttu-id="77679-230">Různé velikostí instance mají omezení na tom, kolik šířku pásma sítě mají k dispozici.</span><span class="sxs-lookup"><span data-stu-id="77679-230">Different sized cache instances have limitations on how much network bandwidth they have available.</span></span> <span data-ttu-id="77679-231">Pokud server překračuje dostupnou šířku pásma, nebudou data odeslat klientovi jako rychle.</span><span class="sxs-lookup"><span data-stu-id="77679-231">If the server exceeds the available bandwidth, then data will not be sent to the client as quickly.</span></span> <span data-ttu-id="77679-232">To může vést k vypršení časových limitů.</span><span class="sxs-lookup"><span data-stu-id="77679-232">This can lead to timeouts.</span></span>

#### <a name="measurement"></a><span data-ttu-id="77679-233">Měření</span><span class="sxs-lookup"><span data-stu-id="77679-233">Measurement</span></span>
<span data-ttu-id="77679-234">Můžete sledovat `Cache Read` metriku, což je množství dat načten z mezipaměti v MB za sekundu (MB/s) během zadaného intervalu sestavy.</span><span class="sxs-lookup"><span data-stu-id="77679-234">You can monitor the `Cache Read` metric, which is the amount of data read from the cache in Megabytes per second (MB/s) during the specified reporting interval.</span></span> <span data-ttu-id="77679-235">Tato hodnota odpovídá šířku pásma sítě používané této mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="77679-235">This value corresponds to the network bandwidth used by this cache.</span></span> <span data-ttu-id="77679-236">Pokud chcete nastavit výstrahy pro omezení šířky pásma sítě straně serveru, můžete je vytvořit pomocí této `Cache Read` čítače.</span><span class="sxs-lookup"><span data-stu-id="77679-236">If you want to set up alerts for server side network bandwidth limits, you can create them using this `Cache Read` counter.</span></span> <span data-ttu-id="77679-237">Porovnání s hodnotami ve vašem odečty [Tato tabulka](cache-faq.md#cache-performance) mezí zjištěnou šířky pásma pro různé mezipaměti cenové úrovně a velikosti.</span><span class="sxs-lookup"><span data-stu-id="77679-237">Compare your readings with the values in [this table](cache-faq.md#cache-performance) for the observed bandwidth limits for various cache pricing tiers and sizes.</span></span>

#### <a name="resolution"></a><span data-ttu-id="77679-238">Řešení</span><span class="sxs-lookup"><span data-stu-id="77679-238">Resolution</span></span>
<span data-ttu-id="77679-239">Pokud jste konzistentně téměř zjištěnou maximální šířka pásma pro cenovou úroveň a mezipaměti velikost, vezměte v úvahu [škálování](cache-how-to-scale.md) cenovou úroveň nebo velikost, která má větší šířku pásma sítě, pomocí hodnoty v [Tato tabulka](cache-faq.md#cache-performance) jako vodítko.</span><span class="sxs-lookup"><span data-stu-id="77679-239">If you are consistently near the observed maximum bandwidth for your pricing tier and cache size, consider [scaling](cache-how-to-scale.md) to a pricing tier or size that has greater network bandwidth, using the values in [this table](cache-faq.md#cache-performance) as a guide.</span></span>

## <a name="stackexchangeredis-timeout-exceptions"></a><span data-ttu-id="77679-240">Výjimkám časového limitu StackExchange.Redis</span><span class="sxs-lookup"><span data-stu-id="77679-240">StackExchange.Redis timeout exceptions</span></span>
<span data-ttu-id="77679-241">Název nastavení používá StackExchange.Redis `synctimeout` pro synchronní operace, které má výchozí hodnotu 1000 ms.</span><span class="sxs-lookup"><span data-stu-id="77679-241">StackExchange.Redis uses a configuration setting named `synctimeout` for synchronous operations which has a default value  of 1000 ms.</span></span> <span data-ttu-id="77679-242">Pokud synchronní volání nedokončí stanovené včas, vyvolá klienta StackExchange.Redis vypršení časového limitu, podobně jako v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="77679-242">If a synchronous call doesn’t complete in the stipulated time, the StackExchange.Redis client throws a timeout error similar to the following example.</span></span>

    System.TimeoutException: Timeout performing MGET 2728cc84-58ae-406b-8ec8-3f962419f641, inst: 1,mgr: Inactive, queue: 73, qu=6, qs=67, qc=0, wr=1/1, in=0/0 IOCP: (Busy=6, Free=999, Min=2,Max=1000), WORKER (Busy=7,Free=8184,Min=2,Max=8191)


<span data-ttu-id="77679-243">Tato chybová zpráva obsahuje metriky, které může pomoci, přejděte na příčina a jejich možná řešení problému.</span><span class="sxs-lookup"><span data-stu-id="77679-243">This error message contains metrics that can help point you to the cause and possible resolution of the issue.</span></span> <span data-ttu-id="77679-244">Následující tabulka obsahuje podrobnosti o metriku chybová zpráva.</span><span class="sxs-lookup"><span data-stu-id="77679-244">The following table contains details about the error message metrics.</span></span>

| <span data-ttu-id="77679-245">Metrika chybová zpráva</span><span class="sxs-lookup"><span data-stu-id="77679-245">Error message metric</span></span> | <span data-ttu-id="77679-246">Podrobnosti</span><span class="sxs-lookup"><span data-stu-id="77679-246">Details</span></span> |
| --- | --- |
| <span data-ttu-id="77679-247">INST</span><span class="sxs-lookup"><span data-stu-id="77679-247">inst</span></span> |<span data-ttu-id="77679-248">V posledním časovém intervalu: 0 příkazy vydané</span><span class="sxs-lookup"><span data-stu-id="77679-248">In the last time slice: 0 commands have been issued</span></span> |
| <span data-ttu-id="77679-249">Mgr</span><span class="sxs-lookup"><span data-stu-id="77679-249">mgr</span></span> |<span data-ttu-id="77679-250">Správce soketu provádí `socket.select` což znamená, že je dotazem operačního systému k označení soketu, který má něco udělat; v podstatě: čtečka není čtení aktivně ze sítě. vzhledem k tomu, že není myslíte, je něco udělat</span><span class="sxs-lookup"><span data-stu-id="77679-250">The socket manager is performing `socket.select` which means it is asking the OS to indicate a socket that has something to do; basically: the reader is not actively reading from the network because it doesn't think there is anything to do</span></span> |
| <span data-ttu-id="77679-251">Fronty</span><span class="sxs-lookup"><span data-stu-id="77679-251">queue</span></span> |<span data-ttu-id="77679-252">73 celkový průběh operace</span><span class="sxs-lookup"><span data-stu-id="77679-252">There are 73 total in-progress operations</span></span> |
| <span data-ttu-id="77679-253">qu</span><span class="sxs-lookup"><span data-stu-id="77679-253">qu</span></span> |<span data-ttu-id="77679-254">6 v průběhu operace jsou ve frontě neodeslaných a nebyly dosud zapsány do odchozí sítě</span><span class="sxs-lookup"><span data-stu-id="77679-254">6 of the in-progress operations are in the unsent queue and have not yet been written to the outbound network</span></span> |
| <span data-ttu-id="77679-255">QS</span><span class="sxs-lookup"><span data-stu-id="77679-255">qs</span></span> |<span data-ttu-id="77679-256">67 he v průběhu operací byly odeslány na server, ale odpověď ještě není k dispozici.</span><span class="sxs-lookup"><span data-stu-id="77679-256">67 of he in-progress operations have been sent to the server but a response is not yet available.</span></span> <span data-ttu-id="77679-257">Odpovědí může být `Not yet sent by the server` nebo`sent by the server but not yet processed by the client.`</span><span class="sxs-lookup"><span data-stu-id="77679-257">The response could be `Not yet sent by the server` or `sent by the server but not yet processed by the client.`</span></span> |
| <span data-ttu-id="77679-258">QC</span><span class="sxs-lookup"><span data-stu-id="77679-258">qc</span></span> |<span data-ttu-id="77679-259">0 v průběhu operací viděli jste, odpoví, ale ještě nebyly byl označen jako dokončení z důvodu čekání na dokončení smyčky</span><span class="sxs-lookup"><span data-stu-id="77679-259">0 of the in-progress operations have seen replies but have not yet been marked as complete due to waiting on the completion loop</span></span> |
| <span data-ttu-id="77679-260">WR</span><span class="sxs-lookup"><span data-stu-id="77679-260">wr</span></span> |<span data-ttu-id="77679-261">Je bajtů/activewriters active zapisovače (což znamená, že nejsou ignorovány 6 neodeslaných požadavky)</span><span class="sxs-lookup"><span data-stu-id="77679-261">There is an active writer (meaning the 6 unsent requests are not being ignored) bytes/activewriters</span></span> |
| <span data-ttu-id="77679-262">V</span><span class="sxs-lookup"><span data-stu-id="77679-262">in</span></span> |<span data-ttu-id="77679-263">Neexistují žádné aktivní čtečky a nulový počet bajtů, které jsou k dispozici ke čtení v bajtech/activereaders síťový adaptér</span><span class="sxs-lookup"><span data-stu-id="77679-263">There are no active readers and zero bytes are available to be read on the NIC bytes/activereaders</span></span> |

### <a name="steps-to-investigate"></a><span data-ttu-id="77679-264">Kroky k prozkoumání</span><span class="sxs-lookup"><span data-stu-id="77679-264">Steps to investigate</span></span>
1. <span data-ttu-id="77679-265">Jako osvědčený postup, ujistěte se používají následující vzor pro připojení při používání klienta StackExchange.Redis.</span><span class="sxs-lookup"><span data-stu-id="77679-265">As a best practice make sure you are using the following pattern to connect when using the StackExchange.Redis client.</span></span>

    ```c#
    private static Lazy<ConnectionMultiplexer> lazyConnection = new Lazy<ConnectionMultiplexer>(() =>
    {
        return ConnectionMultiplexer.Connect("cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...");
    
    });
    
    public static ConnectionMultiplexer Connection
    {
        get
        {
            return lazyConnection.Value;
        }
    }
    ````

    <span data-ttu-id="77679-266">Další informace najdete v tématu [připojení k mezipaměti StackExchange.Redis](cache-dotnet-how-to-use-azure-redis-cache.md#connect-to-the-cache).</span><span class="sxs-lookup"><span data-stu-id="77679-266">For more information, see [Connect to the cache using StackExchange.Redis](cache-dotnet-how-to-use-azure-redis-cache.md#connect-to-the-cache).</span></span>

1. <span data-ttu-id="77679-267">Zajistěte, aby Azure Redis Cache a klientská aplikace byly ve stejné oblasti v Azure.</span><span class="sxs-lookup"><span data-stu-id="77679-267">Ensure that your Azure Redis Cache and the client application are in the same region in Azure.</span></span> <span data-ttu-id="77679-268">Například se vám může zobrazovat časové limity při vaše mezipaměť je ve východní USA, ale klient nachází v západní USA a není v rámci dokončení požadavku `synctimeout` interval, nebo může být získávání překročení časového limitu při ladění z místním vývojovém počítači.</span><span class="sxs-lookup"><span data-stu-id="77679-268">For example, you might be getting timeouts when your cache is in East US but the client is in West US and the request doesn't complete within the `synctimeout` interval or you might be getting timeouts when you are debugging from your local development machine.</span></span> 
   
    <span data-ttu-id="77679-269">Má důrazně doporučujeme mít mezipaměti a v klientovi ve stejné oblasti Azure.</span><span class="sxs-lookup"><span data-stu-id="77679-269">It’s highly recommended to have the cache and in the client in the same Azure region.</span></span> <span data-ttu-id="77679-270">Pokud máte scénáře, který zahrnuje volání různých oblastí, byste měli nastavit `synctimeout` interval na hodnotu vyšší, než je výchozí interval 1000 ms zahrnutím `synctimeout` vlastnost v připojovacím řetězci.</span><span class="sxs-lookup"><span data-stu-id="77679-270">If you have a scenario that includes cross region calls, you should set the `synctimeout` interval to a value higher than the default 1000 ms interval by including a `synctimeout` property in the connection string.</span></span> <span data-ttu-id="77679-271">Následující příklad ukazuje fragment StackExchange.Redis mezipaměti připojovací řetězec s `synctimeout` z 2000 ms.</span><span class="sxs-lookup"><span data-stu-id="77679-271">The following example shows a StackExchange.Redis cache connection string snippet with a `synctimeout` of 2000 ms.</span></span>
   
        synctimeout=2000,cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...
2. <span data-ttu-id="77679-272">Ujistěte se, používáte nejnovější verzi [balíčku StackExchange.Redis NuGet](https://www.nuget.org/packages/StackExchange.Redis/).</span><span class="sxs-lookup"><span data-stu-id="77679-272">Ensure you using the latest version of the [StackExchange.Redis NuGet package](https://www.nuget.org/packages/StackExchange.Redis/).</span></span> <span data-ttu-id="77679-273">Existují opravených neustále se kód, který ho robustnější do vypršení časových limitů, nejnovější verze je důležité.</span><span class="sxs-lookup"><span data-stu-id="77679-273">There are bugs constantly being fixed in the code to make it more robust to timeouts so having the latest version is important.</span></span>
3. <span data-ttu-id="77679-274">Pokud jsou požadavky, které jsou získávání svázaná s omezení šířky pásma na serveru nebo klienta, bude trvat delší dobu, je k dokončení a tím způsobit překročení časového limitu.</span><span class="sxs-lookup"><span data-stu-id="77679-274">If there are requests that are getting bound by bandwidth limitations on the server or client, it will take longer for them to complete and thereby cause timeouts.</span></span> <span data-ttu-id="77679-275">Pokud je vaše časový limit šířky pásma sítě na serveru najdete v tématu [šířky pásma serveru straně překročena](#server-side-bandwidth-exceeded).</span><span class="sxs-lookup"><span data-stu-id="77679-275">To see if your timeout is due to network bandwidth on the server, see [Server side bandwidth exceeded](#server-side-bandwidth-exceeded).</span></span> <span data-ttu-id="77679-276">Pokud je vaše časový limit šířky pásma sítě klienta najdete v tématu [šířky pásma straně klienta, která je překročena](#client-side-bandwidth-exceeded).</span><span class="sxs-lookup"><span data-stu-id="77679-276">To see if your timeout is due to client network bandwidth, see [Client side bandwidth exceeded](#client-side-bandwidth-exceeded).</span></span>
4. <span data-ttu-id="77679-277">Můžete získávání procesoru na serveru nebo na straně klienta je vázána?</span><span class="sxs-lookup"><span data-stu-id="77679-277">Are you getting CPU bound on the server or on the client?</span></span>
   
   * <span data-ttu-id="77679-278">Zkontrolujte, pokud jste se získávání svázaná s procesoru na vašeho klienta, což by mohlo způsobit požadavek nelze zpracovat v rámci `synctimeout` interval, což způsobuje vypršení časového limitu.</span><span class="sxs-lookup"><span data-stu-id="77679-278">Check if you are getting bound by CPU on your client which could cause the request to not be processed within the `synctimeout` interval, thus causing a timeout.</span></span> <span data-ttu-id="77679-279">Přechod na větší velikost klienta nebo distribuci zatížení vám může pomoct řídit to.</span><span class="sxs-lookup"><span data-stu-id="77679-279">Moving to a larger client size or distributing the load can help to control this.</span></span> 
   * <span data-ttu-id="77679-280">Zkontrolujte, jestli se zobrazuje procesoru vázaný na serveru pomocí monitorování `CPU` [mezipaměti metrika výkonu](cache-how-to-monitor.md#available-metrics-and-reporting-intervals).</span><span class="sxs-lookup"><span data-stu-id="77679-280">Check if you are getting CPU bound on the server by monitoring the `CPU` [cache performance metric](cache-how-to-monitor.md#available-metrics-and-reporting-intervals).</span></span> <span data-ttu-id="77679-281">Požadavky přicházející Redis je vázán procesoru může způsobit těchto požadavků do vypršení časového limitu.</span><span class="sxs-lookup"><span data-stu-id="77679-281">Requests coming in while Redis is CPU bound can cause those requests to timeout.</span></span> <span data-ttu-id="77679-282">Z tohoto můžete rozdělit zatížení mezi víc horizontálních oddílů v mezipaměti premium nebo upgradujte na větší velikost nebo cenovou úroveň.</span><span class="sxs-lookup"><span data-stu-id="77679-282">To address this you can distribute the load across multiple shards in a premium cache, or upgrade to a larger size or pricing tier.</span></span> <span data-ttu-id="77679-283">Další informace najdete v tématu [překročení šířky pásma serveru straně](#server-side-bandwidth-exceeded).</span><span class="sxs-lookup"><span data-stu-id="77679-283">For more information, see [Server Side Bandwidth Exceeded](#server-side-bandwidth-exceeded).</span></span>
5. <span data-ttu-id="77679-284">Existují příkazy trvá dlouhou dobu ke zpracování na serveru?</span><span class="sxs-lookup"><span data-stu-id="77679-284">Are there commands taking long time to process on the server?</span></span> <span data-ttu-id="77679-285">Dlouho běžící příkazy, které trvá dlouhou dobu ke zpracování na serveru redis může způsobit překročení časového limitu.</span><span class="sxs-lookup"><span data-stu-id="77679-285">Long running commands that are taking long time to process on the redis-server can cause timeouts.</span></span> <span data-ttu-id="77679-286">Některé příklady příkazů dlouhotrvající `mget` s velkým počtem klíče, `keys *` nebo chybně napsané skripty lua.</span><span class="sxs-lookup"><span data-stu-id="77679-286">Some examples of long running commands are `mget` with large numbers of keys, `keys *` or poorly written lua scripts.</span></span> <span data-ttu-id="77679-287">Můžete se připojit k vaší instanci Azure Redis Cache pomocí rozhraní příkazového řádku redis klienta nebo používat [konzola Redis](cache-configure.md#redis-console) a spusťte [SlowLog](http://redis.io/commands/slowlog) příkaz, zobrazí, pokud jsou požadavky trvá déle, než se očekávalo.</span><span class="sxs-lookup"><span data-stu-id="77679-287">You can connect to your Azure Redis Cache instance using the redis-cli client or use the [Redis Console](cache-configure.md#redis-console) and run the [SlowLog](http://redis.io/commands/slowlog) command to see if there are requests taking longer than expected.</span></span> <span data-ttu-id="77679-288">Serveru redis a StackExchange.Redis jsou optimalizované pro mnoho malých požadavků místo méně velké požadavky.</span><span class="sxs-lookup"><span data-stu-id="77679-288">Redis Server and StackExchange.Redis are optimized for many small requests rather than fewer large requests.</span></span> <span data-ttu-id="77679-289">Rozdělení na menší bloky dat může zvýšit věcí sem.</span><span class="sxs-lookup"><span data-stu-id="77679-289">Splitting your data into smaller chunks may improve things here.</span></span> 
   
    <span data-ttu-id="77679-290">Informace o připojení ke koncovému bodu Azure Redis Cache SSL pomocí rozhraní příkazového řádku redis a stunnel najdete v tématu [uvedení ASP.NET poskytovatele stavu relace pro Redis verze Preview](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx) příspěvku na blogu.</span><span class="sxs-lookup"><span data-stu-id="77679-290">For information on connecting to the Azure Redis Cache SSL endpoint using redis-cli and stunnel, see the [Announcing ASP.NET Session State Provider for Redis Preview Release](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx) blog post.</span></span> <span data-ttu-id="77679-291">Další informace najdete v tématu [SlowLog](http://redis.io/commands/slowlog).</span><span class="sxs-lookup"><span data-stu-id="77679-291">For more information, see [SlowLog](http://redis.io/commands/slowlog).</span></span>
6. <span data-ttu-id="77679-292">Vysoké zatížení serveru Redis může způsobit překročení časového limitu.</span><span class="sxs-lookup"><span data-stu-id="77679-292">High Redis server load can cause timeouts.</span></span> <span data-ttu-id="77679-293">Zatížení serveru můžete monitorovat pomocí monitorování `Redis Server Load` [mezipaměti metrika výkonu](cache-how-to-monitor.md#available-metrics-and-reporting-intervals).</span><span class="sxs-lookup"><span data-stu-id="77679-293">You can monitor the server load by monitoring the `Redis Server Load` [cache performance metric](cache-how-to-monitor.md#available-metrics-and-reporting-intervals).</span></span> <span data-ttu-id="77679-294">Zatížení serveru 100 (maximální hodnota) označuje, že serveru redis byl zaneprázdněn prováděním žádné doba nečinnosti, po zpracování požadavků.</span><span class="sxs-lookup"><span data-stu-id="77679-294">A server load of 100 (maximum value) signifies that the redis server has been busy, with no idle time, processing requests.</span></span> <span data-ttu-id="77679-295">Pokud chcete zobrazit, pokud jsou některé žádosti o zabírá tak všechny funkce serveru, spusťte příkaz SlowLog, jak je popsáno v předchozím odstavci.</span><span class="sxs-lookup"><span data-stu-id="77679-295">To see if certain requests are taking up all of the server capability, run the SlowLog command, as described in the previous paragraph.</span></span> <span data-ttu-id="77679-296">Další informace najdete v tématu [vysoké zatížení CPU / Server načíst](#high-cpu-usage-server-load).</span><span class="sxs-lookup"><span data-stu-id="77679-296">For more information, see [High CPU usage / Server Load](#high-cpu-usage-server-load).</span></span>
7. <span data-ttu-id="77679-297">Byl na straně klienta, která by mohla způsobit sítě blip jiná událost?</span><span class="sxs-lookup"><span data-stu-id="77679-297">Was there any other event on the client side that could have caused a network blip?</span></span> <span data-ttu-id="77679-298">Pokud se například událost škálování počtu instancí klientů nahoru nebo dolů, nebo nasazení nové verze klienta nebo automatické škálování je povolené, zkontrolujte na straně klienta (web, role pracovního procesu nebo virtuálních počítačů Iaas)? V našich testech, které zjistili jsme, že může způsobit škálování nebo škálování nahoru/dolů může být odchozí síťové připojení ke ztrátě pro několik sekund.</span><span class="sxs-lookup"><span data-stu-id="77679-298">Check on the client (web, worker role or an Iaas VM) if there was an event like scaling the number of client instances up or down, or deploying a new version of the client or auto-scale is enabled?In our testing we have found that autoscale or scaling up/down can cause outbound network connectivity can be lost for several seconds.</span></span> <span data-ttu-id="77679-299">Kód StackExchange.Redis odolný proti takové události a bude znovu připojit.</span><span class="sxs-lookup"><span data-stu-id="77679-299">StackExchange.Redis code is resilient to such events and will reconnect.</span></span> <span data-ttu-id="77679-300">Během této doby opakovaného připojení může všech požadavků ve frontě vypršení časového limitu.</span><span class="sxs-lookup"><span data-stu-id="77679-300">During this time of re-connection any requests in the queue can time out.</span></span>
8. <span data-ttu-id="77679-301">Byla žádost big předcházející několik malých požadavků k Redis Cache, který vypršel časový limit?</span><span class="sxs-lookup"><span data-stu-id="77679-301">Was there a big request preceding several small requests to the Redis Cache that timed out?</span></span> <span data-ttu-id="77679-302">Parametr `qs` v chybě zpráva znamená, kolik žádosti byly odeslány z klienta na server, ale nebyly dosud zpracovány odpověď.</span><span class="sxs-lookup"><span data-stu-id="77679-302">The parameter `qs` in the error message tells you how many requests were sent from the client to the server, but have not yet processed a response.</span></span> <span data-ttu-id="77679-303">Tuto hodnotu můžete zachovat narůstají, protože StackExchange.Redis používá jednoho připojení TCP a může číst pouze jedna odpověď najednou.</span><span class="sxs-lookup"><span data-stu-id="77679-303">This value can keep growing because StackExchange.Redis uses a single TCP connection and can only read one response at a time.</span></span> <span data-ttu-id="77679-304">To i v případě, že vypršel časový limit operace první, ale nezastaví dat odeslaných ze serveru a ostatní požadavky jsou zablokované to dokončení, která způsobila časové limity.</span><span class="sxs-lookup"><span data-stu-id="77679-304">Even though the first operation timed out, it does not stop the data being sent to/from the server, and other requests are blocked until this is finished, causing time outs.</span></span> <span data-ttu-id="77679-305">Jedno řešení je omezit možnost vypršení časových limitů zajistíte, že vaše mezipaměť je dostatečně velký pro úlohy a rozdělení na menší bloky velké hodnoty.</span><span class="sxs-lookup"><span data-stu-id="77679-305">One solution is to minimize the chance of timeouts by ensuring that your cache is large enough for your workload and splitting large values into smaller chunks.</span></span> <span data-ttu-id="77679-306">Další možnou příčinou je používat fond `ConnectionMultiplexer` objekty v vašeho klienta a vyberte aspoň načíst `ConnectionMultiplexer` při odesílání novou žádost.</span><span class="sxs-lookup"><span data-stu-id="77679-306">Another possible solution is to use a pool of `ConnectionMultiplexer` objects in your client, and choose the least loaded `ConnectionMultiplexer` when sending a new request.</span></span> <span data-ttu-id="77679-307">To by měl jeden časový limit zabránit v způsobuje ostatních požadavků na taky časový limit.</span><span class="sxs-lookup"><span data-stu-id="77679-307">This should prevent a single timeout from causing other requests to also timeout.</span></span>
9. <span data-ttu-id="77679-308">Pokud používáte `RedisSessionStateprovider`, ujistěte se, jste správně nastavili časový limit opakování.</span><span class="sxs-lookup"><span data-stu-id="77679-308">If you are using `RedisSessionStateprovider`, ensure you have set the retry timeout correctly.</span></span> <span data-ttu-id="77679-309">`retrytimeoutInMilliseconds`musí být vyšší než `operationTimeoutinMilliseonds`, jinak dojde k žádné opakování.</span><span class="sxs-lookup"><span data-stu-id="77679-309">`retrytimeoutInMilliseconds` should be higher than `operationTimeoutinMilliseonds`, otherwise no retries will occur.</span></span> <span data-ttu-id="77679-310">V následujícím příkladu `retrytimeoutInMilliseconds` je nastaven na 3000.</span><span class="sxs-lookup"><span data-stu-id="77679-310">In the following example `retrytimeoutInMilliseconds` is set to 3000.</span></span> <span data-ttu-id="77679-311">Další informace najdete v tématu [poskytovatele stavu relace ASP.NET pro Azure Redis Cache](cache-aspnet-session-state-provider.md) a [jak používat parametry konfigurace poskytovatele stavu relace a poskytovatel výstupní mezipaměti](https://github.com/Azure/aspnet-redis-providers/wiki/Configuration).</span><span class="sxs-lookup"><span data-stu-id="77679-311">For more information, see [ASP.NET Session State Provider for Azure Redis Cache](cache-aspnet-session-state-provider.md) and [How to use the configuration parameters of Session State Provider and Output Cache Provider](https://github.com/Azure/aspnet-redis-providers/wiki/Configuration).</span></span>

    <add
      name="AFRedisCacheSessionStateProvider"
      type="Microsoft.Web.Redis.RedisSessionStateProvider"
      host="enbwcache.redis.cache.windows.net"
      port="6380"
      accessKey="…"
      ssl="true"
      databaseId="0"
      applicationName="AFRedisCacheSessionState"
      connectionTimeoutInMilliseconds = "5000"
      operationTimeoutInMilliseconds = "1000"
      retryTimeoutInMilliseconds="3000" />


1. <span data-ttu-id="77679-312">Zkontrolujte využití paměti na serveru Azure Redis Cache pomocí [monitorování](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `Used Memory RSS` a `Used Memory`.</span><span class="sxs-lookup"><span data-stu-id="77679-312">Check memory usage on the Azure Redis Cache server by [monitoring](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `Used Memory RSS` and `Used Memory`.</span></span> <span data-ttu-id="77679-313">Pokud zásady vyřazení je v místě, Redis spustí při vyřazení klíče `Used_Memory` dosáhne velikosti mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="77679-313">If an eviction policy is in place, Redis starts evicting keys when `Used_Memory` reaches the cache size.</span></span> <span data-ttu-id="77679-314">V ideálním případě `Used Memory RSS` by měly být pouze mírně větší, než `Used memory`.</span><span class="sxs-lookup"><span data-stu-id="77679-314">Ideally, `Used Memory RSS` should be only slightly higher than `Used memory`.</span></span> <span data-ttu-id="77679-315">Velký rozdíl znamená, že fragmentace paměti (interní nebo externí.</span><span class="sxs-lookup"><span data-stu-id="77679-315">A large difference means there is memory fragmentation (internal or external.</span></span> <span data-ttu-id="77679-316">Když `Used Memory RSS` je menší než `Used Memory`, znamená to, součástí paměti mezipaměti byla vzájemně zaměněny v operačním systému.</span><span class="sxs-lookup"><span data-stu-id="77679-316">When `Used Memory RSS` is less than `Used Memory`, it means part of the cache memory has been swapped  by the operating system.</span></span> <span data-ttu-id="77679-317">V takovém případě můžete očekávat některé důležité latenci.</span><span class="sxs-lookup"><span data-stu-id="77679-317">If this occurs you can expect some significant latencies.</span></span> <span data-ttu-id="77679-318">Protože Redis nemá ovládat, jak jsou jeho přidělení mapované na paměťových stránek, vysoké `Used Memory RSS` je často výsledek špička využití paměti.</span><span class="sxs-lookup"><span data-stu-id="77679-318">Because Redis does not have control over how its allocations are mapped to memory pages, high `Used Memory RSS` is often the result of a spike in memory usage.</span></span> <span data-ttu-id="77679-319">Když Redis uvolní paměť, velikost paměti je uveden zpět k přidělujícího modulu a přidělujícího modulu může nebo nemusí poskytnout paměť zpět do systému.</span><span class="sxs-lookup"><span data-stu-id="77679-319">When Redis frees memory, the memory is given back to the allocator, and the allocator may or may not give the memory back to the system.</span></span> <span data-ttu-id="77679-320">Může být v rozporu `Used Memory` hodnota a paměti spotřeby jsou uvedeny v operačním systému.</span><span class="sxs-lookup"><span data-stu-id="77679-320">There may be a discrepancy between the `Used Memory` value and memory consumption as reported by the operating system.</span></span> <span data-ttu-id="77679-321">To může být z důvodu fakt, na který byla používá paměti a vydané ve Redis, ale není zadaný zpátky do systému.</span><span class="sxs-lookup"><span data-stu-id="77679-321">It may be due to the fact memory has been used and released by Redis, but not given back to the system.</span></span> <span data-ttu-id="77679-322">Pro zmírnění problémů paměti můžete provést následující kroky.</span><span class="sxs-lookup"><span data-stu-id="77679-322">To help mitigate memory issues you can perform the following steps.</span></span>
   
   * <span data-ttu-id="77679-323">Upgrade na větší velikost mezipaměti, tak, že nejsou spuštěné zobrazení omezení paměti v systému.</span><span class="sxs-lookup"><span data-stu-id="77679-323">Upgrade the cache to a larger size so that you are not running up against memory limitations on the system.</span></span>
   * <span data-ttu-id="77679-324">Nastavit dobu vypršení platnosti na klíče tak, aby starší hodnoty jsou proaktivně vyřazování.</span><span class="sxs-lookup"><span data-stu-id="77679-324">Set expiration times on the keys so that older values are evicted proactively.</span></span>
   * <span data-ttu-id="77679-325">Monitorování `used_memory_rss` metrika do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="77679-325">Monitor the the `used_memory_rss` cache metric.</span></span> <span data-ttu-id="77679-326">Když se tato hodnota blíží velikosti mezipaměti, budete pravděpodobně začnou problémy s výkonem.</span><span class="sxs-lookup"><span data-stu-id="77679-326">When this value approaches the size of their cache, you are likely to start seeing performance issues.</span></span> <span data-ttu-id="77679-327">Pokud používáte cache ve verzi premium, nebo upgradujte na větší velikost mezipaměti, distribuci dat mezi víc horizontálních oddílů.</span><span class="sxs-lookup"><span data-stu-id="77679-327">Distribute the data across multiple shards if you are using a premium cache, or upgrade to a larger cache size.</span></span>
   
   <span data-ttu-id="77679-328">Další informace najdete v tématu [přetížení paměti na serveru](#memory-pressure-on-the-server).</span><span class="sxs-lookup"><span data-stu-id="77679-328">For more information, see [Memory Pressure on the server](#memory-pressure-on-the-server).</span></span>

## <a name="additional-information"></a><span data-ttu-id="77679-329">Další informace</span><span class="sxs-lookup"><span data-stu-id="77679-329">Additional information</span></span>
* [<span data-ttu-id="77679-330">Jaké nabídky a velikosti Redis Cache mám použít?</span><span class="sxs-lookup"><span data-stu-id="77679-330">What Redis Cache offering and size should I use?</span></span>](cache-faq.md#what-redis-cache-offering-and-size-should-i-use)
* [<span data-ttu-id="77679-331">Jak můžete otestovat a testování výkonu Moje mezipaměti?</span><span class="sxs-lookup"><span data-stu-id="77679-331">How can I benchmark and test the performance of my cache?</span></span>](cache-faq.md#how-can-i-benchmark-and-test-the-performance-of-my-cache)
* [<span data-ttu-id="77679-332">Jak můžete spouštět příkazy Redis?</span><span class="sxs-lookup"><span data-stu-id="77679-332">How can I run Redis commands?</span></span>](cache-faq.md#how-can-i-run-redis-commands)
* [<span data-ttu-id="77679-333">Tom, jak monitorovat Azure Redis Cache</span><span class="sxs-lookup"><span data-stu-id="77679-333">How to monitor Azure Redis Cache</span></span>](cache-how-to-monitor.md)

