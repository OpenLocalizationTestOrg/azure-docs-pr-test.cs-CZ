---
title: "aaaService Fabric spolehlivé aktéři přehled | Microsoft Docs"
description: "Úvod toohello Service Fabric programovacího modelu Reliable Actors."
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: ab010cbf936c6cf723b3d453ef95a9bf51f76c95
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/06/2017
---
# <a name="introduction-tooservice-fabric-reliable-actors"></a><span data-ttu-id="3ef2d-103">Úvod tooService Reliable Actors prostředků infrastruktury</span><span class="sxs-lookup"><span data-stu-id="3ef2d-103">Introduction tooService Fabric Reliable Actors</span></span>
<span data-ttu-id="3ef2d-104">Reliable Actors je architektura aplikace Service Fabric podle hello [virtuální objektu Actor](http://research.microsoft.com/en-us/projects/orleans/) vzor.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-104">Reliable Actors is a Service Fabric application framework based on hello [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="3ef2d-105">Hello spolehlivé aktéři API poskytuje programovací model jednovláknové založený na škálovatelnost a spolehlivost záruky hello poskytované Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-105">hello Reliable Actors API provides a single-threaded programming model built on hello scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="3ef2d-106">Jaké jsou aktéři?</span><span class="sxs-lookup"><span data-stu-id="3ef2d-106">What are Actors?</span></span>
<span data-ttu-id="3ef2d-107">Objekt actor je s jednotkou izolované, nezávislé výpočetních operací a stavu s jedním podprocesem provádění.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="3ef2d-108">Hello [vzor objektu actor](https://en.wikipedia.org/wiki/Actor_model) je výpočetní model souběžných nebo distribuovaných systémů, ve které velké množství těchto aktéři mohou být prováděny současně a nezávisle na sobě navzájem.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-108">hello [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="3ef2d-109">Aktéři mohou komunikovat navzájem a mohou vytvářet další aktéři.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-toouse-reliable-actors"></a><span data-ttu-id="3ef2d-110">Když toouse Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="3ef2d-110">When toouse Reliable Actors</span></span>
<span data-ttu-id="3ef2d-111">Služba Fabric Reliable Actors je implementace tohoto vzoru návrhu objektu actor hello.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-111">Service Fabric Reliable Actors is an implementation of hello actor design pattern.</span></span> <span data-ttu-id="3ef2d-112">Stejně jako u jakékoli vzoru návrhu softwaru hello rozhodnutí, jestli se provádí specifického vzoru toouse podle zda softwaru návrh problém vyhovuje vzoru hello.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-112">As with any software design pattern, hello decision whether toouse a specific pattern is made based on whether or not a software design problem fits hello pattern.</span></span>

<span data-ttu-id="3ef2d-113">I když vzoru návrhu objektu actor hello může být dobrým shody tooa počet distribuovaných systémů problémy a scénáře, pečlivě zvážit omezení hello vzor hello a hello framework implementace, které musí být provedeny.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-113">Although hello actor design pattern can be a good fit tooa number of distributed systems problems and scenarios, careful consideration of hello constraints of hello pattern and hello framework implementing it must be made.</span></span> <span data-ttu-id="3ef2d-114">Jako obecné pokyny vezměte v úvahu hello objektu actor vzor toomodel problém nebo scénář pokud:</span><span class="sxs-lookup"><span data-stu-id="3ef2d-114">As general guidance, consider hello actor pattern toomodel your problem or scenario if:</span></span>

* <span data-ttu-id="3ef2d-115">Váš prostor problém zahrnuje velký počet (tisíc nebo více) malé, nezávislé a izolované jednotek stavu a logiku.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="3ef2d-116">Chcete toowork s jedním podprocesem objekty, které nevyžadují významné interakce z externí součásti, včetně dotaz na stav mezi sadu aktéři.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-116">You want toowork with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="3ef2d-117">Vaše instance objektu actor neblokuje volající s nepředvídatelným zpoždění vydáním vstupně-výstupních operací.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="3ef2d-118">Aktéři v Service Fabric</span><span class="sxs-lookup"><span data-stu-id="3ef2d-118">Actors in Service Fabric</span></span>
<span data-ttu-id="3ef2d-119">V Service Fabric, kteří se implementují ve hello Reliable Actors framework: na základě objektu actor vzor aplikační rozhraní založené na [spolehlivé služby Service Fabric](service-fabric-reliable-services-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="3ef2d-119">In Service Fabric, actors are implemented in hello Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="3ef2d-120">Každý spolehlivé objektu Actor službu, kterou píšete je ve skutečnosti oddílů, stavová spolehlivá služba.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="3ef2d-121">Každý objektu actor je definován jako instance typu objektu actor, způsob identické toohello objekt .NET je instance typu .NET.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-121">Every actor is defined as an instance of an actor type, identical toohello way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="3ef2d-122">Například může být typ objektu actor, který implementuje hello funkce kalkulačky a může být mnoho aktéři daného typu, které jsou rozmístěny v různých uzlech v clusteru.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-122">For example, there may be an actor type that implements hello functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="3ef2d-123">Každé takové objektu actor je jedinečně identifikovaný identifikátor objektu actor.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="3ef2d-124">Doba života objektu actor</span><span class="sxs-lookup"><span data-stu-id="3ef2d-124">Actor Lifetime</span></span>
<span data-ttu-id="3ef2d-125">Service Fabric aktéři jsou virtuální, což znamená, že své životnosti není vázanou tootheir reprezentací v paměti.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-125">Service Fabric actors are virtual, meaning that their lifetime is not tied tootheir in-memory representation.</span></span> <span data-ttu-id="3ef2d-126">V důsledku toho nepotřebují toobe explicitně vytvořen nebo zničeno.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-126">As a result, they do not need toobe explicitly created or destroyed.</span></span> <span data-ttu-id="3ef2d-127">modul runtime Reliable Actors Hello automaticky aktivuje objektu actor hello poprvé obdrží žádost pro ID tohoto objektu actor.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-127">hello Reliable Actors runtime automatically activates an actor hello first time it receives a request for that actor ID.</span></span> <span data-ttu-id="3ef2d-128">Pokud objekt actor se nepoužívá pro určitou dobu, hello Reliable Actors runtime uvolňování paměti – shromažďuje hello objektů v paměti.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-128">If an actor is not used for a period of time, hello Reliable Actors runtime garbage-collects hello in-memory object.</span></span> <span data-ttu-id="3ef2d-129">Také zachová znalostní báze hello objektu actor existence měli toobe později znovu aktivovat.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-129">It will also maintain knowledge of hello actor's existence should it need toobe reactivated later.</span></span> <span data-ttu-id="3ef2d-130">Další podrobnosti najdete v tématu [kolekce paměti a životního cyklu objektu Actor](service-fabric-reliable-actors-lifecycle.md).</span><span class="sxs-lookup"><span data-stu-id="3ef2d-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="3ef2d-131">Tato abstrakce doba života objektu actor virtuální představuje některé upozornění v důsledku hello virtuální objektu actor modelu a ve skutečnosti odchylují hello Reliable Actors implementace v některých případech z tohoto modelu.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-131">This virtual actor lifetime abstraction carries some caveats as a result of hello virtual actor model, and in fact hello Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="3ef2d-132">Objekt actor se automaticky aktivuje (což objektu actor objekt toobe sestavený) hello poprvé, je odeslána zpráva ID tooits objektu actor.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-132">An actor is automatically activated (causing an actor object toobe constructed) hello first time a message is sent tooits actor ID.</span></span> <span data-ttu-id="3ef2d-133">Po nějaké časové období je objekt actor hello uvolnění z paměti.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-133">After some period of time, hello actor object is garbage collected.</span></span> <span data-ttu-id="3ef2d-134">V hello budoucí, znovu pomocí ID objektu actor hello způsobí, že nového objektu actor toobe objekt vytvořený.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-134">In hello future, using hello actor ID again, causes a new actor object toobe constructed.</span></span> <span data-ttu-id="3ef2d-135">Stav objektu actor outlives doba života objektu hello při uložené v hello správce stavu.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-135">An actor's state outlives hello object's lifetime when stored in hello state manager.</span></span>
* <span data-ttu-id="3ef2d-136">Voláním jakékoli metody objektu actor pro ID objektu actor aktivuje tohoto objektu actor.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="3ef2d-137">Z tohoto důvodu objektu actor typy mají jejich Konstruktor volá implicitně hello runtime.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-137">For this reason, actor types have their constructor called implicitly by hello runtime.</span></span> <span data-ttu-id="3ef2d-138">Kód klienta proto nelze předat parametry toohello objektu actor konstruktoru typu, i když parametry mohou být předaná toohello objektu actor konstruktor samotnou službu hello.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-138">Therefore, client code cannot pass parameters toohello actor type's constructor, although parameters may be passed toohello actor's constructor by hello service itself.</span></span> <span data-ttu-id="3ef2d-139">Hello výsledkem je, že aktéři může zkonstruovat ve stavu částečně inicializovat pomocí hello, když se nazývají jiné metody, pokud objektu actor hello vyžaduje inicializační parametry z klienta hello.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-139">hello result is that actors may be constructed in a partially-initialized state by hello time other methods are called on it, if hello actor requires initialization parameters from hello client.</span></span> <span data-ttu-id="3ef2d-140">Neexistuje jeden vstupní bod pro aktivaci hello objektu actor z klienta hello.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-140">There is no single entry point for hello activation of an actor from hello client.</span></span>
* <span data-ttu-id="3ef2d-141">I když Reliable Actors implicitně vytvořit objekty objektu actor; Máte tooexplicitly hello možnost odstranit objekt actor a její stav.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-141">Although Reliable Actors implicitly create actor objects; you do have hello ability tooexplicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="3ef2d-142">Distribuce a převzetí služeb při selhání</span><span class="sxs-lookup"><span data-stu-id="3ef2d-142">Distribution and failover</span></span>
<span data-ttu-id="3ef2d-143">tooprovide škálovatelnost a spolehlivost, Service Fabric distribuuje aktéři v rámci clusteru hello a automaticky migruje je z selhání uzlů toohealthy ty, které jsou podle potřeby.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-143">tooprovide scalability and reliability, Service Fabric distributes actors throughout hello cluster and automatically migrates them from failed nodes toohealthy ones as required.</span></span> <span data-ttu-id="3ef2d-144">Toto je abstrakci přes [oddílů, stavová služba spolehlivé](service-fabric-concepts-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="3ef2d-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="3ef2d-145">Distribuce, škálovatelnost, spolehlivost a automatické převzetí služeb při selhání jsou všechny poskytované na základě hello skutečnost, že aktéři běží ve stavové spolehlivá služba s názvem hello *služby objektu Actor*.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of hello fact that actors are running inside a stateful Reliable Service called hello *Actor Service*.</span></span>

<span data-ttu-id="3ef2d-146">Aktéři jsou rozmístěny v hello oddíly hello služby objektu Actor a tyto oddíly jsou rozmístěny v hello uzlů v clusteru Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-146">Actors are distributed across hello partitions of hello Actor Service, and those partitions are distributed across hello nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="3ef2d-147">Každý oddíl služby obsahuje sadu aktéři.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="3ef2d-148">Service Fabric spravuje distribuce a převzetí služeb při selhání oddílů služby hello.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-148">Service Fabric manages distribution and failover of hello service partitions.</span></span>

<span data-ttu-id="3ef2d-149">Například služby objektu actor s devět oddíly nasadit toothree, které by thusly distribuována uzlů pomocí hello výchozí objektu actor oddílu umístění:</span><span class="sxs-lookup"><span data-stu-id="3ef2d-149">For example, an actor service with nine partitions deployed toothree nodes using hello default actor partition placement would be distributed thusly:</span></span>

![Spolehlivé aktéři distribuce][2]

<span data-ttu-id="3ef2d-151">oddíl schématu a klíč nastavení rozsahu pro vás spravuje Hello objektu Actor Framework.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-151">hello Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="3ef2d-152">Zjednodušuje některé možnosti, ale také představuje některé pozornost:</span><span class="sxs-lookup"><span data-stu-id="3ef2d-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="3ef2d-153">Spolehlivé služby vám umožní toochoose schéma rozdělení oddílů, klíče rozsah (při použití rozsah dělení schéma) a počet oddílů.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-153">Reliable Services allows you toochoose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="3ef2d-154">Reliable Actors je omezená toohello rozsah schéma rozdělení oddílů (hello uniform Int64 schéma) a vyžaduje, že používáte hello plný Int64 klíče rozsah.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-154">Reliable Actors is restricted toohello range partitioning scheme (hello uniform Int64 scheme) and requires you use hello full Int64 key range.</span></span>
* <span data-ttu-id="3ef2d-155">Ve výchozím nastavení se umístí do oddílů, které jsou výsledkem uniform distribuční náhodně aktéři.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="3ef2d-156">Protože aktéři jsou náhodně umístěn, je třeba očekávat, objektu actor operace budou vždy vyžadovat komunikaci sítě, včetně serializace a deserializace dat volání metody, by docházelo k latenci a zatížení.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="3ef2d-157">V pokročilých scénářích je možné toocontrol objektu actor oddílu umístění pomocí objektu actor Int64 ID, které mapují toospecific oddíly.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-157">In advanced scenarios, it is possible toocontrol actor partition placement by using Int64 actor IDs that map toospecific partitions.</span></span> <span data-ttu-id="3ef2d-158">Ale to tak může způsobit jako nevyváženou distribučního aktéři napříč oddíly.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="3ef2d-159">Další informace o tom, jak jsou služby objektu actor do několika oddílů, najdete v části příliš[dělení koncepty pro aktéři](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span><span class="sxs-lookup"><span data-stu-id="3ef2d-159">For more information on how actor services are partitioned, refer too[partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="3ef2d-160">Komunikace objektu actor</span><span class="sxs-lookup"><span data-stu-id="3ef2d-160">Actor communication</span></span>
<span data-ttu-id="3ef2d-161">Interakce objektu actor jsou definovány v rozhraní, které sdílí objektu actor hello, který implementuje rozhraní hello a hello klienta, který získá proxy objektu actor tooan prostřednictvím hello stejné rozhraní.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-161">Actor interactions are defined in an interface that is shared by hello actor that implements hello interface, and hello client that gets a proxy tooan actor via hello same interface.</span></span> <span data-ttu-id="3ef2d-162">Protože toto rozhraní je tooinvoke použitých actor metody asynchronně, musí být každou metodu na rozhraní hello vrácení úloh.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-162">Because this interface is used tooinvoke actor methods asynchronously, every method on hello interface must be Task-returning.</span></span>

<span data-ttu-id="3ef2d-163">Volání metod a jejich odpovědi nakonec za následek síťové požadavky napříč hello clusteru, takže hello argumentů a typy výsledků hello hello úloh, že vrací musejí být serializovatelná platformou hello.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-163">Method invocations and their responses ultimately result in network requests across hello cluster, so hello arguments and hello result types of hello tasks that they return must be serializable by hello platform.</span></span> <span data-ttu-id="3ef2d-164">Konkrétně musí být [kontraktů dat serializovatelný](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="3ef2d-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="hello-actor-proxy"></a><span data-ttu-id="3ef2d-165">Proxy Server Hello objektu actor</span><span class="sxs-lookup"><span data-stu-id="3ef2d-165">hello actor proxy</span></span>
<span data-ttu-id="3ef2d-166">Hello Reliable Actors klientského rozhraní API poskytuje komunikaci mezi instanci objektu actor a objektu actor klienta.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-166">hello Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="3ef2d-167">toocommunicate s objektu actor, klient vytvoří objekt objektu actor proxy serveru, který implementuje rozhraní objektu actor hello.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-167">toocommunicate with an actor, a client creates an actor proxy object that implements hello actor interface.</span></span> <span data-ttu-id="3ef2d-168">Hello klient komunikuje s objektu actor hello volajícím metody u objektu proxy hello.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-168">hello client interacts with hello actor by invoking methods on hello proxy object.</span></span> <span data-ttu-id="3ef2d-169">proxy objektu actor Hello lze použít pro komunikaci klienta do objektu actor a objektu actor actor.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-169">hello actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="3ef2d-170">Hello dva údaje použity toocreate hello objektu actor proxy – objekt jsou hello objekt actor s ID a název aplikace hello.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-170">Note that hello two pieces of information used toocreate hello actor proxy object are hello actor ID and hello application name.</span></span> <span data-ttu-id="3ef2d-171">ID objektu actor Hello jednoznačně identifikuje objektu actor hello, zatímco název aplikace hello identifikuje hello [aplikace Service Fabric](service-fabric-reliable-actors-platform.md#application-model) kde je nasazená objektu actor hello.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-171">hello actor ID uniquely identifies hello actor, while hello application name identifies hello [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where hello actor is deployed.</span></span>

<span data-ttu-id="3ef2d-172">Hello `ActorProxy`(C#) nebo `ActorProxyBase`– třída (Java) na straně klienta hello provede hello nezbytné řešení toolocate objektu actor hello podle ID a otevřete komunikační kanál s ním.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-172">hello `ActorProxy`(C#) / `ActorProxyBase`(Java) class on hello client side performs hello necessary resolution toolocate hello actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="3ef2d-173">Opakuje také toolocate hello objektu actor v případech hello selhání komunikace a převzetí služeb při selhání.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-173">It also retries toolocate hello actor in hello cases of communication failures and failovers.</span></span> <span data-ttu-id="3ef2d-174">V důsledku toho doručování zpráv má hello následující vlastnosti:</span><span class="sxs-lookup"><span data-stu-id="3ef2d-174">As a result, message delivery has hello following characteristics:</span></span>

* <span data-ttu-id="3ef2d-175">Doručení zpráv je nejlepší úsilí.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="3ef2d-176">Aktéři mohou se zobrazit duplicitní zprávy z hello stejného klienta.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-176">Actors may receive duplicate messages from hello same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="3ef2d-177">Souběžnost</span><span class="sxs-lookup"><span data-stu-id="3ef2d-177">Concurrency</span></span>
<span data-ttu-id="3ef2d-178">Hello Reliable Actors runtime poskytuje jednoduché přístupu na základě zapněte model pro přístup k objektu actor metody.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-178">hello Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="3ef2d-179">To znamená, že kdykoli může být aktivní uvnitř objekt actor kód více než jedno vlákno.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="3ef2d-180">Není nutné pro synchronizaci mechanismy pro přístup k datům přístupu na základě zapnout výrazně zjednodušuje souběžných systémy.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="3ef2d-181">Taky to znamená, že systémy musí být vytvořeny s zvláštní upozornění pro hello jednovláknové přístup povaze každá instance objektu actor.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-181">It also means systems must be designed with special considerations for hello single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="3ef2d-182">Více než jeden požadavek nelze zpracovat instance jednoho objektu actor v čase.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="3ef2d-183">Instance objektu actor může způsobit úzkým místem propustnost, pokud je očekávaný toohandle souběžných požadavků.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-183">An actor instance can cause a throughput bottleneck if it is expected toohandle concurrent requests.</span></span>
* <span data-ttu-id="3ef2d-184">Aktéři můžete zablokování na sobě navzájem, pokud je požadavek cyklické mezi dvěma aktéři při Přišla žádost o externí tooone hello aktéři současně.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made tooone of hello actors simultaneously.</span></span> <span data-ttu-id="3ef2d-185">Hello objektu actor runtime bude automaticky času odhlašování v objektu actor volá a k vyvolání k výjimce toohello volající toointerrupt situacích možné zablokování.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-185">hello actor runtime will automatically time out on actor calls and throw an exception toohello caller toointerrupt possible deadlock situations.</span></span>

![Spolehlivé aktéři komunikace][3]

#### <a name="turn-based-access"></a><span data-ttu-id="3ef2d-187">Přístupu na základě zapnout</span><span class="sxs-lookup"><span data-stu-id="3ef2d-187">Turn-based access</span></span>
<span data-ttu-id="3ef2d-188">Zapněte se skládá z hello dokončení provádění metody objektu actor v žádosti o tooa odpovědi jiných klientů nebo aktéři nebo hello dokončení provádění [časovače nebo připomenutí](service-fabric-reliable-actors-timers-reminders.md) zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-188">A turn consists of hello complete execution of an actor method in response tooa request from other actors or clients, or hello complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="3ef2d-189">I když jsou tyto metody a zpětná volání asynchronní, hello aktéři runtime není prokládání dat je.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-189">Even though these methods and callbacks are asynchronous, hello Actors runtime does not interleave them.</span></span> <span data-ttu-id="3ef2d-190">Předtím, než je povolený nový zapnout, musí být plně dokončení zapnout.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="3ef2d-191">Jinými slovy objektu actor metoda nebo časovače nebo připomenutí zpětné volání, které je aktuálně spuštěných musí být plně dokončení před nové metody tooa volání nebo zpětné volání je povolen.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call tooa method or callback is allowed.</span></span> <span data-ttu-id="3ef2d-192">Metoda nebo zpětného volání považuje za toohave dokončení Pokud hello provádění vrátila z metody hello nebo dokončení zpětného volání a hello úlohy vrácený metodou hello nebo zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-192">A method or callback is considered toohave finished if hello execution has returned from hello method or callback and hello task returned by hello method or callback has finished.</span></span> <span data-ttu-id="3ef2d-193">Je vhodné zdůraznění, že na základě zapnout concurrency je dodržena i přes různé metody, časovače a zpětná volání.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="3ef2d-194">Hello aktéři runtime vynucuje na základě zapnout souběžnosti získávání zámku na objektu actor na začátku hello zapnout a uvolněním hello zámku na konci hello hello vypnout.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-194">hello Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at hello beginning of a turn and releasing hello lock at hello end of hello turn.</span></span> <span data-ttu-id="3ef2d-195">Na základě zapnout souběžnosti je proto vynucují na základě za objekt actor a není mezi aktéři.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="3ef2d-196">Metody objektu actor a zpětná volání časovače nebo připomenutí můžete spustit současně jménem různých aktéři.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="3ef2d-197">Hello následující příklad znázorňuje hello výše koncepty.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-197">hello following example illustrates hello above concepts.</span></span> <span data-ttu-id="3ef2d-198">Vezměte v úvahu typ objektu actor, který implementuje dvě asynchronní metody (Řekněme, *Method1* a *Method2*), a časovač a připomenutí.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="3ef2d-199">Hello následující diagram ukazuje příklad časovou osu pro hello provádění těchto metod a zpětná volání jménem dvě aktéři (*ActorId1* a *ActorId2*), patří toothis objektu actor typu.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-199">hello diagram below shows an example of a timeline for hello execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong toothis actor type.</span></span>

![Spolehlivé aktéři modul runtime na základě zapnout souběžnosti a přístup][1]

<span data-ttu-id="3ef2d-201">Tento diagram dodržovat tyto konvence:</span><span class="sxs-lookup"><span data-stu-id="3ef2d-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="3ef2d-202">Každé svislé čáry zobrazuje hello logický tok provádění metody nebo zpětné volání jménem konkrétního objektu actor.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-202">Each vertical line shows hello logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="3ef2d-203">Hello na každé svislé čáry označit k událostem v chronologickém pořadí s novější událostí pod starší.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-203">hello events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="3ef2d-204">Různé barvy se používají pro odpovídající aktéři toodifferent časové osy.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-204">Different colors are used for timelines corresponding toodifferent actors.</span></span>
* <span data-ttu-id="3ef2d-205">Zvýraznění je použité tooindicate hello duration, pro které hello je blokován zámek na objektu actor jménem metoda nebo zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-205">Highlighting is used tooindicate hello duration for which hello per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="3ef2d-206">Některé důležité body tooconsider:</span><span class="sxs-lookup"><span data-stu-id="3ef2d-206">Some important points tooconsider:</span></span>

* <span data-ttu-id="3ef2d-207">Při *Method1* provádí jménem *ActorId2* v odpovědi tooclient požadavku *xyz789*, další požadavek klienta (*abc123*) dorazí, který taky vyžaduje *Method1* toobe provedený *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-207">While *Method1* is executing on behalf of *ActorId2* in response tooclient request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* toobe executed by *ActorId2*.</span></span> <span data-ttu-id="3ef2d-208">Ale hello druhý provádění *Method1* nemá na začátku až do dokončení předchozí provádění hello.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-208">However, hello second execution of *Method1* does not begin until hello prior execution has finished.</span></span> <span data-ttu-id="3ef2d-209">Podobně, zobrazí se připomenutí registrovaných *ActorId2* aktivuje se při *Method1* je spouštěna v odpovědi tooclient požadavku *xyz789*.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response tooclient request *xyz789*.</span></span> <span data-ttu-id="3ef2d-210">Hello zpětného volání připomenutí se spustí až po obou spuštěních z *Method1* jsou dokončeny.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-210">hello reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="3ef2d-211">Všechny tyto je z důvodu souběžnosti na základě tooturn vynucení pro *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-211">All of this is due tooturn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="3ef2d-212">Podobně se na základě zapnout souběžnosti také vynucuje pro *ActorId1*, jak je znázorněno pomocí hello provádění *Method1*, *Method2*, a hello zpětné volání časovače jménem *ActorId1* děje sériové způsobem.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by hello execution of *Method1*, *Method2*, and hello timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="3ef2d-213">Provádění *Method1* jménem *ActorId1* se překrývá s jeho spuštění jménem *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="3ef2d-214">Je to proto, že na základě zapnout concurrency se vynucuje jenom v rámci objektu actor a není napříč aktéři.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="3ef2d-215">V některých hello metoda/zpětného volání spuštěních hello `Task`(C#) nebo `CompletableFuture`(Java) vrácený hello metoda/zpětného volání dokončení po návratu metody hello.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-215">In some of hello method/callback executions, hello `Task`(C#) / `CompletableFuture`(Java) returned by hello method/callback finishes after hello method returns.</span></span> <span data-ttu-id="3ef2d-216">V některých jiných hello asynchronní operace již byla dokončena hello doby, vrátí hodnotu hello metoda/zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-216">In some others, hello asynchronous operation has already finished by hello time hello method/callback returns.</span></span> <span data-ttu-id="3ef2d-217">V obou případech zámku na objektu actor hello vydání až po obě metody nebo zpětné hello volání vrátí, dokončení asynchronní operace hello.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-217">In both cases, hello per-actor lock is released only after both hello method/callback returns and hello asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="3ef2d-218">Vícenásobný přístup</span><span class="sxs-lookup"><span data-stu-id="3ef2d-218">Reentrancy</span></span>
<span data-ttu-id="3ef2d-219">Hello aktéři runtime umožňuje vícenásobný přístup ve výchozím nastavení.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-219">hello Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="3ef2d-220">To znamená, že pokud metoda objektu actor *objektu Actor A* volá metodu na *objektu Actor B*, která volá jinou metodu na *objektu Actor A*, že metoda může toorun.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed toorun.</span></span> <span data-ttu-id="3ef2d-221">Důvodem je, že je součástí hello stejné logické řetězce volání kontextu.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-221">This is because it is part of hello same logical call-chain context.</span></span> <span data-ttu-id="3ef2d-222">Všechna volání časovače a připomenutí začínat hello nové logické volání kontextu.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-222">All timer and reminder calls start with hello new logical call context.</span></span> <span data-ttu-id="3ef2d-223">V tématu hello [vícenásobný přístup Reliable Actors](service-fabric-reliable-actors-reentrancy.md) další podrobnosti.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-223">See hello [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="3ef2d-224">Rozsah záruky souběžnosti</span><span class="sxs-lookup"><span data-stu-id="3ef2d-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="3ef2d-225">modul runtime aktéři Hello poskytuje tyto záruky souběžnosti v situacích, kde se řídí hello volání z těchto metod.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-225">hello Actors runtime provides these concurrency guarantees in situations where it controls hello invocation of these methods.</span></span> <span data-ttu-id="3ef2d-226">Například poskytuje tyto záruky pro hello volání metod, které se provádějí v požadavku klienta tooa odpověď, a také pro zpětné volání časovače a připomenutí.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-226">For example, it provides these guarantees for hello method invocations that are done in response tooa client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="3ef2d-227">Ale pokud hello objektu actor kód přímo vyvolá tyto metody mimo hello mechanismus hello aktéři runtime, hello runtime nelze zadejte žádné záruky souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-227">However, if hello actor code directly invokes these methods outside of hello mechanisms provided by hello Actors runtime, then hello runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="3ef2d-228">Například pokud hello metoda je volána v kontextu hello některé úlohy, který není spojen s hello úloh vrácených metody objektu actor hello, hello runtime nelze zadejte souběžnosti záruky.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-228">For example, if hello method is invoked in hello context of some task that is not associated with hello task returned by hello actor methods, then hello runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="3ef2d-229">Pokud hello metoda je volána z vlákna tohoto objektu actor hello vytvoří sama o sobě, pak hello runtime také neposkytuje souběžnosti záruky.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-229">If hello method is invoked from a thread that hello actor creates on its own, then hello runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="3ef2d-230">Proto měli používat aktéři tooperform operace na pozadí, [objektu actor časovače a upomínek objektu actor](service-fabric-reliable-actors-timers-reminders.md) , respektují na základě zapnout souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="3ef2d-230">Therefore, tooperform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="3ef2d-231">Další kroky</span><span class="sxs-lookup"><span data-stu-id="3ef2d-231">Next steps</span></span>
* <span data-ttu-id="3ef2d-232">Začínáme se ve vaší první službě Reliable Actors:</span><span class="sxs-lookup"><span data-stu-id="3ef2d-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="3ef2d-233">Začínáme s Reliable Actors na rozhraní .NET</span><span class="sxs-lookup"><span data-stu-id="3ef2d-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="3ef2d-234">Začínáme s Reliable Actors v jazyce Java</span><span class="sxs-lookup"><span data-stu-id="3ef2d-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
