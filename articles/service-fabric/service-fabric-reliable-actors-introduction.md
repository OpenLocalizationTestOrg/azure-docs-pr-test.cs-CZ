---
title: "Služba Fabric Reliable Actors přehled | Microsoft Docs"
description: "Úvod do programovacího modelu Service Fabric Reliable Actors."
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: e89be04a0d6fe90a89e293e67d42f0204eb7000a
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/11/2017
---
# <a name="introduction-to-service-fabric-reliable-actors"></a><span data-ttu-id="cdf21-103">Seznámení se službou Service Fabric Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="cdf21-103">Introduction to Service Fabric Reliable Actors</span></span>
<span data-ttu-id="cdf21-104">Reliable Actors je architektura aplikace Service Fabric na základě [virtuální objektu Actor](http://research.microsoft.com/en-us/projects/orleans/) vzor.</span><span class="sxs-lookup"><span data-stu-id="cdf21-104">Reliable Actors is a Service Fabric application framework based on the [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="cdf21-105">Rozhraní API spolehlivé aktéři poskytuje programovací model jednovláknové založený na škálovatelnost a spolehlivost záruk poskytnutých Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="cdf21-105">The Reliable Actors API provides a single-threaded programming model built on the scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="cdf21-106">Jaké jsou aktéři?</span><span class="sxs-lookup"><span data-stu-id="cdf21-106">What are Actors?</span></span>
<span data-ttu-id="cdf21-107">Objekt actor je s jednotkou izolované, nezávislé výpočetních operací a stavu s jedním podprocesem provádění.</span><span class="sxs-lookup"><span data-stu-id="cdf21-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="cdf21-108">[Vzor objektu actor](https://en.wikipedia.org/wiki/Actor_model) je výpočetní model souběžných nebo distribuovaných systémů, ve které velké množství těchto aktéři mohou být prováděny současně a nezávisle na sobě navzájem.</span><span class="sxs-lookup"><span data-stu-id="cdf21-108">The [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="cdf21-109">Aktéři mohou komunikovat navzájem a mohou vytvářet další aktéři.</span><span class="sxs-lookup"><span data-stu-id="cdf21-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-to-use-reliable-actors"></a><span data-ttu-id="cdf21-110">Kdy použít Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="cdf21-110">When to use Reliable Actors</span></span>
<span data-ttu-id="cdf21-111">Služba Fabric Reliable Actors je implementace tohoto vzoru návrhu objektu actor.</span><span class="sxs-lookup"><span data-stu-id="cdf21-111">Service Fabric Reliable Actors is an implementation of the actor design pattern.</span></span> <span data-ttu-id="cdf21-112">Rozhodnutí, jestli se má používat specifického vzoru se provádí podle zda softwaru návrh problém stejně jako u jakékoli vzoru návrhu softwaru vyhovuje vzoru.</span><span class="sxs-lookup"><span data-stu-id="cdf21-112">As with any software design pattern, the decision whether to use a specific pattern is made based on whether or not a software design problem fits the pattern.</span></span>

<span data-ttu-id="cdf21-113">I když objektu actor návrh vzor dobrou vejdou na počet distribuovaných systémů problémy a scénáře, postupujte opatrně, že musí být provedeny zvážení omezení vzoru a rozhraní ho implementujete.</span><span class="sxs-lookup"><span data-stu-id="cdf21-113">Although the actor design pattern can be a good fit to a number of distributed systems problems and scenarios, careful consideration of the constraints of the pattern and the framework implementing it must be made.</span></span> <span data-ttu-id="cdf21-114">Jako obecné pokyny vezměte v úvahu vzor objektu actor pro modelování problém nebo scénář, pokud:</span><span class="sxs-lookup"><span data-stu-id="cdf21-114">As general guidance, consider the actor pattern to model your problem or scenario if:</span></span>

* <span data-ttu-id="cdf21-115">Váš prostor problém zahrnuje velký počet (tisíc nebo více) malé, nezávislé a izolované jednotek stavu a logiku.</span><span class="sxs-lookup"><span data-stu-id="cdf21-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="cdf21-116">Budete chtít pracovat s jedním podprocesem objekty, které nevyžadují významné interakce z externí součásti, včetně dotaz na stav mezi sadu aktéři.</span><span class="sxs-lookup"><span data-stu-id="cdf21-116">You want to work with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="cdf21-117">Vaše instance objektu actor neblokuje volající s nepředvídatelným zpoždění vydáním vstupně-výstupních operací.</span><span class="sxs-lookup"><span data-stu-id="cdf21-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="cdf21-118">Aktéři v Service Fabric</span><span class="sxs-lookup"><span data-stu-id="cdf21-118">Actors in Service Fabric</span></span>
<span data-ttu-id="cdf21-119">V Service Fabric aktéři jsou implementované v rámci Reliable Actors: na základě objektu actor vzor aplikační rozhraní založené na [spolehlivé služby Service Fabric](service-fabric-reliable-services-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="cdf21-119">In Service Fabric, actors are implemented in the Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="cdf21-120">Každý spolehlivé objektu Actor službu, kterou píšete je ve skutečnosti oddílů, stavová spolehlivá služba.</span><span class="sxs-lookup"><span data-stu-id="cdf21-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="cdf21-121">Každý objekt actor je definován jako instanci objektu actor typu identické způsobem, jakým objekt .NET je instance typu .NET.</span><span class="sxs-lookup"><span data-stu-id="cdf21-121">Every actor is defined as an instance of an actor type, identical to the way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="cdf21-122">Například může být typ objektu actor, která implementuje funkce kalkulačky a může být mnoho aktéři daného typu, které jsou rozmístěny v různých uzlech v clusteru.</span><span class="sxs-lookup"><span data-stu-id="cdf21-122">For example, there may be an actor type that implements the functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="cdf21-123">Každé takové objektu actor je jedinečně identifikovaný identifikátor objektu actor.</span><span class="sxs-lookup"><span data-stu-id="cdf21-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="cdf21-124">Doba života objektu actor</span><span class="sxs-lookup"><span data-stu-id="cdf21-124">Actor Lifetime</span></span>
<span data-ttu-id="cdf21-125">Service Fabric aktéři jsou virtuální, což znamená, že své životnosti není vázaný k jejich reprezentaci v paměti.</span><span class="sxs-lookup"><span data-stu-id="cdf21-125">Service Fabric actors are virtual, meaning that their lifetime is not tied to their in-memory representation.</span></span> <span data-ttu-id="cdf21-126">V důsledku toho se nemusíte být explicitně vytvořen nebo zničeno.</span><span class="sxs-lookup"><span data-stu-id="cdf21-126">As a result, they do not need to be explicitly created or destroyed.</span></span> <span data-ttu-id="cdf21-127">Modul runtime Reliable Actors automaticky aktivuje doba objektu actor první obdrží žádost pro ID tohoto objektu actor.</span><span class="sxs-lookup"><span data-stu-id="cdf21-127">The Reliable Actors runtime automatically activates an actor the first time it receives a request for that actor ID.</span></span> <span data-ttu-id="cdf21-128">Pokud objekt actor se nepoužívá pro určitou dobu, modul runtime Reliable Actors uvolňování paměti – shromažďuje objekt v paměti.</span><span class="sxs-lookup"><span data-stu-id="cdf21-128">If an actor is not used for a period of time, the Reliable Actors runtime garbage-collects the in-memory object.</span></span> <span data-ttu-id="cdf21-129">Také zachová znalostní báze objektu actor existence měli později znovu aktivovat.</span><span class="sxs-lookup"><span data-stu-id="cdf21-129">It will also maintain knowledge of the actor's existence should it need to be reactivated later.</span></span> <span data-ttu-id="cdf21-130">Další podrobnosti najdete v tématu [kolekce paměti a životního cyklu objektu Actor](service-fabric-reliable-actors-lifecycle.md).</span><span class="sxs-lookup"><span data-stu-id="cdf21-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="cdf21-131">Tato abstrakce doba života objektu actor virtuální představuje některé upozornění v důsledku virtuální objektu actor modelu a ve skutečnosti implementace Reliable Actors odchylují někdy z tohoto modelu.</span><span class="sxs-lookup"><span data-stu-id="cdf21-131">This virtual actor lifetime abstraction carries some caveats as a result of the virtual actor model, and in fact the Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="cdf21-132">Objekt actor se automaticky aktivuje (což objekt actor tak, aby zkonstruovat) při prvním přijetí zprávy jeho ID objektu actor.</span><span class="sxs-lookup"><span data-stu-id="cdf21-132">An actor is automatically activated (causing an actor object to be constructed) the first time a message is sent to its actor ID.</span></span> <span data-ttu-id="cdf21-133">Po nějaké časové období je objekt actor uvolnění z paměti.</span><span class="sxs-lookup"><span data-stu-id="cdf21-133">After some period of time, the actor object is garbage collected.</span></span> <span data-ttu-id="cdf21-134">V budoucnu znovu pomocí ID objektu actor, způsobí, že objekt nového objektu actor zkonstruovat.</span><span class="sxs-lookup"><span data-stu-id="cdf21-134">In the future, using the actor ID again, causes a new actor object to be constructed.</span></span> <span data-ttu-id="cdf21-135">Stav objektu actor outlives doba života objektu, když uložené v správce stavu.</span><span class="sxs-lookup"><span data-stu-id="cdf21-135">An actor's state outlives the object's lifetime when stored in the state manager.</span></span>
* <span data-ttu-id="cdf21-136">Voláním jakékoli metody objektu actor pro ID objektu actor aktivuje tohoto objektu actor.</span><span class="sxs-lookup"><span data-stu-id="cdf21-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="cdf21-137">Z tohoto důvodu objektu actor typy mají jejich konstruktor volána implicitně modulem runtime.</span><span class="sxs-lookup"><span data-stu-id="cdf21-137">For this reason, actor types have their constructor called implicitly by the runtime.</span></span> <span data-ttu-id="cdf21-138">Kód klienta proto nemůžete předat parametry do konstruktoru objektu actor typu, i když může být předány parametry objektu actor konstruktor samotné služby.</span><span class="sxs-lookup"><span data-stu-id="cdf21-138">Therefore, client code cannot pass parameters to the actor type's constructor, although parameters may be passed to the actor's constructor by the service itself.</span></span> <span data-ttu-id="cdf21-139">Výsledkem je, že aktéři může zkonstruovat ve stavu částečně inicializovat podle času, které se nazývají jiné metody, pokud objektu actor vyžaduje inicializační parametry z klienta.</span><span class="sxs-lookup"><span data-stu-id="cdf21-139">The result is that actors may be constructed in a partially-initialized state by the time other methods are called on it, if the actor requires initialization parameters from the client.</span></span> <span data-ttu-id="cdf21-140">Neexistuje jeden vstupní bod pro aktivaci objektu actor z klienta.</span><span class="sxs-lookup"><span data-stu-id="cdf21-140">There is no single entry point for the activation of an actor from the client.</span></span>
* <span data-ttu-id="cdf21-141">I když Reliable Actors implicitně vytvořit objekty objektu actor; Máte možnost explicitně odstranit objekt actor a její stav.</span><span class="sxs-lookup"><span data-stu-id="cdf21-141">Although Reliable Actors implicitly create actor objects; you do have the ability to explicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="cdf21-142">Distribuce a převzetí služeb při selhání</span><span class="sxs-lookup"><span data-stu-id="cdf21-142">Distribution and failover</span></span>
<span data-ttu-id="cdf21-143">Zajistit škálovatelnost a spolehlivost, Service Fabric distribuuje aktéři v rámci clusteru a automaticky je migraci z selhání uzlů do pořádku ty, které jsou podle potřeby.</span><span class="sxs-lookup"><span data-stu-id="cdf21-143">To provide scalability and reliability, Service Fabric distributes actors throughout the cluster and automatically migrates them from failed nodes to healthy ones as required.</span></span> <span data-ttu-id="cdf21-144">Toto je abstrakci přes [oddílů, stavová služba spolehlivé](service-fabric-concepts-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="cdf21-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="cdf21-145">Distribuce, škálovatelnost, spolehlivost a automatické převzetí služeb při selhání jsou k všechny dispozici základě skutečnost, že aktéři běží ve stavové služby spolehlivé volat *služby objektu Actor*.</span><span class="sxs-lookup"><span data-stu-id="cdf21-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of the fact that actors are running inside a stateful Reliable Service called the *Actor Service*.</span></span>

<span data-ttu-id="cdf21-146">Aktéři jsou distribuovány na oddíly služby objektu Actor a tyto oddíly jsou rozdělené mezi uzly v clusteru Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="cdf21-146">Actors are distributed across the partitions of the Actor Service, and those partitions are distributed across the nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="cdf21-147">Každý oddíl služby obsahuje sadu aktéři.</span><span class="sxs-lookup"><span data-stu-id="cdf21-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="cdf21-148">Service Fabric spravuje distribuce a převzetí služeb při selhání oddílů služby.</span><span class="sxs-lookup"><span data-stu-id="cdf21-148">Service Fabric manages distribution and failover of the service partitions.</span></span>

<span data-ttu-id="cdf21-149">Například služby objektu actor s devět oddíly, které jsou nasazené na tři uzly pomocí výchozí umístění oddílu objektu actor by distribuována thusly:</span><span class="sxs-lookup"><span data-stu-id="cdf21-149">For example, an actor service with nine partitions deployed to three nodes using the default actor partition placement would be distributed thusly:</span></span>

![Spolehlivé aktéři distribuce][2]

<span data-ttu-id="cdf21-151">Rozhraní objektu Actor oddílu schéma a klíč nastavení rozsahu pro vás spravuje.</span><span class="sxs-lookup"><span data-stu-id="cdf21-151">The Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="cdf21-152">Zjednodušuje některé možnosti, ale také představuje některé pozornost:</span><span class="sxs-lookup"><span data-stu-id="cdf21-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="cdf21-153">Spolehlivé služby umožňuje vyberte schéma rozdělení oddílů, klíče rozsah (při použití rozsah dělení schéma) a počet oddílu.</span><span class="sxs-lookup"><span data-stu-id="cdf21-153">Reliable Services allows you to choose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="cdf21-154">Reliable Actors je omezen na rozsah dělení schéma (uniform Int64 schéma) a vyžaduje, že používáte plný rozsah klíče Int64.</span><span class="sxs-lookup"><span data-stu-id="cdf21-154">Reliable Actors is restricted to the range partitioning scheme (the uniform Int64 scheme) and requires you use the full Int64 key range.</span></span>
* <span data-ttu-id="cdf21-155">Ve výchozím nastavení se umístí do oddílů, které jsou výsledkem uniform distribuční náhodně aktéři.</span><span class="sxs-lookup"><span data-stu-id="cdf21-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="cdf21-156">Protože aktéři jsou náhodně umístěn, je třeba očekávat, objektu actor operace budou vždy vyžadovat komunikaci sítě, včetně serializace a deserializace dat volání metody, by docházelo k latenci a zatížení.</span><span class="sxs-lookup"><span data-stu-id="cdf21-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="cdf21-157">V pokročilých scénářích je možné umístění oddílu objektu actor ovládacího prvku pomocí objektu actor Int64 ID, které mapují na konkrétní oddíly.</span><span class="sxs-lookup"><span data-stu-id="cdf21-157">In advanced scenarios, it is possible to control actor partition placement by using Int64 actor IDs that map to specific partitions.</span></span> <span data-ttu-id="cdf21-158">Ale to tak může způsobit jako nevyváženou distribučního aktéři napříč oddíly.</span><span class="sxs-lookup"><span data-stu-id="cdf21-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="cdf21-159">Další informace o tom, jak jsou služby objektu actor do několika oddílů, najdete v části [dělení koncepty pro aktéři](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span><span class="sxs-lookup"><span data-stu-id="cdf21-159">For more information on how actor services are partitioned, refer to [partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="cdf21-160">Komunikace objektu actor</span><span class="sxs-lookup"><span data-stu-id="cdf21-160">Actor communication</span></span>
<span data-ttu-id="cdf21-161">Interakce objektu actor jsou definovány v rozhraní, které sdílí objektu actor, který implementuje rozhraní a klienta, který získá proxy serveru k objektu actor prostřednictvím stejné rozhraní.</span><span class="sxs-lookup"><span data-stu-id="cdf21-161">Actor interactions are defined in an interface that is shared by the actor that implements the interface, and the client that gets a proxy to an actor via the same interface.</span></span> <span data-ttu-id="cdf21-162">Protože toto rozhraní se použije k vyvolání metody objektu actor asynchronně, musí být každý metoda v rozhraní vrácení úloh.</span><span class="sxs-lookup"><span data-stu-id="cdf21-162">Because this interface is used to invoke actor methods asynchronously, every method on the interface must be Task-returning.</span></span>

<span data-ttu-id="cdf21-163">Volání metod a jejich odpovědi konečným výsledkem je síťové požadavky napříč clusterem, takže argumenty a typy výsledků úlohy, které vracejí musejí být serializovatelná platformou.</span><span class="sxs-lookup"><span data-stu-id="cdf21-163">Method invocations and their responses ultimately result in network requests across the cluster, so the arguments and the result types of the tasks that they return must be serializable by the platform.</span></span> <span data-ttu-id="cdf21-164">Konkrétně musí být [kontraktů dat serializovatelný](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="cdf21-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="the-actor-proxy"></a><span data-ttu-id="cdf21-165">Proxy objektu actor</span><span class="sxs-lookup"><span data-stu-id="cdf21-165">The actor proxy</span></span>
<span data-ttu-id="cdf21-166">Klient Reliable Actors rozhraní API poskytuje komunikaci mezi instanci objektu actor a objektu actor klienta.</span><span class="sxs-lookup"><span data-stu-id="cdf21-166">The Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="cdf21-167">Ke komunikaci s objektu actor, klient vytvoří objekt actor proxy, který implementuje rozhraní objektu actor.</span><span class="sxs-lookup"><span data-stu-id="cdf21-167">To communicate with an actor, a client creates an actor proxy object that implements the actor interface.</span></span> <span data-ttu-id="cdf21-168">Klient komunikuje s objektu actor vyvoláním metody pro objekt proxy serveru.</span><span class="sxs-lookup"><span data-stu-id="cdf21-168">The client interacts with the actor by invoking methods on the proxy object.</span></span> <span data-ttu-id="cdf21-169">Proxy objektu actor lze použít pro komunikaci klienta do objektu actor a objektu actor actor.</span><span class="sxs-lookup"><span data-stu-id="cdf21-169">The actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on the actor. If an actor with the given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on the actor. If an actor with the given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="cdf21-170">Upozorňujeme, že jsou dva kusy informace, které slouží k vytvoření objektu actor proxy objektu objekt actor s ID a název aplikace.</span><span class="sxs-lookup"><span data-stu-id="cdf21-170">Note that the two pieces of information used to create the actor proxy object are the actor ID and the application name.</span></span> <span data-ttu-id="cdf21-171">ID objektu actor jednoznačně identifikuje objektu actor, zatímco identifikuje název aplikace [aplikace Service Fabric](service-fabric-reliable-actors-platform.md#application-model) kde je nasazená objektu actor.</span><span class="sxs-lookup"><span data-stu-id="cdf21-171">The actor ID uniquely identifies the actor, while the application name identifies the [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where the actor is deployed.</span></span>

<span data-ttu-id="cdf21-172">`ActorProxy`(C#) nebo `ActorProxyBase`– třída (Java) na straně klienta provádí nezbytné řešení pro vyhledání objektu actor podle ID a otevřete komunikační kanál s ním.</span><span class="sxs-lookup"><span data-stu-id="cdf21-172">The `ActorProxy`(C#) / `ActorProxyBase`(Java) class on the client side performs the necessary resolution to locate the actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="cdf21-173">Také se pokusí najít objektu actor v případě selhání komunikace a převzetí služeb při selhání.</span><span class="sxs-lookup"><span data-stu-id="cdf21-173">It also retries to locate the actor in the cases of communication failures and failovers.</span></span> <span data-ttu-id="cdf21-174">V důsledku toho doručování zpráv má následující vlastnosti:</span><span class="sxs-lookup"><span data-stu-id="cdf21-174">As a result, message delivery has the following characteristics:</span></span>

* <span data-ttu-id="cdf21-175">Doručení zpráv je nejlepší úsilí.</span><span class="sxs-lookup"><span data-stu-id="cdf21-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="cdf21-176">Aktéři může se zobrazit duplicitní zprávy ze stejného klienta.</span><span class="sxs-lookup"><span data-stu-id="cdf21-176">Actors may receive duplicate messages from the same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="cdf21-177">Souběžnost</span><span class="sxs-lookup"><span data-stu-id="cdf21-177">Concurrency</span></span>
<span data-ttu-id="cdf21-178">Modul runtime Reliable Actors poskytuje jednoduché přístupu na základě zapněte model pro přístup k objektu actor metody.</span><span class="sxs-lookup"><span data-stu-id="cdf21-178">The Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="cdf21-179">To znamená, že kdykoli může být aktivní uvnitř objekt actor kód více než jedno vlákno.</span><span class="sxs-lookup"><span data-stu-id="cdf21-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="cdf21-180">Není nutné pro synchronizaci mechanismy pro přístup k datům přístupu na základě zapnout výrazně zjednodušuje souběžných systémy.</span><span class="sxs-lookup"><span data-stu-id="cdf21-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="cdf21-181">Taky to znamená, že systémy musí být vytvořeny s zvláštní upozornění pro jednovláknové přístup povaze každá instance objektu actor.</span><span class="sxs-lookup"><span data-stu-id="cdf21-181">It also means systems must be designed with special considerations for the single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="cdf21-182">Více než jeden požadavek nelze zpracovat instance jednoho objektu actor v čase.</span><span class="sxs-lookup"><span data-stu-id="cdf21-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="cdf21-183">Instance objektu actor může způsobit úzkým místem propustnost, pokud se očekává, zpracování souběžných požadavků.</span><span class="sxs-lookup"><span data-stu-id="cdf21-183">An actor instance can cause a throughput bottleneck if it is expected to handle concurrent requests.</span></span>
* <span data-ttu-id="cdf21-184">Aktéři můžete zablokování na sobě navzájem, pokud je požadavek cyklické mezi dvěma aktéři při externí požadavku na jednu z aktéři současně.</span><span class="sxs-lookup"><span data-stu-id="cdf21-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made to one of the actors simultaneously.</span></span> <span data-ttu-id="cdf21-185">Modul runtime objektu actor automaticky vypršení časového limitu při volání objektu actor a způsobí výjimku volajícího k přerušení situacích možné zablokování.</span><span class="sxs-lookup"><span data-stu-id="cdf21-185">The actor runtime will automatically time out on actor calls and throw an exception to the caller to interrupt possible deadlock situations.</span></span>

![Spolehlivé aktéři komunikace][3]

#### <a name="turn-based-access"></a><span data-ttu-id="cdf21-187">Přístupu na základě zapnout</span><span class="sxs-lookup"><span data-stu-id="cdf21-187">Turn-based access</span></span>
<span data-ttu-id="cdf21-188">Zapněte se skládá z dokončení provádění metody objektu actor v reakci na žádost o jiných klientů nebo aktéři nebo dokončení provádění [časovače nebo připomenutí](service-fabric-reliable-actors-timers-reminders.md) zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="cdf21-188">A turn consists of the complete execution of an actor method in response to a request from other actors or clients, or the complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="cdf21-189">I když jsou tyto metody a zpětná volání asynchronní, modul runtime aktéři není prokládání dat je.</span><span class="sxs-lookup"><span data-stu-id="cdf21-189">Even though these methods and callbacks are asynchronous, the Actors runtime does not interleave them.</span></span> <span data-ttu-id="cdf21-190">Předtím, než je povolený nový zapnout, musí být plně dokončení zapnout.</span><span class="sxs-lookup"><span data-stu-id="cdf21-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="cdf21-191">Jinými slovy musí být plně dokončení před nové volání do metody objektu actor metoda nebo časovače nebo připomenutí zpětné volání, které právě probíhá nebo je povoleno zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="cdf21-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call to a method or callback is allowed.</span></span> <span data-ttu-id="cdf21-192">Metoda nebo zpětné volání se považuje dokončily, pokud provádění vrátila z metody nebo dokončení zpětného volání a úloha vrácená metoda nebo zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="cdf21-192">A method or callback is considered to have finished if the execution has returned from the method or callback and the task returned by the method or callback has finished.</span></span> <span data-ttu-id="cdf21-193">Je vhodné zdůraznění, že na základě zapnout concurrency je dodržena i přes různé metody, časovače a zpětná volání.</span><span class="sxs-lookup"><span data-stu-id="cdf21-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="cdf21-194">Modul runtime aktéři vynucuje na základě zapnout souběžnosti získávání zámku na objektu actor na začátku zapnout a uvolnění uzamčení na konci zapnout.</span><span class="sxs-lookup"><span data-stu-id="cdf21-194">The Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at the beginning of a turn and releasing the lock at the end of the turn.</span></span> <span data-ttu-id="cdf21-195">Na základě zapnout souběžnosti je proto vynucují na základě za objekt actor a není mezi aktéři.</span><span class="sxs-lookup"><span data-stu-id="cdf21-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="cdf21-196">Metody objektu actor a zpětná volání časovače nebo připomenutí můžete spustit současně jménem různých aktéři.</span><span class="sxs-lookup"><span data-stu-id="cdf21-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="cdf21-197">Následující příklad ilustruje výše koncepty.</span><span class="sxs-lookup"><span data-stu-id="cdf21-197">The following example illustrates the above concepts.</span></span> <span data-ttu-id="cdf21-198">Vezměte v úvahu typ objektu actor, který implementuje dvě asynchronní metody (Řekněme, *Method1* a *Method2*), a časovač a připomenutí.</span><span class="sxs-lookup"><span data-stu-id="cdf21-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="cdf21-199">Následující diagram ukazuje příklad časovou osu pro provádění těchto metod a zpětná volání jménem dvě aktéři (*ActorId1* a *ActorId2*), patří do tohoto typu objektu actor.</span><span class="sxs-lookup"><span data-stu-id="cdf21-199">The diagram below shows an example of a timeline for the execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong to this actor type.</span></span>

![Spolehlivé aktéři modul runtime na základě zapnout souběžnosti a přístup][1]

<span data-ttu-id="cdf21-201">Tento diagram dodržovat tyto konvence:</span><span class="sxs-lookup"><span data-stu-id="cdf21-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="cdf21-202">Každé svislé čáry zobrazuje logický tok provádění metody nebo zpětné volání jménem konkrétního objektu actor.</span><span class="sxs-lookup"><span data-stu-id="cdf21-202">Each vertical line shows the logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="cdf21-203">V chronologickém pořadí s novější událostí pod starší dochází k události na každé svislé čáry označit.</span><span class="sxs-lookup"><span data-stu-id="cdf21-203">The events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="cdf21-204">Různé barvy se používají pro odpovídající různých aktéři časové osy.</span><span class="sxs-lookup"><span data-stu-id="cdf21-204">Different colors are used for timelines corresponding to different actors.</span></span>
* <span data-ttu-id="cdf21-205">Zvýraznění je slouží k určení doby trvání, pro který zámek na objektu actor trvá jménem metoda nebo zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="cdf21-205">Highlighting is used to indicate the duration for which the per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="cdf21-206">Některé důležité body vzít v úvahu:</span><span class="sxs-lookup"><span data-stu-id="cdf21-206">Some important points to consider:</span></span>

* <span data-ttu-id="cdf21-207">Při *Method1* provádí jménem *ActorId2* v reakci na žádost klienta *xyz789*, další požadavek klienta (*abc123*) dorazí, který taky vyžaduje *Method1* být vykonán *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="cdf21-207">While *Method1* is executing on behalf of *ActorId2* in response to client request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* to be executed by *ActorId2*.</span></span> <span data-ttu-id="cdf21-208">Ale druhý provádění *Method1* nemá na začátku až do dokončení předchozí provádění.</span><span class="sxs-lookup"><span data-stu-id="cdf21-208">However, the second execution of *Method1* does not begin until the prior execution has finished.</span></span> <span data-ttu-id="cdf21-209">Podobně, zobrazí se připomenutí registrovaných *ActorId2* aktivuje se při *Method1* je spouštěna v reakci na žádost klienta *xyz789*.</span><span class="sxs-lookup"><span data-stu-id="cdf21-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response to client request *xyz789*.</span></span> <span data-ttu-id="cdf21-210">Zpětné volání připomenutí se spustí až po obou spuštěních z *Method1* jsou dokončeny.</span><span class="sxs-lookup"><span data-stu-id="cdf21-210">The reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="cdf21-211">Všechny tyto je z důvodu souběžnosti na základě zapnout vynucení pro *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="cdf21-211">All of this is due to turn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="cdf21-212">Podobně se na základě zapnout souběžnosti také vynucuje pro *ActorId1*, jak je znázorněno pomocí provádění *Method1*, *Method2*a zpětné volání časovače jménem  *ActorId1* děje sériové způsobem.</span><span class="sxs-lookup"><span data-stu-id="cdf21-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by the execution of *Method1*, *Method2*, and the timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="cdf21-213">Provádění *Method1* jménem *ActorId1* se překrývá s jeho spuštění jménem *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="cdf21-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="cdf21-214">Je to proto, že na základě zapnout concurrency se vynucuje jenom v rámci objektu actor a není napříč aktéři.</span><span class="sxs-lookup"><span data-stu-id="cdf21-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="cdf21-215">V některých spuštěních metoda/zpětného volání `Task`(C#) nebo `CompletableFuture`(Java) vrácený dokončení metoda/zpětného volání po vrátí metoda.</span><span class="sxs-lookup"><span data-stu-id="cdf21-215">In some of the method/callback executions, the `Task`(C#) / `CompletableFuture`(Java) returned by the method/callback finishes after the method returns.</span></span> <span data-ttu-id="cdf21-216">V některých jiných asynchronní operace již byla dokončena o dobu, kterou vrátí metoda zpětného volání.</span><span class="sxs-lookup"><span data-stu-id="cdf21-216">In some others, the asynchronous operation has already finished by the time the method/callback returns.</span></span> <span data-ttu-id="cdf21-217">V obou případech zámek na objektu actor vydání až po, vrátí metoda zpětného volání i dokončení asynchronní operace.</span><span class="sxs-lookup"><span data-stu-id="cdf21-217">In both cases, the per-actor lock is released only after both the method/callback returns and the asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="cdf21-218">Vícenásobný přístup</span><span class="sxs-lookup"><span data-stu-id="cdf21-218">Reentrancy</span></span>
<span data-ttu-id="cdf21-219">Modul runtime aktéři umožňuje vícenásobný přístup ve výchozím nastavení.</span><span class="sxs-lookup"><span data-stu-id="cdf21-219">The Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="cdf21-220">To znamená, že pokud metoda objektu actor *objektu Actor A* volá metodu na *objektu Actor B*, která volá jinou metodu na *objektu Actor A*, že je metoda může spustit.</span><span class="sxs-lookup"><span data-stu-id="cdf21-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed to run.</span></span> <span data-ttu-id="cdf21-221">Je to proto, že je součástí stejného logického řetězce volání kontextu.</span><span class="sxs-lookup"><span data-stu-id="cdf21-221">This is because it is part of the same logical call-chain context.</span></span> <span data-ttu-id="cdf21-222">Všechna volání časovače a připomenutí začínat nový kontext logické volání.</span><span class="sxs-lookup"><span data-stu-id="cdf21-222">All timer and reminder calls start with the new logical call context.</span></span> <span data-ttu-id="cdf21-223">Najdete v článku [vícenásobný přístup Reliable Actors](service-fabric-reliable-actors-reentrancy.md) další podrobnosti.</span><span class="sxs-lookup"><span data-stu-id="cdf21-223">See the [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="cdf21-224">Rozsah záruky souběžnosti</span><span class="sxs-lookup"><span data-stu-id="cdf21-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="cdf21-225">Modul runtime aktéři poskytuje tyto záruky souběžnosti v situacích, kde se řídí volání z těchto metod.</span><span class="sxs-lookup"><span data-stu-id="cdf21-225">The Actors runtime provides these concurrency guarantees in situations where it controls the invocation of these methods.</span></span> <span data-ttu-id="cdf21-226">Například poskytuje tyto záruky pro volání metod, které se provádějí v odpovědi na požadavek klienta, a také pro zpětné volání časovače a připomenutí.</span><span class="sxs-lookup"><span data-stu-id="cdf21-226">For example, it provides these guarantees for the method invocations that are done in response to a client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="cdf21-227">Ale pokud kód objektu actor přímo vyvolá tyto metody mimo mechanismy, které poskytuje modulem runtime aktéři, modul runtime nelze zadejte jakékoli záruky souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="cdf21-227">However, if the actor code directly invokes these methods outside of the mechanisms provided by the Actors runtime, then the runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="cdf21-228">Například pokud metoda je volána v rámci některých úloh, který není spojen s Úloha vrácená metody objektu actor, modul runtime nelze zadejte souběžnosti záruky.</span><span class="sxs-lookup"><span data-stu-id="cdf21-228">For example, if the method is invoked in the context of some task that is not associated with the task returned by the actor methods, then the runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="cdf21-229">Pokud je metoda je vyvolána z vlákna, která objektu actor vytvoří sama o sobě, modul runtime nelze zadejte také souběžnosti záruky.</span><span class="sxs-lookup"><span data-stu-id="cdf21-229">If the method is invoked from a thread that the actor creates on its own, then the runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="cdf21-230">Proto k provedení operace na pozadí, měli používat aktéři [objektu actor časovače a upomínek objektu actor](service-fabric-reliable-actors-timers-reminders.md) , respektují na základě zapnout souběžnosti.</span><span class="sxs-lookup"><span data-stu-id="cdf21-230">Therefore, to perform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="cdf21-231">Další kroky</span><span class="sxs-lookup"><span data-stu-id="cdf21-231">Next steps</span></span>
* <span data-ttu-id="cdf21-232">Začínáme se ve vaší první službě Reliable Actors:</span><span class="sxs-lookup"><span data-stu-id="cdf21-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="cdf21-233">Začínáme s Reliable Actors na rozhraní .NET</span><span class="sxs-lookup"><span data-stu-id="cdf21-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="cdf21-234">Začínáme s Reliable Actors v jazyce Java</span><span class="sxs-lookup"><span data-stu-id="cdf21-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
