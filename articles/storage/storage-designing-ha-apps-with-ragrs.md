---
title: "Navrhování vysoce dostupné aplikace pomocí Azure přístup pro čtení geograficky redundantní úložiště (RA-GRS) | Microsoft Docs"
description: "Jak používat Azure RA-GRS úložiště do architektury vysokou dostupností aplikace dostatečně flexibilní, aby zpracování výpadků."
services: storage
documentationcenter: .net
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 8f040b0f-8926-4831-ac07-79f646f31926
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 1/19/2017
ms.author: robinsh
ms.openlocfilehash: adc7e23d8c9f869f2951490020e3d0f1a2b2e81c
ms.sourcegitcommit: 02e69c4a9d17645633357fe3d46677c2ff22c85a
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/03/2017
---
# <a name="designing-highly-available-applications-using-ra-grs"></a><span data-ttu-id="a848c-103">Navrhování pomocí RA-GRS vysoce dostupných aplikací.</span><span class="sxs-lookup"><span data-stu-id="a848c-103">Designing Highly Available Applications using RA-GRS</span></span>

<span data-ttu-id="a848c-104">Běžné funkce cloudové infrastruktury je poskytují vysokou dostupností platformu pro hostování aplikací.</span><span class="sxs-lookup"><span data-stu-id="a848c-104">A common feature of cloud-based infrastructures is that they provide a highly available platform for hosting applications.</span></span> <span data-ttu-id="a848c-105">Vývojáři cloudové aplikace musíte pečlivě zvažte, jak využít této platformě, aby poskytovat vysoce dostupné aplikace uživatelům.</span><span class="sxs-lookup"><span data-stu-id="a848c-105">Developers of cloud-based applications must consider carefully how to leverage this platform to deliver highly available applications to their users.</span></span> <span data-ttu-id="a848c-106">Tento článek zaměřuje konkrétně na tom, jak mohou vývojáři Azure úložiště přístup pro čtení geograficky redundantní úložiště (RA-GRS) zpřístupnit svých aplikací.</span><span class="sxs-lookup"><span data-stu-id="a848c-106">This article focuses specifically on how developers can use the Azure Storage Read Access Geo Redundant Storage (RA-GRS) to make their applications more available.</span></span>

<span data-ttu-id="a848c-107">Existují čtyři možnosti pro redundanci – LRS (Locally Redundant Storage), ZRS (zóny redundantní úložiště), (Geo-Redundant Storage) GRS a RA-GRS (Geo-Redundant Storage přístup pro čtení).</span><span class="sxs-lookup"><span data-stu-id="a848c-107">There are four choices for redundancy – LRS (Locally Redundant Storage), ZRS (Zone Redundant Storage), GRS (Geo-Redundant Storage), and RA-GRS (Read Access Geo-Redundant Storage).</span></span> <span data-ttu-id="a848c-108">Budeme zabývat GRS a RA-GRS v tomto článku.</span><span class="sxs-lookup"><span data-stu-id="a848c-108">We are going to discuss GRS and RA-GRS in this article.</span></span> <span data-ttu-id="a848c-109">S GRS udržovaly tři kopie dat v primární oblast, kterou jste vybrali při nastavování účtu úložiště.</span><span class="sxs-lookup"><span data-stu-id="a848c-109">With GRS, three copies of your data are kept in the primary region you selected when setting up the storage account.</span></span> <span data-ttu-id="a848c-110">Tři další kopie je udržováno asynchronně v sekundární oblasti definované v Azure.</span><span class="sxs-lookup"><span data-stu-id="a848c-110">Three additional copies are maintained asynchronously in a secondary region specified by Azure.</span></span> <span data-ttu-id="a848c-111">RA-GRS je totéž jako GRS, s tím rozdílem, že máte přístup pro čtení k sekundární kopie.</span><span class="sxs-lookup"><span data-stu-id="a848c-111">RA-GRS is the same thing as GRS except that you have read access to the secondary copy.</span></span> <span data-ttu-id="a848c-112">Další informace o různých možnostech redundance úložiště Azure najdete v tématu [replikace Azure Storage](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy).</span><span class="sxs-lookup"><span data-stu-id="a848c-112">For more information about the different Azure Storage redundancy options, see [Azure Storage replication](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy).</span></span> <span data-ttu-id="a848c-113">Replikace článek také ukazuje dvojice primární a sekundární oblasti.</span><span class="sxs-lookup"><span data-stu-id="a848c-113">The replication article also shows the pairings of the primary and secondary regions.</span></span>

<span data-ttu-id="a848c-114">Existují fragmenty kódu, které jsou zahrnuté v tomto článku a odkaz na ucelenou ukázku na konci, kterou můžete stáhnout a spustit.</span><span class="sxs-lookup"><span data-stu-id="a848c-114">There are code snippets included in this article, and a link to a complete sample at the end that you can download and run.</span></span>

## <a name="key-features-of-ra-grs"></a><span data-ttu-id="a848c-115">Klíčové funkce RA-GRS</span><span class="sxs-lookup"><span data-stu-id="a848c-115">Key features of RA-GRS</span></span>

<span data-ttu-id="a848c-116">Než budeme mluvit o tom, jak používat úložiště RA-GRS, budeme mluvit o svých vlastnostech a chování.</span><span class="sxs-lookup"><span data-stu-id="a848c-116">Before we talk about how to use RA-GRS storage, let's talk about its properties and behavior.</span></span>

* <span data-ttu-id="a848c-117">Úložiště Azure udržuje kopii dat, které ukládáte ve vaší primární oblasti v sekundární oblasti; jen pro čtení Jak jsme uvedli výše, službu úložiště určuje umístění sekundární oblast.</span><span class="sxs-lookup"><span data-stu-id="a848c-117">Azure Storage maintains a read-only copy of the data you store in your primary region in a secondary region; as noted above, the storage service determines the location of the secondary region.</span></span>

* <span data-ttu-id="a848c-118">Kopie jen pro čtení je [nakonec byl konzistentní](https://en.wikipedia.org/wiki/Eventual_consistency) s daty v primární oblasti.</span><span class="sxs-lookup"><span data-stu-id="a848c-118">The read-only copy is [eventually consistent](https://en.wikipedia.org/wiki/Eventual_consistency) with the data in the primary region.</span></span>

* <span data-ttu-id="a848c-119">Pro objekty BLOB, tabulek a front, můžete dát dotaz na sekundární oblast pro *čas poslední synchronizace* hodnotu, která oznamuje, kdy došlo k chybě poslední replikace z primárního na sekundární oblast.</span><span class="sxs-lookup"><span data-stu-id="a848c-119">For blobs, tables, and queues, you can query the secondary region for a *Last Sync Time* value that tells you when the last replication from the primary to the secondary region occurred.</span></span> <span data-ttu-id="a848c-120">(To není podporováno pro úložiště Azure File, které nemá RA-GRS redundance v tuto chvíli).</span><span class="sxs-lookup"><span data-stu-id="a848c-120">(This is not supported for Azure File storage, which doesn't have RA-GRS redundancy at this time.)</span></span>

* <span data-ttu-id="a848c-121">Klientská knihovna pro úložiště můžete použít k interakci s daty v primární nebo sekundární oblast.</span><span class="sxs-lookup"><span data-stu-id="a848c-121">You can use the Storage Client Library to interact with the data in either the primary or secondary region.</span></span> <span data-ttu-id="a848c-122">Taky můžete přesměrovat číst požadavky automaticky sekundární oblast, když požadavek čtení primární oblasti časový limit.</span><span class="sxs-lookup"><span data-stu-id="a848c-122">You can also redirect read requests automatically to the secondary region if a read request to the primary region times out.</span></span>

* <span data-ttu-id="a848c-123">Pokud je hlavní problém ovlivňující usnadnění dat v primární oblasti, tým Azure mohou aktivovat geo-převzetí služeb při selhání, v tomto okamžiku se změní položky DNS odkazující na primární oblasti tak, aby odkazoval na sekundární oblast.</span><span class="sxs-lookup"><span data-stu-id="a848c-123">If there is a major issue affecting the accessibility of the data in the primary region, the Azure team may trigger a geo-failover, at which point the DNS entries pointing to the primary region will be changed to point to the secondary region.</span></span>

* <span data-ttu-id="a848c-124">Pokud dojde k selhání geograficky, Azure bude vyberte nové sekundární umístění a replikovat data do tohoto umístění a potom přejděte sekundární položky DNS.</span><span class="sxs-lookup"><span data-stu-id="a848c-124">If a geo-failover occurs, Azure will select a new secondary location and replicate the data to that location, then point the secondary DNS entries to it.</span></span> <span data-ttu-id="a848c-125">Sekundární koncový bod nebude k dispozici, dokud nedokončí účet úložiště, replikaci.</span><span class="sxs-lookup"><span data-stu-id="a848c-125">The secondary endpoint will be unavailable until the storage account has finished replicating.</span></span> <span data-ttu-id="a848c-126">Další informace najdete v tématu [co dělat, když dojde k výpadku Azure Storage](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance).</span><span class="sxs-lookup"><span data-stu-id="a848c-126">For more information, please see [What to do if an Azure Storage outage occurs](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance).</span></span>

## <a name="application-design-considerations-when-using-ra-grs"></a><span data-ttu-id="a848c-127">Aspekty návrhu aplikace při používání RA-GRS</span><span class="sxs-lookup"><span data-stu-id="a848c-127">Application design considerations when using RA-GRS</span></span>

<span data-ttu-id="a848c-128">Hlavním účelem tohoto článku je návod, jak k návrhu aplikace, která budou nadále fungovat (i když v omezené kapacitou) i v případě významnější havárie v primárním datovém centru.</span><span class="sxs-lookup"><span data-stu-id="a848c-128">The main purpose of this article is to show you how to design an application that will continue to function (albeit in a limited capacity) even in the event of a major disaster at the primary data center.</span></span> <span data-ttu-id="a848c-129">To uděláte tak, že vaše aplikace pro zpracování přechodný nebo dlouhotrvající problémy přepínání číst ze sekundární oblasti, zatímco došlo k potížím a přepněte zpět v případě, že primární oblasti opět k dispozici.</span><span class="sxs-lookup"><span data-stu-id="a848c-129">You do this by having your application to handle transient or long-running issues by switching to read from the secondary region while there is a problem, and switching back when the primary region is available again.</span></span>

### <a name="using-eventually-consistent-data"></a><span data-ttu-id="a848c-130">Pomocí nakonec byl konzistentní dat</span><span class="sxs-lookup"><span data-stu-id="a848c-130">Using eventually consistent data</span></span>

<span data-ttu-id="a848c-131">Toto navrhované řešení předpokládá, že je přijatelné vrácení, co může být zastaralá data do aplikace volání.</span><span class="sxs-lookup"><span data-stu-id="a848c-131">This proposed solution assumes that it is okay to return what could be stale data to the calling application.</span></span> <span data-ttu-id="a848c-132">Protože se nakonec byl konzistentní sekundární data, je možné, že data byla zapsána na primární, ale aktualizace sekundární kdyby dokončení replikace při primární oblasti jsou nedostupné.</span><span class="sxs-lookup"><span data-stu-id="a848c-132">Because the secondary data is eventually consistent, it is possible that the data was written to the primary but the update to the secondary had not finished replicating when the primary region became inaccessible.</span></span>

<span data-ttu-id="a848c-133">Například zákazník může odeslat aktualizaci, která je úspěšné, a potom může primární přejděte před aktualizace rozšířena do sekundární.</span><span class="sxs-lookup"><span data-stu-id="a848c-133">For example, your customer could submit an update that is successful, and then the primary could go down before the update is propagated to the secondary.</span></span> <span data-ttu-id="a848c-134">V takovém případě Pokud zákazník následně požádá číst data zpět, dostane zastaralá data místo aktualizovaná data.</span><span class="sxs-lookup"><span data-stu-id="a848c-134">In this case, if the customer then asks to read the data back, he receives the stale data instead of the updated data.</span></span> <span data-ttu-id="a848c-135">Pokud to je přijatelné a pokud ano, musíte rozhodnout, jak se zprávy zákazníka.</span><span class="sxs-lookup"><span data-stu-id="a848c-135">You must decide if this is acceptable, and if so, how you will message the customer.</span></span> <span data-ttu-id="a848c-136">Uvidíte, jak zkontrolovat poslední čas synchronizace na sekundární data později v tomto článku jestli sekundární je aktuální.</span><span class="sxs-lookup"><span data-stu-id="a848c-136">You'll see how to check the Last Sync Time on the secondary data later in this article to see if the secondary is up-to-date.</span></span>

### <a name="handling-services-separately-or-all-together"></a><span data-ttu-id="a848c-137">Zpracování služby samostatně nebo společně všechny</span><span class="sxs-lookup"><span data-stu-id="a848c-137">Handling services separately or all together</span></span>

<span data-ttu-id="a848c-138">Když není pravděpodobné, je možné jeden služby k dispozici, zatímco ostatní služby jsou stále plně funkční.</span><span class="sxs-lookup"><span data-stu-id="a848c-138">While not likely, it is possible for one service to become unavailable while the other services are still fully functional.</span></span> <span data-ttu-id="a848c-139">Dokáže zpracovat opakování a režimu jen pro čtení pro jednotlivé služby samostatně (objekty BLOB, fronty, tabulky), nebo může zpracovat opakování obecně pro všechny služby úložiště společně.</span><span class="sxs-lookup"><span data-stu-id="a848c-139">You can handle the retries and read-only mode for each service separately (blobs, queues, tables), or you can handle retries generically for all the storage services together.</span></span>

<span data-ttu-id="a848c-140">Pokud používáte fronty a objekty BLOB ve vaší aplikaci, můžete rozhodnout umístit do samostatného kódu pro zpracování opakovatelné chyby pro každou z nich.</span><span class="sxs-lookup"><span data-stu-id="a848c-140">For example, if you use queues and blobs in your application, you may decide to put in separate code to handle retryable errors for each of these.</span></span> <span data-ttu-id="a848c-141">Pak pokud získáte od služby objektů blob zkuste to znovu, ale stále funguje služba fronty, bude ovlivněn jenom část aplikace, který zpracovává objekty BLOB.</span><span class="sxs-lookup"><span data-stu-id="a848c-141">Then if you get a retry from the blob service, but the queue service is still working, only the part of your application that handles blobs will be impacted.</span></span> <span data-ttu-id="a848c-142">Pokud se rozhodnete obecně zpracovat všechny opakování služby úložiště a vrátí Opakovatelná chyba volání služby objektů blob, bude mít vliv žádosti o služby objektů blob a fronty služby.</span><span class="sxs-lookup"><span data-stu-id="a848c-142">If you decide to handle all storage service retries generically and a call to the blob service returns a retryable error, then requests to both the blob service and the queue service will be impacted.</span></span>

<span data-ttu-id="a848c-143">Nakonec to závisí na složitosti vaší aplikace.</span><span class="sxs-lookup"><span data-stu-id="a848c-143">Ultimately, this depends on the complexity of your application.</span></span> <span data-ttu-id="a848c-144">Můžete rozhodnout není pro zpracování chyby službou, ale místo pro přesměrování požadavků pro všechny úložiště služby sekundární oblast na čtení a spuštění aplikace v režimu jen pro čtení, když jste k problému s jakoukoli službu, úložiště v primární oblasti.</span><span class="sxs-lookup"><span data-stu-id="a848c-144">You may decide not to handle the failures by service, but instead to redirect read requests for all storage services to the secondary region and run the application in read-only mode when you detect a problem with any storage service in the primary region.</span></span>

### <a name="other-considerations"></a><span data-ttu-id="a848c-145">Další důležité informace</span><span class="sxs-lookup"><span data-stu-id="a848c-145">Other considerations</span></span>

<span data-ttu-id="a848c-146">Jedná se o dalších hledisek, které se budeme zabývat ve zbývající části tohoto článku.</span><span class="sxs-lookup"><span data-stu-id="a848c-146">These are the other considerations we will discuss in the rest of this article.</span></span>

*   <span data-ttu-id="a848c-147">Zpracování opakování požadavků na čtení pomocí vzoru jistič</span><span class="sxs-lookup"><span data-stu-id="a848c-147">Handling retries of read requests using the Circuit Breaker pattern</span></span>

*   <span data-ttu-id="a848c-148">Nakonec konzistentní data a čas poslední synchronizace</span><span class="sxs-lookup"><span data-stu-id="a848c-148">Eventually-consistent data and the Last Sync Time</span></span>

*   <span data-ttu-id="a848c-149">Testování</span><span class="sxs-lookup"><span data-stu-id="a848c-149">Testing</span></span>

## <a name="running-your-application-in-read-only-mode"></a><span data-ttu-id="a848c-150">Spuštění aplikace v režimu jen pro čtení</span><span class="sxs-lookup"><span data-stu-id="a848c-150">Running your application in read-only mode</span></span>

<span data-ttu-id="a848c-151">Používání úložiště RA-GRS, musí být schopna zpracovávat i neúspěšné požadavky na čtení a neúspěšné požadavky aktualizace (s aktualizací v tomto případě znamená vložení, aktualizace a odstranění).</span><span class="sxs-lookup"><span data-stu-id="a848c-151">To use RA-GRS storage, you must be able to handle both failed read requests and failed update requests (with update in this case meaning inserts, updates, and deletions).</span></span> <span data-ttu-id="a848c-152">Pokud primární datového centra softwaru selže, čtení požadavky můžete přesměrovat do sekundárního datového centra, ale nelze žádosti o aktualizaci, protože sekundární je jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="a848c-152">If the primary data center fails, read requests can be redirected to the secondary data center, but update requests cannot because the secondary is read only.</span></span> <span data-ttu-id="a848c-153">Z tohoto důvodu musíte některé způsob, jak aplikaci spustit v režimu jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="a848c-153">For this reason, you need some way to run your application in read-only mode.</span></span>

<span data-ttu-id="a848c-154">Například můžete nastavit příznak, který bude ověřen před odesláním všechny žádosti o aktualizaci služby úložiště.</span><span class="sxs-lookup"><span data-stu-id="a848c-154">For example, you can set a flag that will be checked before submitting any update requests to the storage service.</span></span> <span data-ttu-id="a848c-155">Pokud jeden z žádosti o aktualizaci se zobrazí výzva, můžete vynechat a vrátí odpověď odpovídající zákazníka.</span><span class="sxs-lookup"><span data-stu-id="a848c-155">When one of the update requests comes through, you can skip it and return an appropriate response to the customer.</span></span> <span data-ttu-id="a848c-156">Můžete chtít i zakázat některé funkce úplně, dokud nebude problém vyřešen a upozorněte uživatele, že tyto funkce jsou dočasně nedostupné.</span><span class="sxs-lookup"><span data-stu-id="a848c-156">You may even want to disable certain features altogether until the problem is resolved and notify users that those features are temporarily unavailable.</span></span>

<span data-ttu-id="a848c-157">Pokud se rozhodnete samostatně zpracování chyb pro každou službu, musíte se také pro zpracování možnost aplikaci spustit v režimu jen pro čtení službou.</span><span class="sxs-lookup"><span data-stu-id="a848c-157">If you decide to handle errors for each service separately, you will also need to handle the ability to run your application in read-only mode by service.</span></span> <span data-ttu-id="a848c-158">Můžete mít jen pro čtení příznaky pro každou službu, která lze povolit a zakázat a zpracování odpovídající příznak na příslušná místa v kódu.</span><span class="sxs-lookup"><span data-stu-id="a848c-158">You could have read-only flags for each service that can be enabled and disabled and handle the appropriate flag in the appropriate places in your code.</span></span>

<span data-ttu-id="a848c-159">Bude možné aplikaci spustit v režimu jen pro čtení má další výhody straně – získáte možnost zajistit omezenou funkčnost během upgradu hlavní aplikace.</span><span class="sxs-lookup"><span data-stu-id="a848c-159">Being able to run your application in read-only mode has another side benefit – it gives you the ability to ensure limited functionality during a major application upgrade.</span></span> <span data-ttu-id="a848c-160">Můžete aktivovat aplikaci spustit v režimu jen pro čtení a přejděte na sekundární datové středisko, o zajištění, že když děláte upgrady, je nikdo přístup k datům v primární oblasti.</span><span class="sxs-lookup"><span data-stu-id="a848c-160">You can trigger your application to run in read-only mode and point to the secondary data center, ensuring nobody is accessing the data in the primary region while you're making upgrades.</span></span>

## <a name="handling-updates-when-running-in-read-only-mode"></a><span data-ttu-id="a848c-161">Zpracování aktualizací při spuštění v režimu jen pro čtení</span><span class="sxs-lookup"><span data-stu-id="a848c-161">Handling updates when running in read-only mode</span></span>

<span data-ttu-id="a848c-162">Existuje mnoho způsobů pro zpracování žádosti o aktualizaci při spuštění v režimu jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="a848c-162">There are many ways to handle update requests when running in read-only mode.</span></span> <span data-ttu-id="a848c-163">To jsme nebude komplexně pokrývat, ale obecně platí, existuje několik vzorů, které považujete za.</span><span class="sxs-lookup"><span data-stu-id="a848c-163">We won't cover this comprehensively, but generally, there are a couple of patterns that you consider.</span></span>

1.  <span data-ttu-id="a848c-164">Můžete reagovat na uživatele a sdělte jim, že nejsou aktuálně přijímat aktualizace.</span><span class="sxs-lookup"><span data-stu-id="a848c-164">You can respond to your user and tell them you are not currently accepting updates.</span></span> <span data-ttu-id="a848c-165">Například může systém kontaktní správy umožňují zákazníkům získat přístup k informacím, ale nikoli aktualizace.</span><span class="sxs-lookup"><span data-stu-id="a848c-165">For example, a contact management system could enable customers to access contact information but not make updates.</span></span>

2.  <span data-ttu-id="a848c-166">Můžete zařadit vaše aktualizace v jiné oblasti.</span><span class="sxs-lookup"><span data-stu-id="a848c-166">You can enqueue your updates in another region.</span></span> <span data-ttu-id="a848c-167">V takovém případě by vaše čekání na aktualizaci požadavků na zápis do fronty v jiné oblasti a pak mít možnost zpracování těchto žádostí po primární datové centrum bude znovu online.</span><span class="sxs-lookup"><span data-stu-id="a848c-167">In this case, you would write your pending update requests to a queue in a different region, and then have a way to process those requests after the primary data center comes online again.</span></span> <span data-ttu-id="a848c-168">V tomto scénáři by měl necháte zákazník vědět, že požadovaná aktualizace ve frontě pro pozdější zpracování.</span><span class="sxs-lookup"><span data-stu-id="a848c-168">In this scenario, you should let the customer know that the update requested is queued for later processing.</span></span>

3.  <span data-ttu-id="a848c-169">Vaše aktualizace může zapisovat do účtu úložiště v jiné oblasti.</span><span class="sxs-lookup"><span data-stu-id="a848c-169">You can write your updates to a storage account in another region.</span></span> <span data-ttu-id="a848c-170">Pak když primární datové centrum přejde do režimu online, můžete mít způsob, jak do primární dat, v závislosti na strukturu dat sloučit tyto aktualizace.</span><span class="sxs-lookup"><span data-stu-id="a848c-170">Then when the primary data center comes back online, you can have a way to merge those updates into the primary data, depending on the structure of the data.</span></span> <span data-ttu-id="a848c-171">Například pokud vytvoříte samostatné soubory pomocí razítka data a času v názvu, můžete zkopírovat tyto soubory zpět na primární oblasti.</span><span class="sxs-lookup"><span data-stu-id="a848c-171">For example, if you are creating separate files with a date/time stamp in the name, you can copy those files back to the primary region.</span></span> <span data-ttu-id="a848c-172">Tento postup funguje pro některé úlohy, jako jsou data protokolování a iOT.</span><span class="sxs-lookup"><span data-stu-id="a848c-172">This works for some workloads such as logging and iOT data.</span></span>

## <a name="handling-retries"></a><span data-ttu-id="a848c-173">Zpracování opakování</span><span class="sxs-lookup"><span data-stu-id="a848c-173">Handling retries</span></span>

<span data-ttu-id="a848c-174">Jak budete vědět, které chyby se opakovatelná?</span><span class="sxs-lookup"><span data-stu-id="a848c-174">How do you know which errors are retryable?</span></span> <span data-ttu-id="a848c-175">To je dáno Klientská knihovna pro úložiště.</span><span class="sxs-lookup"><span data-stu-id="a848c-175">This is determined by the storage client library.</span></span> <span data-ttu-id="a848c-176">Například chybu 404 (prostředek nebyl nalezen) není opakovatelná, protože ho opakování není mohlo vést úspěch.</span><span class="sxs-lookup"><span data-stu-id="a848c-176">For example, a 404 error (resource not found) is not retryable because retrying it is not likely to result in success.</span></span> <span data-ttu-id="a848c-177">Na druhé straně je opakovatelné 500 Chyba, protože je k serverové chybě a může být přechodný problém.</span><span class="sxs-lookup"><span data-stu-id="a848c-177">On the other hand, a 500 error is retryable because it is a server error, and it may simply be a transient issue.</span></span> <span data-ttu-id="a848c-178">Další podrobnosti, projděte si [otevřete zdrojového kódu pro třídu ExponentialRetry](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) v klientské knihovny .NET úložiště.</span><span class="sxs-lookup"><span data-stu-id="a848c-178">For more details, check out the [open source code for the ExponentialRetry class](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) in the .NET storage client library.</span></span> <span data-ttu-id="a848c-179">(Podívejte se na metodu ShouldRetry.)</span><span class="sxs-lookup"><span data-stu-id="a848c-179">(Look for the ShouldRetry method.)</span></span>

### <a name="read-requests"></a><span data-ttu-id="a848c-180">Požadavky pro čtení</span><span class="sxs-lookup"><span data-stu-id="a848c-180">Read requests</span></span>

<span data-ttu-id="a848c-181">Čtení požadavky můžete přesměrovat do sekundárního úložiště, pokud dojde k problému s primární úložiště.</span><span class="sxs-lookup"><span data-stu-id="a848c-181">Read requests can be redirected to secondary storage if there is a problem with primary storage.</span></span> <span data-ttu-id="a848c-182">Uvedené výše v [pomocí nakonec konzistentních dat](#using-eventually-consistent-data), musí být přijatelné pro vaši aplikaci potenciálně číst zastaralá data.</span><span class="sxs-lookup"><span data-stu-id="a848c-182">As noted above in [Using Eventually Consistent Data](#using-eventually-consistent-data), it must be acceptable for your application to potentially read stale data.</span></span> <span data-ttu-id="a848c-183">Pokud používáte Klientská knihovna pro úložiště pro přístup k datům RA-GRS, můžete zadat chování opakovat požadavek čtení nastavením hodnoty pro **LocationMode** vlastnost na jednu z následujících akcí:</span><span class="sxs-lookup"><span data-stu-id="a848c-183">If you are using the storage client library to access RA-GRS data, you can specify the retry behavior of a read request by setting a value for the **LocationMode** property to one of the following:</span></span>

*   <span data-ttu-id="a848c-184">**PrimaryOnly** (výchozí)</span><span class="sxs-lookup"><span data-stu-id="a848c-184">**PrimaryOnly** (the default)</span></span>

*   <span data-ttu-id="a848c-185">**PrimaryThenSecondary**</span><span class="sxs-lookup"><span data-stu-id="a848c-185">**PrimaryThenSecondary**</span></span>

*   <span data-ttu-id="a848c-186">**SecondaryOnly**</span><span class="sxs-lookup"><span data-stu-id="a848c-186">**SecondaryOnly**</span></span>

*   <span data-ttu-id="a848c-187">**SecondaryThenPrimary**</span><span class="sxs-lookup"><span data-stu-id="a848c-187">**SecondaryThenPrimary**</span></span>

<span data-ttu-id="a848c-188">Když nastavíte **LocationMode** k **PrimaryThenSecondary**, pokud požadavek na počáteční čtení k selže primární koncový bod s opakovatelnou chybou, klient automaticky provede jiný požadavků na čtení sekundární koncový bod.</span><span class="sxs-lookup"><span data-stu-id="a848c-188">When you set the **LocationMode** to **PrimaryThenSecondary**, if the initial read request to the primary endpoint fails with a retryable error, the client automatically makes another read request to the secondary endpoint.</span></span> <span data-ttu-id="a848c-189">Pokud je chyba vypršení časového limitu serveru, bude mít klient čekání na časový limit vyprší před obdrží Opakovatelná chyba ze služby.</span><span class="sxs-lookup"><span data-stu-id="a848c-189">If the error is a server timeout, then the client will have to wait for the timeout to expire before it receives a retryable error from the service.</span></span>

<span data-ttu-id="a848c-190">V podstatě existují dva scénáře vzít v úvahu při rozhodování jak reagovat na Opakovatelná chyba:</span><span class="sxs-lookup"><span data-stu-id="a848c-190">There are basically two scenarios to consider when you are deciding how to respond to a retryable error:</span></span>

*   <span data-ttu-id="a848c-191">Toto je problém s izolované a další požadavky na primární koncový bod nebude vracet Opakovatelná chyba.</span><span class="sxs-lookup"><span data-stu-id="a848c-191">This is an isolated problem and subsequent requests to the primary endpoint will not return a retryable error.</span></span> <span data-ttu-id="a848c-192">Příklad, kdy k tomu může dojít je, když dojde k chybě přechodný síťový.</span><span class="sxs-lookup"><span data-stu-id="a848c-192">An example of where this might happen is when there is a transient network error.</span></span>

    <span data-ttu-id="a848c-193">V tomto scénáři není žádné snížení výkonu výrazné tomu, aby **LocationMode** nastavena na **PrimaryThenSecondary** jako tato situace nastane pouze zřídka.</span><span class="sxs-lookup"><span data-stu-id="a848c-193">In this scenario, there is no significant performance penalty in having **LocationMode** set to **PrimaryThenSecondary** as this only happens infrequently.</span></span>

*   <span data-ttu-id="a848c-194">Jedná o problém s alespoň jedním služby úložiště v primární oblasti a všechny následné žádosti do této služby v primární oblasti pravděpodobně se chcete vrátit opakovatelné chyby v časovém intervalu.</span><span class="sxs-lookup"><span data-stu-id="a848c-194">This is a problem with at least one of the storage services in the primary region and all subsequent requests to that service in the primary region are likely to return retryable errors for a period of time.</span></span> <span data-ttu-id="a848c-195">Příkladem je, pokud je primární oblasti úplně nedostupná.</span><span class="sxs-lookup"><span data-stu-id="a848c-195">An example of this is if the primary region is completely inaccessible.</span></span>

    <span data-ttu-id="a848c-196">V tomto scénáři je snížení výkonu vzhledem k tomu, že všechny vaše požadavky na čtení bude pokuste se nejdřív primární koncový bod, počkejte časový limit vyprší a potom přepnout na sekundární koncový bod.</span><span class="sxs-lookup"><span data-stu-id="a848c-196">In this scenario, there is a performance penalty because all your read requests will try the primary endpoint first, wait for the timeout to expire, then switch to the secondary endpoint.</span></span>

<span data-ttu-id="a848c-197">U těchto scénářů byste měli určit, existuje se probíhající problém s primární koncový bod a odeslání všech žádostí o přímo na sekundární koncový bod čtení nastavením **LocationMode** vlastnost **SecondaryOnly**.</span><span class="sxs-lookup"><span data-stu-id="a848c-197">For these scenarios, you should identify that there is an ongoing issue with the primary endpoint and send all read requests directly to the secondary endpoint by setting the **LocationMode** property to **SecondaryOnly**.</span></span> <span data-ttu-id="a848c-198">V tomto okamžiku změníte také aplikace spuštěna v režimu jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="a848c-198">At this time, you should also change the application to run in read-only mode.</span></span> <span data-ttu-id="a848c-199">Tento postup se označuje jako [jistič vzor](https://msdn.microsoft.com/library/dn589784.aspx).</span><span class="sxs-lookup"><span data-stu-id="a848c-199">This approach is known as the [Circuit Breaker Pattern](https://msdn.microsoft.com/library/dn589784.aspx).</span></span>

### <a name="update-requests"></a><span data-ttu-id="a848c-200">Žádosti o aktualizaci</span><span class="sxs-lookup"><span data-stu-id="a848c-200">Update requests</span></span>

<span data-ttu-id="a848c-201">Vzor jistič lze použít také k aktualizaci požadavky.</span><span class="sxs-lookup"><span data-stu-id="a848c-201">The Circuit Breaker pattern can also be applied to update requests.</span></span> <span data-ttu-id="a848c-202">Žádosti o aktualizaci však nelze přesměrovat do sekundárního úložiště, která je jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="a848c-202">However, update requests cannot be redirected to secondary storage, which is read-only.</span></span> <span data-ttu-id="a848c-203">Pro tyto požadavky, ponechte **LocationMode** vlastnost nastavena na hodnotu **PrimaryOnly** (výchozí).</span><span class="sxs-lookup"><span data-stu-id="a848c-203">For these requests, you should leave the **LocationMode** property set to **PrimaryOnly** (the default).</span></span> <span data-ttu-id="a848c-204">Ke zpracování těchto chyb, můžete použít metriky na tyto požadavky – například 10 selhání v řádku – a vaše prahová hodnota při splnění, přepnout aplikace do režimu jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="a848c-204">To handle these errors, you can apply a metric to these requests – such as 10 failures in a row – and when your threshold is met, switch the application into read-only mode.</span></span> <span data-ttu-id="a848c-205">Stejné metody pro vrácení slouží k aktualizaci režimu tak, jak je popsáno níže v další části o vzoru jistič.</span><span class="sxs-lookup"><span data-stu-id="a848c-205">You can use the same methods for returning to update mode as those described below in the next section about the Circuit Breaker pattern.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="a848c-206">Vzor jistič</span><span class="sxs-lookup"><span data-stu-id="a848c-206">Circuit Breaker pattern</span></span>

<span data-ttu-id="a848c-207">Použití vzoru jistič v aplikaci, můžete zabránit v opakování operace, která je pravděpodobně selžou opakovaně.</span><span class="sxs-lookup"><span data-stu-id="a848c-207">Using the Circuit Breaker pattern in your application can prevent it from retrying an operation that is likely to fail repeatedly.</span></span> <span data-ttu-id="a848c-208">Umožňuje aplikaci nadále spouštět spíše než zabírají čas při operaci je exponenciálnímu opakovat.</span><span class="sxs-lookup"><span data-stu-id="a848c-208">It allows the application to continue to run rather than taking up time while the operation is retried exponentially.</span></span> <span data-ttu-id="a848c-209">Navíc rozpozná, když byl opraven chyby, po kterém aplikace to zkuste znovu.</span><span class="sxs-lookup"><span data-stu-id="a848c-209">It also detects when the fault has been fixed, at which time the application can try the operation again.</span></span>

### <a name="how-to-implement-the-circuit-breaker-pattern"></a><span data-ttu-id="a848c-210">Implementace vzoru jistič</span><span class="sxs-lookup"><span data-stu-id="a848c-210">How to implement the circuit breaker pattern</span></span>

<span data-ttu-id="a848c-211">Pokud chcete zjistit, zda je problém s probíhající primární koncový bod, můžete sledovat, jak často klient zaznamená opakovatelné chyby.</span><span class="sxs-lookup"><span data-stu-id="a848c-211">To identify that there is an ongoing problem with a primary endpoint, you can monitor how frequently the client encounters retryable errors.</span></span> <span data-ttu-id="a848c-212">Protože každý případ se liší, je nutné rozhodnout, prahovou hodnotu, kterou chcete použít pro rozhodnutí přepnout sekundární koncový bod a spusťte aplikaci v režimu jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="a848c-212">Because each case is different, you have to decide on the threshold you want to use for the decision to switch to the secondary endpoint and run the application in read-only mode.</span></span> <span data-ttu-id="a848c-213">Může například rozhodnout, že k provedení přepínač, pokud jsou v řádek s žádné úspěchů 10 selhání.</span><span class="sxs-lookup"><span data-stu-id="a848c-213">For example, you could decide to perform the switch if there are 10 failures in a row with no successes.</span></span> <span data-ttu-id="a848c-214">Dalším příkladem je přepínač pokud selže 90 % požadavků v období 2 minut.</span><span class="sxs-lookup"><span data-stu-id="a848c-214">Another example is to switch if 90% of the requests in a 2-minute period fail.</span></span>

<span data-ttu-id="a848c-215">Pro prvního scénáře můžete jednoduše zachovat počet selhání a pokud je úspěšné dříve, než dorazila maximum, nastavit počet zpět na nulu.</span><span class="sxs-lookup"><span data-stu-id="a848c-215">For the first scenario, you can simply keep a count of the failures, and if there is a success before reaching the maximum, set the count back to zero.</span></span> <span data-ttu-id="a848c-216">Jedním ze způsobů k implementaci pro druhý scénář, je použít objekt MemoryCache (v rozhraní .NET).</span><span class="sxs-lookup"><span data-stu-id="a848c-216">For the second scenario, one way to implement it is to use the MemoryCache object (in .NET).</span></span> <span data-ttu-id="a848c-217">Pro každý požadavek přidání CacheItem do mezipaměti, nastavte hodnotu na úspěšné provedení (1) nebo selhání (0) a nastavte čas vypršení platnosti 2 minut od nyní (nebo vše, co je vaším omezením čas).</span><span class="sxs-lookup"><span data-stu-id="a848c-217">For each request, add a CacheItem to the cache, set the value to success (1) or fail (0), and set the expiration time to 2 minutes from now (or whatever your time constraint is).</span></span> <span data-ttu-id="a848c-218">Když je dosaženo času vypršení platnosti položky, položka je automaticky odstraněna.</span><span class="sxs-lookup"><span data-stu-id="a848c-218">When an entry's expiration time is reached, the entry is automatically removed.</span></span> <span data-ttu-id="a848c-219">Tím získáte okno postupného 2 minut.</span><span class="sxs-lookup"><span data-stu-id="a848c-219">This will give you a rolling 2-minute window.</span></span> <span data-ttu-id="a848c-220">Pokaždé, když musíte provést žádost službě úložiště, nejprve použijete dotaz Linq napříč objekt MemoryCache pro výpočet procenta úspěšnosti souhrnné zpracování hodnoty a vydělí počet.</span><span class="sxs-lookup"><span data-stu-id="a848c-220">Each time you make a request to the storage service, you first use a Linq query across the MemoryCache object to calculate the percent success by summing the values and dividing by the count.</span></span> <span data-ttu-id="a848c-221">Když procenta úspěšnosti klesne pod některé prahové hodnoty (například 10 %), nastavte **LocationMode** vlastnost pro čtení žádosti **SecondaryOnly** a přepínačů aplikace do režimu jen pro čtení, než budete pokračovat.</span><span class="sxs-lookup"><span data-stu-id="a848c-221">When the percent success drops below some threshold (such as 10%), set the **LocationMode** property for read requests to **SecondaryOnly** and switch the application into read-only mode before continuing.</span></span>

<span data-ttu-id="a848c-222">Prahovou hodnotu chyby, které umožňuje určit, kdy vytvořit přepínač se může lišit od služby ve vaší aplikaci, proto byste měli zvážit přitom konfigurovatelné parametry.</span><span class="sxs-lookup"><span data-stu-id="a848c-222">The threshold of errors used to determine when to make the switch may vary from service to service in your application, so you should consider making them configurable parameters.</span></span> <span data-ttu-id="a848c-223">Toto je také rozhodnete, kde se budou zpracovávat opakovatelné chyby z každé služby samostatně nebo jako jeden, jak je popsáno dříve.</span><span class="sxs-lookup"><span data-stu-id="a848c-223">This is also where you decide to handle retryable errors from each service separately or as one, as discussed previously.</span></span>

<span data-ttu-id="a848c-224">Je potřeba zamyslet se určuje způsob zpracování více instancí aplikace a co dělat, když zjistíte opakovatelné chyby v každé instanci.</span><span class="sxs-lookup"><span data-stu-id="a848c-224">Another consideration is how to handle multiple instances of an application, and what to do when you detect retryable errors in each instance.</span></span> <span data-ttu-id="a848c-225">Například můžete mít 20 virtuálních počítačů s stejnou aplikaci načíst.</span><span class="sxs-lookup"><span data-stu-id="a848c-225">For example, you may have 20 VMs running with the same application loaded.</span></span> <span data-ttu-id="a848c-226">Samostatně každá instance zpracovávat?</span><span class="sxs-lookup"><span data-stu-id="a848c-226">Do you handle each instance separately?</span></span> <span data-ttu-id="a848c-227">Pokud jedna instance spustí, dochází k problémům, chcete omezit odpovědi jenom jednu instanci, nebo chcete opakujte tak, aby měl reagovat všechny instance stejným způsobem, když jedna instance má problém?</span><span class="sxs-lookup"><span data-stu-id="a848c-227">If one instance starts having problems, do you want to limit the response to just that one instance, or do you want to try to have all instances respond in the same way when one instance has a problem?</span></span> <span data-ttu-id="a848c-228">Zpracování instance samostatně je mnohem jednodušší než pokusu o koordinaci odpovědi mezi nimi, ale tento postup závisí na architektuře vaší aplikace.</span><span class="sxs-lookup"><span data-stu-id="a848c-228">Handling the instances separately is much simpler than trying to coordinate the response across them, but how you do this depends on your application's architecture.</span></span>

### <a name="options-for-monitoring-the-error-frequency"></a><span data-ttu-id="a848c-229">Možnosti sledování četnost chyb</span><span class="sxs-lookup"><span data-stu-id="a848c-229">Options for monitoring the error frequency</span></span>

<span data-ttu-id="a848c-230">Máte tři hlavní možnosti sledování frekvenci opakování v primární oblasti, aby bylo možné určit, kdy přepnout na sekundární oblast a změňte aplikace spuštěna v režimu jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="a848c-230">You have three main options for monitoring the frequency of retries in the primary region in order to determine when to switch over to the secondary region and change the application to run in read-only mode.</span></span>

*   <span data-ttu-id="a848c-231">Přidejte obslužnou rutinu pro [ **bude opakován** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) událostí na [ **informacím OperationContext** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx) objekt můžete předat do úložiště požadavky – Toto je metoda zobrazí v tomto článku a používá se v doprovodné ukázce.</span><span class="sxs-lookup"><span data-stu-id="a848c-231">Add a handler for the [**Retrying**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) event on the [**OperationContext**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx) object you pass to your storage requests – this is the method displayed in this article and used in the accompanying sample.</span></span> <span data-ttu-id="a848c-232">Tyto události fire vždy, když klient pokus obnovuje žádost, které umožňují sledovat, jak často klient zaznamená opakovatelné chyby na primární koncový bod.</span><span class="sxs-lookup"><span data-stu-id="a848c-232">These events fire whenever the client retries a request, enabling you to track how often the client encounters retryable errors on a primary endpoint.</span></span>

    ```csharp 
    operationContext.Retrying += (sender, arguments) =>
    {
        // Retrying in the primary region
        if (arguments.Request.Host == primaryhostname)
            ...
    };
    ```

*   <span data-ttu-id="a848c-233">V [ **Evaluate** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) metoda v zásadách vlastní opakování, můžete spustit vlastní kód vždy, když probíhá opakování.</span><span class="sxs-lookup"><span data-stu-id="a848c-233">In the [**Evaluate**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) method in a custom retry policy, you can run custom code whenever a retry takes place.</span></span> <span data-ttu-id="a848c-234">Kromě zápisu při opakovaném pokusu se stane, to také vám dává možnost změny chování vaší opakování.</span><span class="sxs-lookup"><span data-stu-id="a848c-234">In addition to recording when a retry happens, this also gives you the opportunity to modify your retry behavior.</span></span>

    ```csharp 
    public RetryInfo Evaluate(RetryContext retryContext,
    OperationContext operationContext)
    {
        var statusCode = retryContext.LastRequestResult.HttpStatusCode;
        if (retryContext.CurrentRetryCount >= this.maximumAttempts
        || ((statusCode &gt;= 300 && statusCode &lt; 500 && statusCode != 408)
        || statusCode == 501 // Not Implemented
        || statusCode == 505 // Version Not Supported
            ))
        {
        // Do not retry
            return null;
        }

        // Monitor retries in the primary location
        ...

        // Determine RetryInterval and TargetLocation
        RetryInfo info =
            CreateRetryInfo(retryContext.CurrentRetryCount);

        return info;
    }
    ```

*   <span data-ttu-id="a848c-235">Je třetí přístup k implementaci vlastních monitorovací komponentu v aplikaci, které průběžně odešle příkaz ping váš koncový bod primárního úložiště s fiktivní číst požadavků (jako je například čtení malých objektů blob) k určení jeho stav.</span><span class="sxs-lookup"><span data-stu-id="a848c-235">The third approach is to implement a custom monitoring component in your application that continually pings your primary storage endpoint with dummy read requests (such as reading a small blob) to determine its health.</span></span> <span data-ttu-id="a848c-236">Bude to trvat až některé prostředky, ale není značné množství.</span><span class="sxs-lookup"><span data-stu-id="a848c-236">This would take up some resources, but not a significant amount.</span></span> <span data-ttu-id="a848c-237">Pokud k problému je zjistit, která dosáhne vaší prahové hodnoty, by pak proveďte přepínač tak, aby **SecondaryOnly** a režimu jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="a848c-237">When a problem is discovered that reaches your threshold, you would then perform the switch to **SecondaryOnly** and read-only mode.</span></span>

<span data-ttu-id="a848c-238">V určitém okamžiku můžete přepnout zpět na používá primární koncový bod a umožní aktualizace.</span><span class="sxs-lookup"><span data-stu-id="a848c-238">At some point, you will want to switch back to using the primary endpoint and allowing updates.</span></span> <span data-ttu-id="a848c-239">Pokud pomocí jedné z výše uvedených první dvě metody, může jednoduše přepnete zpět do primární koncový bod a povolit režim aktualizace po provedení nahodile vybrané množství času nebo počet operací.</span><span class="sxs-lookup"><span data-stu-id="a848c-239">If using one of the first two methods listed above, you could simply switch back to the primary endpoint and enable update mode after an arbitrarily selected amount of time or number of operations has been performed.</span></span> <span data-ttu-id="a848c-240">Pak můžete nechat ji znovu projít logika opakovaných pokusů.</span><span class="sxs-lookup"><span data-stu-id="a848c-240">You can then let it go through the retry logic again.</span></span> <span data-ttu-id="a848c-241">Pokud byl opraven problém, se bude nadále používat primární koncový bod a povolit aktualizace.</span><span class="sxs-lookup"><span data-stu-id="a848c-241">If the problem has been fixed, it will continue to use the primary endpoint and allow updates.</span></span> <span data-ttu-id="a848c-242">Pokud stále existuje problém, ji budou jednou přepněte zpátky na sekundární koncový bod a režimu jen pro čtení po selhání kritéria, které jste nastavili.</span><span class="sxs-lookup"><span data-stu-id="a848c-242">If there is still a problem, it will once more switch back to the secondary endpoint and read-only mode after failing the criteria you've set.</span></span>

<span data-ttu-id="a848c-243">Třetí scénář, jakmile otestováním koncový bod primárního úložiště opět úspěšné, můžete aktivovat přepínač zpět na **PrimaryOnly** a pokračovat v povolení aktualizace.</span><span class="sxs-lookup"><span data-stu-id="a848c-243">For the third scenario, when pinging the primary storage endpoint becomes successful again, you can trigger the switch back to **PrimaryOnly** and continue allowing updates.</span></span>

## <a name="handling-eventually-consistent-data"></a><span data-ttu-id="a848c-244">Zpracování nakonec byl konzistentní dat</span><span class="sxs-lookup"><span data-stu-id="a848c-244">Handling eventually consistent data</span></span>

<span data-ttu-id="a848c-245">RA-GRS funguje tak, že replikace transakce z primárního na sekundární oblast.</span><span class="sxs-lookup"><span data-stu-id="a848c-245">RA-GRS works by replicating transactions from the primary to the secondary region.</span></span> <span data-ttu-id="a848c-246">Tento proces replikace zaručuje, že se data v sekundární oblasti *nakonec byl konzistentní*.</span><span class="sxs-lookup"><span data-stu-id="a848c-246">This replication process guarantees that the data in the secondary region is *eventually consistent*.</span></span> <span data-ttu-id="a848c-247">To znamená, že všechny transakce v primární oblasti se nakonec objeví v sekundární oblasti, ale že mohou být prodleva předtím, než se objeví, a že neexistuje žádná záruka transakce přicházející do sekundární oblasti ve stejném pořadí jako, ve kterém byly původně uplatňují v primární oblasti.</span><span class="sxs-lookup"><span data-stu-id="a848c-247">This means that all the transactions in the primary region will eventually appear in the secondary region, but that there may be a lag before they appear, and that there is no guarantee the transactions arrive in the secondary region in the same order as that in which they were originally applied in the primary region.</span></span> <span data-ttu-id="a848c-248">Pokud vaše transakce přicházejí v sekundární oblasti mimo pořadí, můžete *může* vezměte v úvahu vaše data v sekundární oblasti, kterou chcete být v nekonzistentním stavu, dokud služba zachytí.</span><span class="sxs-lookup"><span data-stu-id="a848c-248">If your transactions arrive in the secondary region out of order, you *may* consider your data in the secondary region to be in an inconsistent state until the service catches up.</span></span>

<span data-ttu-id="a848c-249">Následující tabulka znázorňuje příklad co může dojít v případě, že aktualizujete podrobnosti zaměstnanec, aby se mu členem *správci* role.</span><span class="sxs-lookup"><span data-stu-id="a848c-249">The following table shows an example of what might happen when you update the details of an employee to make her a member of the *administrators* role.</span></span> <span data-ttu-id="a848c-250">Z důvodu v tomto příkladu to vyžaduje, můžete aktualizovat **zaměstnanec** entitu a aktualizace **role správce** entity s počtem celkový počet správců.</span><span class="sxs-lookup"><span data-stu-id="a848c-250">For the sake of this example, this requires you update the **employee** entity and update an **administrator role** entity with a count of the total number of administrators.</span></span> <span data-ttu-id="a848c-251">Všimněte si, jak aktualizace jsou použity mimo pořadí v sekundární oblasti.</span><span class="sxs-lookup"><span data-stu-id="a848c-251">Notice how the updates are applied out of order in the secondary region.</span></span>

| <span data-ttu-id="a848c-252">**Čas**</span><span class="sxs-lookup"><span data-stu-id="a848c-252">**Time**</span></span> | <span data-ttu-id="a848c-253">**Transakce**</span><span class="sxs-lookup"><span data-stu-id="a848c-253">**Transaction**</span></span>                                            | <span data-ttu-id="a848c-254">**Replikace**</span><span class="sxs-lookup"><span data-stu-id="a848c-254">**Replication**</span></span>                       | <span data-ttu-id="a848c-255">**Čas poslední synchronizace**</span><span class="sxs-lookup"><span data-stu-id="a848c-255">**Last Sync Time**</span></span> | <span data-ttu-id="a848c-256">**Výsledek**</span><span class="sxs-lookup"><span data-stu-id="a848c-256">**Result**</span></span> |
|----------|------------------------------------------------------------|---------------------------------------|--------------------|------------| 
| <span data-ttu-id="a848c-257">T0</span><span class="sxs-lookup"><span data-stu-id="a848c-257">T0</span></span>       | <span data-ttu-id="a848c-258">Transakce A:</span><span class="sxs-lookup"><span data-stu-id="a848c-258">Transaction A:</span></span> <br> <span data-ttu-id="a848c-259">Vložit zaměstnance</span><span class="sxs-lookup"><span data-stu-id="a848c-259">Insert employee</span></span> <br> <span data-ttu-id="a848c-260">entity v primární</span><span class="sxs-lookup"><span data-stu-id="a848c-260">entity in primary</span></span> |                                   |                    | <span data-ttu-id="a848c-261">Transakce A vložit do primární,</span><span class="sxs-lookup"><span data-stu-id="a848c-261">Transaction A inserted to primary,</span></span><br> <span data-ttu-id="a848c-262">není ještě nereplikovaly.</span><span class="sxs-lookup"><span data-stu-id="a848c-262">not replicated yet.</span></span> |
| <span data-ttu-id="a848c-263">T1</span><span class="sxs-lookup"><span data-stu-id="a848c-263">T1</span></span>       |                                                            | <span data-ttu-id="a848c-264">Transakce A</span><span class="sxs-lookup"><span data-stu-id="a848c-264">Transaction A</span></span> <br> <span data-ttu-id="a848c-265">replikovat do</span><span class="sxs-lookup"><span data-stu-id="a848c-265">replicated to</span></span><br> <span data-ttu-id="a848c-266">sekundární</span><span class="sxs-lookup"><span data-stu-id="a848c-266">secondary</span></span> | <span data-ttu-id="a848c-267">T1</span><span class="sxs-lookup"><span data-stu-id="a848c-267">T1</span></span> | <span data-ttu-id="a848c-268">Replikovat do sekundárního A transakce.</span><span class="sxs-lookup"><span data-stu-id="a848c-268">Transaction A replicated to secondary.</span></span> <br><span data-ttu-id="a848c-269">Čas poslední synchronizace aktualizovat.</span><span class="sxs-lookup"><span data-stu-id="a848c-269">Last Sync Time updated.</span></span>    |
| <span data-ttu-id="a848c-270">T2</span><span class="sxs-lookup"><span data-stu-id="a848c-270">T2</span></span>       | <span data-ttu-id="a848c-271">Transakce B:</span><span class="sxs-lookup"><span data-stu-id="a848c-271">Transaction B:</span></span><br><span data-ttu-id="a848c-272">Aktualizace</span><span class="sxs-lookup"><span data-stu-id="a848c-272">Update</span></span><br> <span data-ttu-id="a848c-273">Zaměstnanec entity</span><span class="sxs-lookup"><span data-stu-id="a848c-273">employee entity</span></span><br> <span data-ttu-id="a848c-274">v primární</span><span class="sxs-lookup"><span data-stu-id="a848c-274">in primary</span></span>  |                                | <span data-ttu-id="a848c-275">T1</span><span class="sxs-lookup"><span data-stu-id="a848c-275">T1</span></span>                 | <span data-ttu-id="a848c-276">Transakce B zapsána do primární,</span><span class="sxs-lookup"><span data-stu-id="a848c-276">Transaction B written to primary,</span></span><br> <span data-ttu-id="a848c-277">není ještě nereplikovaly.</span><span class="sxs-lookup"><span data-stu-id="a848c-277">not replicated yet.</span></span>  |
| <span data-ttu-id="a848c-278">T3</span><span class="sxs-lookup"><span data-stu-id="a848c-278">T3</span></span>       | <span data-ttu-id="a848c-279">Transakce C:</span><span class="sxs-lookup"><span data-stu-id="a848c-279">Transaction C:</span></span><br> <span data-ttu-id="a848c-280">Aktualizace</span><span class="sxs-lookup"><span data-stu-id="a848c-280">Update</span></span> <br><span data-ttu-id="a848c-281">Správce</span><span class="sxs-lookup"><span data-stu-id="a848c-281">administrator</span></span><br><span data-ttu-id="a848c-282">entitu role v</span><span class="sxs-lookup"><span data-stu-id="a848c-282">role entity in</span></span><br><span data-ttu-id="a848c-283">primární</span><span class="sxs-lookup"><span data-stu-id="a848c-283">primary</span></span> |                    | <span data-ttu-id="a848c-284">T1</span><span class="sxs-lookup"><span data-stu-id="a848c-284">T1</span></span>                 | <span data-ttu-id="a848c-285">Transakce zapsána do primární, C</span><span class="sxs-lookup"><span data-stu-id="a848c-285">Transaction C written to primary,</span></span><br> <span data-ttu-id="a848c-286">není ještě nereplikovaly.</span><span class="sxs-lookup"><span data-stu-id="a848c-286">not replicated yet.</span></span>  |
| <span data-ttu-id="a848c-287">*T4*</span><span class="sxs-lookup"><span data-stu-id="a848c-287">*T4*</span></span>     |                                                       | <span data-ttu-id="a848c-288">Transakce C</span><span class="sxs-lookup"><span data-stu-id="a848c-288">Transaction C</span></span> <br><span data-ttu-id="a848c-289">replikovat do</span><span class="sxs-lookup"><span data-stu-id="a848c-289">replicated to</span></span><br> <span data-ttu-id="a848c-290">sekundární</span><span class="sxs-lookup"><span data-stu-id="a848c-290">secondary</span></span> | <span data-ttu-id="a848c-291">T1</span><span class="sxs-lookup"><span data-stu-id="a848c-291">T1</span></span>         | <span data-ttu-id="a848c-292">Transakce C replikovat na sekundární.</span><span class="sxs-lookup"><span data-stu-id="a848c-292">Transaction C replicated to secondary.</span></span><br><span data-ttu-id="a848c-293">Nelze aktualizovat, protože LastSyncTime</span><span class="sxs-lookup"><span data-stu-id="a848c-293">LastSyncTime not updated because</span></span> <br><span data-ttu-id="a848c-294">ještě nebyla replikována transakce B.</span><span class="sxs-lookup"><span data-stu-id="a848c-294">transaction B has not been replicated yet.</span></span>|
| <span data-ttu-id="a848c-295">*T5*</span><span class="sxs-lookup"><span data-stu-id="a848c-295">*T5*</span></span>     | <span data-ttu-id="a848c-296">Ke čtení entit</span><span class="sxs-lookup"><span data-stu-id="a848c-296">Read entities</span></span> <br><span data-ttu-id="a848c-297">ze sekundární</span><span class="sxs-lookup"><span data-stu-id="a848c-297">from secondary</span></span>                           |                                  | <span data-ttu-id="a848c-298">T1</span><span class="sxs-lookup"><span data-stu-id="a848c-298">T1</span></span>                 | <span data-ttu-id="a848c-299">Získat zastaralé hodnotu pro zaměstnance</span><span class="sxs-lookup"><span data-stu-id="a848c-299">You get the stale value for employee</span></span> <br> <span data-ttu-id="a848c-300">entity vzhledem k tomu, že nebyla transakce B</span><span class="sxs-lookup"><span data-stu-id="a848c-300">entity because transaction B hasn't</span></span> <br> <span data-ttu-id="a848c-301">ještě nereplikovaly.</span><span class="sxs-lookup"><span data-stu-id="a848c-301">replicated yet.</span></span> <span data-ttu-id="a848c-302">Získat novou hodnotu</span><span class="sxs-lookup"><span data-stu-id="a848c-302">You get the new value for</span></span><br> <span data-ttu-id="a848c-303">entitu role správce vzhledem k tomu, že má C</span><span class="sxs-lookup"><span data-stu-id="a848c-303">administrator role entity because C has</span></span><br> <span data-ttu-id="a848c-304">replikovat.</span><span class="sxs-lookup"><span data-stu-id="a848c-304">replicated.</span></span> <span data-ttu-id="a848c-305">Čas poslední synchronizace stále ještě</span><span class="sxs-lookup"><span data-stu-id="a848c-305">Last Sync Time still hasn't</span></span><br> <span data-ttu-id="a848c-306">byla aktualizovat, protože transakce B</span><span class="sxs-lookup"><span data-stu-id="a848c-306">been updated because transaction B</span></span><br> <span data-ttu-id="a848c-307">nebyla replikována.</span><span class="sxs-lookup"><span data-stu-id="a848c-307">hasn't replicated.</span></span> <span data-ttu-id="a848c-308">Můžete zjistit</span><span class="sxs-lookup"><span data-stu-id="a848c-308">You can tell the</span></span><br><span data-ttu-id="a848c-309">Entita role správce je nekonzistentní</span><span class="sxs-lookup"><span data-stu-id="a848c-309">administrator role entity is inconsistent</span></span> <br><span data-ttu-id="a848c-310">protože je datum a čas entity za</span><span class="sxs-lookup"><span data-stu-id="a848c-310">because the entity date/time is after</span></span> <br><span data-ttu-id="a848c-311">Čas poslední synchronizace.</span><span class="sxs-lookup"><span data-stu-id="a848c-311">the Last Sync Time.</span></span> |
| <span data-ttu-id="a848c-312">*T6*</span><span class="sxs-lookup"><span data-stu-id="a848c-312">*T6*</span></span>     |                                                      | <span data-ttu-id="a848c-313">Transakce B</span><span class="sxs-lookup"><span data-stu-id="a848c-313">Transaction B</span></span><br> <span data-ttu-id="a848c-314">replikovat do</span><span class="sxs-lookup"><span data-stu-id="a848c-314">replicated to</span></span><br> <span data-ttu-id="a848c-315">sekundární</span><span class="sxs-lookup"><span data-stu-id="a848c-315">secondary</span></span> | <span data-ttu-id="a848c-316">T6</span><span class="sxs-lookup"><span data-stu-id="a848c-316">T6</span></span>                 | <span data-ttu-id="a848c-317">*T6* – mít všechny transakce prostřednictvím C</span><span class="sxs-lookup"><span data-stu-id="a848c-317">*T6* – All transactions through C have</span></span> <br><span data-ttu-id="a848c-318">byla replikovat, čas poslední synchronizace</span><span class="sxs-lookup"><span data-stu-id="a848c-318">been replicated, Last Sync Time</span></span><br> <span data-ttu-id="a848c-319">je aktualizována.</span><span class="sxs-lookup"><span data-stu-id="a848c-319">is updated.</span></span> |

<span data-ttu-id="a848c-320">V tomto příkladu se předpokládá, že klient přepíná na čtení ze sekundární oblasti v T5.</span><span class="sxs-lookup"><span data-stu-id="a848c-320">In this example, assume the client switches to reading from the secondary region at T5.</span></span> <span data-ttu-id="a848c-321">Můžou číst **role správce** entity v tuto chvíli, ale entita obsahuje hodnotu pro počet správců, který není konzistentní s počtem **zaměstnanec** entit, které jsou označeny jako správci v sekundární oblasti v tuto chvíli.</span><span class="sxs-lookup"><span data-stu-id="a848c-321">It can successfully read the **administrator role** entity at this time, but the entity contains a value for the count of administrators that is not consistent with the number of **employee** entities that are marked as administrators in the secondary region at this time.</span></span> <span data-ttu-id="a848c-322">Váš klient jednoduše zobrazit tuto hodnotu s riziko, že je nekonzistentní informace.</span><span class="sxs-lookup"><span data-stu-id="a848c-322">Your client could simply display this value, with the risk that it is inconsistent information.</span></span> <span data-ttu-id="a848c-323">Alternativně může klient pokusí zjistit, který **role správce** je ve stavu potenciálně nekonzistentní, protože aktualizace dojít mimo pořadí a potom informovat uživatele o této skutečnosti.</span><span class="sxs-lookup"><span data-stu-id="a848c-323">Alternatively, the client could attempt to determine that the **administrator role** is in a potentially inconsistent state because the updates have happened out of order, and then inform the user of this fact.</span></span>

<span data-ttu-id="a848c-324">Rozpoznat, zda má potenciálně nekonzistentní data, může klient použít hodnotu *čas poslední synchronizace* , můžete se kdykoli dotazováním služby úložiště.</span><span class="sxs-lookup"><span data-stu-id="a848c-324">To recognize that it has potentially inconsistent data, the client can use the value of the *Last Sync Time* that you can get at any time by querying a storage service.</span></span> <span data-ttu-id="a848c-325">Znamená to, čas, kdy byl naposledy data v sekundární oblasti konzistentní a když službu měl u všech transakcí před tento bod v čase.</span><span class="sxs-lookup"><span data-stu-id="a848c-325">This tells you the time when the data in the secondary region was last consistent and when the service had applied all the transactions prior to that point in time.</span></span> <span data-ttu-id="a848c-326">V příkladu výše, po vloží službu **zaměstnanec** entity v sekundární oblasti, čas poslední synchronizace je nastaven na *T1*.</span><span class="sxs-lookup"><span data-stu-id="a848c-326">In the example shown above, after the service inserts the **employee** entity in the secondary region, the last sync time is set to *T1*.</span></span> <span data-ttu-id="a848c-327">Zůstane v *T1* až do aktualizace služby **zaměstnanec** entity v sekundární oblasti, pokud je nastavena na *T6*.</span><span class="sxs-lookup"><span data-stu-id="a848c-327">It remains at *T1* until the service updates the **employee** entity in the secondary region when it is set to *T6*.</span></span> <span data-ttu-id="a848c-328">Pokud klient načte čas poslední synchronizace při přečte entity na *T5*, ho můžete porovnat s časovým razítkem u entity.</span><span class="sxs-lookup"><span data-stu-id="a848c-328">If the client retrieves the last sync time when it reads the entity at *T5*, it can compare it with the timestamp on the entity.</span></span> <span data-ttu-id="a848c-329">Pokud se časové razítko u entity později než čas poslední synchronizace, pak tato entita je ve stavu potenciálně nekonzistentní a může trvat vše, co je pro vaši aplikaci příslušnou akci.</span><span class="sxs-lookup"><span data-stu-id="a848c-329">If the timestamp on the entity is later than the last sync time, then the entity is in a potentially inconsistent state, and you can take whatever is the appropriate action for your application.</span></span> <span data-ttu-id="a848c-330">Použít toto pole je nutné vědět, kdy byla dokončena poslední aktualizace na primární.</span><span class="sxs-lookup"><span data-stu-id="a848c-330">Using this field requires that you know when the last update to the primary was completed.</span></span>

## <a name="testing"></a><span data-ttu-id="a848c-331">Testování</span><span class="sxs-lookup"><span data-stu-id="a848c-331">Testing</span></span>

<span data-ttu-id="a848c-332">Je důležité k testování, že chování vaší aplikace podle očekávání, pokud se setká s opakovatelnou chyby.</span><span class="sxs-lookup"><span data-stu-id="a848c-332">It's important to test that your application behaves as expected when it encounters retryable errors.</span></span> <span data-ttu-id="a848c-333">Například je potřeba provést testování, aby aplikace přepínače na sekundární a do režimu jen pro čtení, když zjistí problém a přepínače zpět Jakmile primární oblasti opět k dispozici.</span><span class="sxs-lookup"><span data-stu-id="a848c-333">For example, you need to test that the application switches to the secondary and into read-only mode when it detects a problem, and switches back when the primary region becomes available again.</span></span> <span data-ttu-id="a848c-334">K tomu potřebujete způsob, jak simulovat opakovatelné chyb a řízení, jak často k nim dojde.</span><span class="sxs-lookup"><span data-stu-id="a848c-334">To do this, you need a way to simulate retryable errors and control how often they occur.</span></span>

<span data-ttu-id="a848c-335">Můžete použít [Fiddler](http://www.telerik.com/fiddler) zachytí a upravit odpovědi HTTP ve skriptu.</span><span class="sxs-lookup"><span data-stu-id="a848c-335">You can use [Fiddler](http://www.telerik.com/fiddler) to intercept and modify HTTP responses in a script.</span></span> <span data-ttu-id="a848c-336">Tento skript můžete identifikovat odpovědi, které pocházejí z váš primární koncový bod a změnit stavový kód protokolu HTTP na takový, který Klientská knihovna pro úložiště rozpozná jako Opakovatelná chyba.</span><span class="sxs-lookup"><span data-stu-id="a848c-336">This script can identify responses that come from your primary endpoint and change the HTTP status code to one that the Storage Client Library recognizes as a retryable error.</span></span> <span data-ttu-id="a848c-337">Tento fragment kódu ukazuje jednoduchý příklad Fiddler skriptu, který zabrání odpovědi ke čtení požadavky DHCP proti **employeedata** tabulky vrátit 502 stav:</span><span class="sxs-lookup"><span data-stu-id="a848c-337">This code snippet shows a simple example of a Fiddler script that intercepts responses to read requests against the **employeedata** table to return a 502 status:</span></span>

```java
static function OnBeforeResponse(oSession: Session) {
    ...
    if ((oSession.hostname == "\[yourstorageaccount\].table.core.windows.net")
      && (oSession.PathAndQuery.StartsWith("/employeedata?$filter"))) {
        oSession.responseCode = 502;
    }
}
```

<span data-ttu-id="a848c-338">Tento příklad zachytí většímu počtu požadavků a změnit jedině tak může rozšířit **responseCode** u některých z nich lépe simulace scénářem z reálného prostředí.</span><span class="sxs-lookup"><span data-stu-id="a848c-338">You could extend this example to intercept a wider range of requests and only change the **responseCode** on some of them to better simulate a real-world scenario.</span></span> <span data-ttu-id="a848c-339">Další informace o přizpůsobení Fiddler skriptů najdete v tématu [úprava požadavek nebo odpověď](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) v dokumentaci k aplikaci Fiddler.</span><span class="sxs-lookup"><span data-stu-id="a848c-339">For more information about customizing Fiddler scripts, see [Modifying a Request or Response](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) in the Fiddler documentation.</span></span>

<span data-ttu-id="a848c-340">Pokud jste provedli prahové hodnoty pro přepínání vaší aplikace do režimu jen pro čtení konfigurovat, bude snazší testování chování se svazky mimo produkční transakce.</span><span class="sxs-lookup"><span data-stu-id="a848c-340">If you have made the thresholds for switching your application to read-only mode configurable, it will be easier to test the behavior with non-production transaction volumes.</span></span>

## <a name="next-steps"></a><span data-ttu-id="a848c-341">Další kroky</span><span class="sxs-lookup"><span data-stu-id="a848c-341">Next Steps</span></span>

* <span data-ttu-id="a848c-342">Další informace o přístup pro čtení geografická redundance, včetně další příklad nastavení LastSyncTime, najdete v tématu [možnosti redundance úložiště Windows Azure a geograficky redundantní úložiště s přístupem pro čtení](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/).</span><span class="sxs-lookup"><span data-stu-id="a848c-342">For more information about Read Access Geo-Redundancy, including another example of how the LastSyncTime is set, please see [Windows Azure Storage Redundancy Options and Read Access Geo Redundant Storage](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/).</span></span>

* <span data-ttu-id="a848c-343">Kompletní příklad znázorňující aby přepínač mezi primární a sekundární koncové body, najdete v tématu [Azure Samples – vzor jistič pomocí úložiště RA-GRS](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs).</span><span class="sxs-lookup"><span data-stu-id="a848c-343">For a complete sample showing how to make the switch back and forth between the Primary and Secondary endpoints, please see [Azure Samples – Using the Circuit Breaker Pattern with RA-GRS storage](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs).</span></span>
